I"Y<h1 id="ch6-内存模型简介-存储设备">Ch6 内存模型简介-存储设备</h1>

<p>在本章中，我们将简介ROM和闪存这一类低速存储设备， 并研究用于在闪存中储存信息的浮栅二极管。 最后， 我们将对不同类型的低速存储设备进行简要介绍， 并探讨如何在Verilog中定义存储。</p>
<ol>
  <li>只读存储器 <code class="language-plaintext highlighter-rouge">ROM</code> 和闪存</li>
  <li>其他的低速存储设备: 磁盘和光盘</li>
  <li>存储在 <code class="language-plaintext highlighter-rouge">Verilog</code> 中的定义方式</li>
</ol>

<p><br />
<br /></p>

<h2 id="1-只读存储器-rom-和闪存">1. 只读存储器 <code class="language-plaintext highlighter-rouge">ROM</code> 和闪存</h2>

<h3 id="11-只读存储器">1.1 只读存储器</h3>
<p>只读存储器 <code class="language-plaintext highlighter-rouge">ROM</code> 的电路设计原理和随机存储器相近, 但成本更低. <code class="language-plaintext highlighter-rouge">ROM</code> 和 <code class="language-plaintext highlighter-rouge">RAM</code> 的主要差别在于: <code class="language-plaintext highlighter-rouge">ROM</code> 是 <strong>只读的非易失性存储器</strong>, 通常用于存储没有修改必要的核心操作系统程序, 固件或微码.</p>

<p>对于大部分的只读存储器而言, 它们承载的数据在工厂生产阶段即被写入, 并且这个过程是不可逆的. 只读存储器成本低廉, 常用于 <code class="language-plaintext highlighter-rouge">ASIC</code> (特殊应用集成电路). <code class="language-plaintext highlighter-rouge">ROM</code> 的访问界面和 <code class="language-plaintext highlighter-rouge">SRAM</code> 相似, 并且一些可被二次写入的 <code class="language-plaintext highlighter-rouge">ROM</code> 同样具有写入引脚:</p>

<p>随着技术的发展, 所谓的 “只读存储器” 类别中也出现了可在出厂后被一次性重编程或可被用户多次写入的产品, 称其为 <code class="language-plaintext highlighter-rouge">PROM</code> 或 <code class="language-plaintext highlighter-rouge">EPROM/EEPROM</code>.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PROM</code><br />
全称为 <code class="language-plaintext highlighter-rouge">Programmable ROM</code>, 是一种可在出厂后被一次性重编程的只读存储器. 数据在生产过程中并不会被烧录其中, 而是需要特殊的设备才能实现数据的烧录. 数据烧录过程中, 位于 <code class="language-plaintext highlighter-rouge">PROM</code> 内部用以标示二进制位的保险丝会根据所要烧录的数据内容而选择性熔断, 因而对其进行的数据烧录是不可逆的, 一旦数据在烧录过程中出现错误, 存储芯片只能被废弃.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">EPROM</code><br />
全称为 <code class="language-plaintext highlighter-rouge">Erasable Programmable ROM</code>, 使用浮栅阵列存储数据, 所存储的数据可通过紫外线照射而抹除, 并可以多次写入. 这类存储芯片常见于 $21$ 世纪早期的 <code class="language-plaintext highlighter-rouge">PC</code> 主板上用来存储 <code class="language-plaintext highlighter-rouge">BIOS</code> 数据, 现在已经极为罕见.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">EEPROM</code><br />
全称为 <code class="language-plaintext highlighter-rouge">Electroinc Erasable Programmable ROM</code>, 使用浮栅二极管阵列存储数据, 数据使用纯电路方式即可写入和抹除, 是最为常见的存储设备类别. 和随机存储器 <code class="language-plaintext highlighter-rouge">RAM</code> 不同, <code class="language-plaintext highlighter-rouge">EEPROM</code> 在读取数据时的寻址时间相对写入数据所消耗的时间要长得多. 对于实现方式不同的 <code class="language-plaintext highlighter-rouge">EEPROM</code> 而言, 它所支持的数据抹除方式也有不同: 若某个 <code class="language-plaintext highlighter-rouge">EEPROM</code> 由多个容量较小的块组合而成, 那么在抹除数据时, 可以抹除的最小单位为块.</p>
  </li>
</ul>

<p>闪存, 包括 <code class="language-plaintext highlighter-rouge">NAND</code>, <code class="language-plaintext highlighter-rouge">Solid State Drive</code> 等均属于 <code class="language-plaintext highlighter-rouge">EEPROM</code> 类别. 相对 <code class="language-plaintext highlighter-rouge">SRAM</code> 或 <code class="language-plaintext highlighter-rouge">DRAM</code>, 它们的速度要低得多.</p>

<p><br /></p>

<h3 id="12-浮栅二极管">1.2 浮栅二极管</h3>
<p>下面我们研究 <strong>浮栅二极管</strong>: <br /></p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201231102241.png" alt="20201231102241" /></p>

<p>浮栅二极管 (<code class="language-plaintext highlighter-rouge">Floating Gate transistor</code>) 是 金属-氧化物半导体场效应二极管 (<code class="language-plaintext highlighter-rouge">MOSFET</code>) 的一个变体. <code class="language-plaintext highlighter-rouge">MOSFET</code> 有三个端子, 即栅极、源极和漏极. <code class="language-plaintext highlighter-rouge">MOSFET</code> 的名称来自其结构: 金属层位于非导电隔离层顶部，而该隔离层又在半导体层的上方. 该二极管用于控制源极和漏极之间的传导.</p>

<p>源极和漏极被一个半导体通道所分隔开. 当一个够大的电位差施于 <code class="language-plaintext highlighter-rouge">MOSFET</code> 的栅极与源极之间时, 电场会在氧化层下方的半导体表面形成感应电荷, 而这时反转通道（<code class="language-plaintext highlighter-rouge">Inversion Channel</code>）就会形成, 其极性与其漏极与源极相同. 通道形成后，<code class="language-plaintext highlighter-rouge">MOSFET</code> 即可让电流通过, 而依据施于栅极的电压值不同, 可由 <code class="language-plaintext highlighter-rouge">MOSFET</code> 的通道流过的电流大小亦会受其控制而改变.</p>

<ul>
  <li>
    <p>数据写入过程<br />
在不对二极管的栅极施加电压时, 漏极与源极之间为开路. 要存储信息, 我们只需对栅极施加强电压并将漏极和源极接地. 这将导致在隔离层之下的栅极和源极之间形成传导通道. 电子将在这个区域聚集, 充能后突破隔离层到达浮栅门. 在上下两层隔离带的控制之下, 浮栅门中存储的电子即使在栅极施加的电压被撤除后也很难自由溢出. 
<img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201231104839.png" alt="20201231104839" /></p>
  </li>
  <li>
    <p>数据读取过程<br />
当浮栅中注入或释放了电子时, 该二极管的导通阈值电压会发生改变. 因此, 只需要对栅极施加一个位于充/放电状态下的导通阈值电压之间的中间电平, 使得浮栅中存有电子的二极管无法导通而放电后的浮栅可以被导通. 这样, 通过检测该二极管的源极和漏极之间能否允许电流流过, 即可判断它处于何种状态之下.</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201231104928.png" alt="20201231104928" /></p>
  </li>
</ul>

<p>下面盗用源于知乎的一张小图对 <code class="language-plaintext highlighter-rouge">SLC, MLC, TLC</code> 进行傻瓜化介绍:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/mem.png" alt="mem" /></p>

<p><br /></p>

<h3 id="13-存储块">1.3 存储块</h3>

<p>单片内存颗粒的存储容量和支持的数据位宽都是有限的. 通过将这些内存颗粒并行连接, 就可以满足更先进架构, 如 <code class="language-plaintext highlighter-rouge">32</code> 位或 <code class="language-plaintext highlighter-rouge">64</code> 位计算机的需要. 
如下图所示: 我们将两个 $1$ MB, $8$ 位宽的存储块并行连接, 构成了一块 $1$MB, $16$ 位宽的存储. 两个子块共享相同的地址总线, 而作为输出的数据总线由两个子块的输出分别组合而成. 在这个结构中, 两个子块分别负责了较高位的 $8$ 位数据输出和较低位的输出. 这样的层级构造对处理器而言会被抽象为一个 $16$ 位宽的存储块. 如果我们需要更大的数据位宽, 可以用类似的方法对并联更多的存储块以满足需求.</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201231112306.png" alt="20201231112306" /></p>

<p>除了并行连接多个位宽较小的子块实现更大的数据总线位宽以外, 我们还可以将它们串行连接以获取更大的存储深度 (即更大的存储容量).</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201231112641.png" alt="20201231112641" /></p>

<p><br /></p>

<h2 id="2-其他的低速存储设备-磁盘和光盘">2. 其他的低速存储设备: 磁盘和光盘</h2>

<p>扩展阅读内容, 摸了(</p>

<p><br /></p>

<h2 id="3-存储在-verilog-中的定义方式">3. 存储在 <code class="language-plaintext highlighter-rouge">Verilog</code> 中的定义方式</h2>

<h3 id="31-一般化定义">3.1 一般化定义</h3>
<p>从抽象的角度来看, 存储和数组一样, 都可被视为一列数据, 并且可以对指定位置处的数据进行读取或者写入.</p>

<p>要在 <code class="language-plaintext highlighter-rouge">Verilog</code> 中定义一个数组, 我们只需要定义一个具有位宽和维度这两个属性的, 以寄存器为数据类型的变量:</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>  <span class="kt">reg</span> <span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>   <span class="n">memory</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span> <span class="mi">2</span><span class="o">^{</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">}</span><span class="p">]</span>
  <span class="p">;</span> <span class="n">implement</span> <span class="n">an</span> <span class="n">array</span> <span class="k">with</span> <span class="mi">2</span><span class="o">^{</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">}</span> <span class="n">locations</span><span class="p">,</span> <span class="n">each</span> <span class="n">n</span><span class="o">-</span><span class="nb">bits</span> <span class="n">wide</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>而要从所定义的存储器读取或写入某个位置的变量, 我们只需要提供一个地址:</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="p">;</span> <span class="n">READ</span><span class="o">:</span>
<span class="n">address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">01</span><span class="n">C</span><span class="p">;</span>
<span class="n">data_read</span> <span class="o">=</span> <span class="n">memory</span><span class="p">[</span><span class="n">address</span><span class="p">];</span>

<span class="p">;</span> <span class="n">the</span> <span class="n">variable</span> <span class="err">'</span><span class="n">address</span><span class="err">'</span> <span class="n">will</span> <span class="n">contain</span> <span class="n">the</span> <span class="k">context</span> <span class="n">from</span> <span class="n">address</span> <span class="err">'</span><span class="o">&amp;</span><span class="mi">01</span><span class="n">C</span><span class="err">'</span><span class="p">.</span> 

<span class="p">;</span><span class="o">----</span><span class="n">breaking</span> <span class="n">line</span><span class="o">----</span>

<span class="p">;</span> <span class="n">WRITE</span><span class="o">:</span>
<span class="n">address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="mi">0</span><span class="n">F2</span><span class="p">;</span>
<span class="n">data_to_write</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">FFFF</span>
<span class="n">memory</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_to_write</span><span class="p">;</span>

<span class="p">;</span> <span class="n">the</span> <span class="n">value</span> <span class="err">'</span><span class="o">&amp;</span><span class="n">FFFF</span><span class="err">'</span> <span class="n">will</span> <span class="n">be</span> <span class="n">written</span> <span class="n">to</span> <span class="n">address</span> <span class="err">'</span><span class="o">&amp;</span><span class="mi">0</span><span class="n">F2</span><span class="err">'</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<h3 id="32-单端口-ram">3.2 单端口 <code class="language-plaintext highlighter-rouge">RAM</code></h3>
<p>单端口 <code class="language-plaintext highlighter-rouge">RAM</code> 是一种只能串行执行读/写请求的存储设备. 它只受两个信号控制: 使能控制信号 <code class="language-plaintext highlighter-rouge">en</code> 和写入控制信号 <code class="language-plaintext highlighter-rouge">wr</code>, 另有一条数据总线用于传输要被写入或读取的数据.</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201231173618.png" alt="20201231173618" /></p>

<p>在厘清其基本抽象结构后, 我们可以很容易地在 <code class="language-plaintext highlighter-rouge">Verilog</code> 中设计出单端口 <code class="language-plaintext highlighter-rouge">RAM</code> 这一时序电路:</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">module</span> <span class="n">single_port_ram</span>  <span class="p">(</span><span class="kt">input</span> <span class="kt">wire</span>        <span class="n">en</span><span class="p">,</span> <span class="n">wr</span>
                         <span class="kt">input</span> <span class="kt">wire</span>        <span class="n">clock</span><span class="p">;</span>
                         <span class="kt">input</span> <span class="kt">wire</span> <span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">data_in</span><span class="p">;</span>
                         <span class="kt">input</span> <span class="kt">wire</span> <span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">address</span><span class="p">;</span>
                         <span class="kt">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">data_out</span><span class="p">;)</span>
  
<span class="kt">reg</span> <span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">data_RAM</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">65535</span><span class="p">];</span>

<span class="k">always</span> <span class="o">@</span> <span class="p">(</span><span class="kt">posedge</span> <span class="n">clock</span><span class="p">)</span>              <span class="p">;</span> <span class="n">synchronous</span> <span class="n">circuit</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">en</span><span class="p">)</span>                             <span class="p">;</span> <span class="n">only</span> <span class="k">if</span> <span class="n">enabled</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wr</span><span class="p">)</span>
      <span class="n">data_RAM</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data_in</span><span class="p">;</span>   <span class="p">;</span> <span class="n">perform</span> <span class="n">mem</span> <span class="nb">write</span>
    <span class="k">else</span>
      <span class="n">data_out</span> <span class="o">&lt;=</span> <span class="n">data_RAM</span><span class="p">[</span><span class="n">address</span><span class="p">];</span>  <span class="p">;</span> <span class="n">perform</span> <span class="n">mem</span> <span class="n">read</span>

<span class="k">endmodule</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<h3 id="33-多端口-ram">3.3 多端口 <code class="language-plaintext highlighter-rouge">RAM</code></h3>
<p>和单端口 <code class="language-plaintext highlighter-rouge">RAM</code> 相比, 多端口 <code class="language-plaintext highlighter-rouge">RAM</code> 有多条数据输入和输出总线, 并且设有多条控制信号以单独控制每一条总线, 这使得它可以并行读/写数据. 下面以双端口 <code class="language-plaintext highlighter-rouge">RAM</code> 为例:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201231174646.png" alt="20201231174646" /></p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="k">module</span> <span class="n">dual_port_ram</span>    <span class="p">(</span><span class="kt">input</span> <span class="kt">wire</span>        <span class="n">en1</span><span class="p">,</span> <span class="n">en2</span><span class="p">,</span> <span class="n">wr</span>
                         <span class="kt">input</span> <span class="kt">wire</span>        <span class="n">clock</span><span class="p">;</span>
                         <span class="kt">input</span> <span class="kt">wire</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">data_in</span><span class="p">;</span>
                         <span class="kt">input</span> <span class="kt">wire</span> <span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">address1</span><span class="p">,</span> <span class="n">address2</span><span class="p">;</span>
                         <span class="kt">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">data_out1</span><span class="p">,</span> <span class="n">data_out2</span><span class="p">;)</span>
  
<span class="kt">reg</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">data_RAM</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">65535</span><span class="p">];</span>

<span class="k">always</span> <span class="o">@</span> <span class="p">(</span><span class="kt">posedge</span> <span class="n">clock</span><span class="p">)</span>               <span class="p">;</span> <span class="n">synchronous</span> <span class="n">circuit</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">en1</span><span class="p">)</span>                             <span class="p">;</span> <span class="n">only</span> <span class="k">if</span> <span class="n">enabled</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wr</span><span class="p">)</span>
      <span class="n">data_RAM</span><span class="p">[</span><span class="n">address1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">data_in</span><span class="p">;</span>   <span class="p">;</span> <span class="n">perform</span> <span class="n">mem</span> <span class="nb">write</span>
    <span class="k">else</span>
      <span class="n">data_out1</span> <span class="o">&lt;=</span> <span class="n">data_RAM</span><span class="p">[</span><span class="n">address1</span><span class="p">];</span> <span class="p">;</span> <span class="n">perform</span> <span class="n">mem</span> <span class="n">read</span>
  

<span class="k">always</span> <span class="o">@</span> <span class="p">(</span><span class="kt">posedge</span> <span class="n">clock</span><span class="p">)</span>               <span class="p">;</span> <span class="n">synchronous</span> <span class="n">circuit</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">en2</span><span class="p">)</span>                             <span class="p">;</span> <span class="n">READONLY</span>
    <span class="n">data_out2</span> <span class="o">&lt;=</span> <span class="n">data_RAM</span><span class="p">[</span><span class="n">address2</span><span class="p">];</span>   <span class="p">;</span> <span class="n">perform</span> <span class="n">mem</span> <span class="n">read</span>

<span class="k">endmodule</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>双端口 <code class="language-plaintext highlighter-rouge">RAM</code> 通常被用作显存 (<code class="language-plaintext highlighter-rouge">VRAM</code>). 其特性使得在处理器将显示信息写入 <code class="language-plaintext highlighter-rouge">VRAM</code> 的同时, 用于输出图像的硬件电路可以同时从 <code class="language-plaintext highlighter-rouge">VRAM</code> 中读取信息.</p>

<p><br /></p>

:ET