I""<h1 id="语言和正则表达式">语言和正则表达式</h1>
<p>在本章中, 我们将概述语言和正则表达式的相关定义, 性质与其他内容.</p>

<p><br /></p>

<h2 id="1-基本术语和概念">1. 基本术语和概念</h2>
<p>我们首先引入一系列基本概念:</p>

<p><strong>定义 1.1.1</strong> 符号</p>
<blockquote>
  <p>符号是组成字符串的最小单位, 不可被继续分割, 在形式逻辑中亦被称为字母 (<code class="language-plaintext highlighter-rouge">letter</code>), 常使用 $x, y, z, \cdots$ 表示.</p>
</blockquote>

<p><br /></p>

<p><strong>定义 1.1.2</strong> 字母表</p>
<blockquote>
  <p>字母表是由符号组成的集合, 指代任意字母表的符号是 $\Sigma$.</p>
</blockquote>

<p><br /></p>

<p><strong>定义 1.1.3</strong> 字符串</p>
<blockquote>
  <p>字符串由 $0$ 或更多的符号组成, 在形式逻辑中亦被称为文字 (<code class="language-plaintext highlighter-rouge">word</code>), 使用 $s, t, u, \cdots$ 表示.</p>
</blockquote>

<p><br /></p>

<p><strong>定义 1.1.4</strong> 空文字</p>
<blockquote>
  <p>空文字是不包含任何符号的字符串, 其长为 $0$, 使用 $\epsilon$ 表示.</p>
</blockquote>

<p><br /></p>

<p><strong>定义 1.1.5</strong> 连接</p>
<blockquote>
  <p>连接是将两个字符串头尾相接组成新字符串的操作. <br />
我们使用 <strong>幂</strong> 简化重复的连接, 如: 
\((010)^3 = 010010010.\)</p>
</blockquote>

<p><br /></p>

<p><strong>定义 1.1.6</strong> 语言</p>
<blockquote>
  <p>语言是由文字组成的集合, 使用 $\mathscr{L}_1, \mathscr{L}_2, \cdots$ 表示.</p>
</blockquote>

<p><br /></p>

<p>在上述的定义中, 我们将语言及其组成描述为集合或是集合中的元素, 通过引入对集合的各种操作 (也就是运用“模式”), 我们可以在给定语言的基础上生成新的语言. 可行的操作如下:</p>

<ul>
  <li>
    <p>并: <br />可以将两个不同的语言作并运算得到新的语言.</p>
  </li>
  <li>
    <p>交: <br />可以将两个不同的语言作交运算得到新的语言.</p>
  </li>
  <li>
    <p>相对补 (<code class="language-plaintext highlighter-rouge">Set Difference</code>): <br />将两个不同的语言作相对补运算, 得到仅包含由某一种语言所独有的文字所组成的新语言.</p>
  </li>
  <li>
    <p>绝对补 (<code class="language-plaintext highlighter-rouge">Set Complement</code>): <br />将两个不同的语言作绝对补运算, 得到新的语言.</p>
  </li>
  <li>
    <p>连接 (<code class="language-plaintext highlighter-rouge">Concatenation</code>): <br />
取任意两个基于字母表 $\Sigma$ 的语言 $\mathscr{L_1}, \mathscr{L_2}$, 有:</p>

\[\mathscr{L_1} \cdot \mathscr{L_2} \{s \cdot t \vert s \in \mathscr{L_1}, t \in \mathscr{L_2}\}.\]
  </li>
  <li>任意 $n$ 次连接 (<code class="language-plaintext highlighter-rouge">n-ary Concatenation</code>): <br />
    <center>

$$
\begin{aligned}
\mathscr{L^n} &amp;= \{s_1\cdot s_2 \cdots s_n ~\vert~ \forall s_i \in \mathscr{L} , 1 \leqslant i \leqslant n\}\\
\text{and}\\
\mathscr{L^0} &amp;= \{s_1\cdot s_2 \cdots s_n ~\vert~ \forall s_i \in \mathscr{L} , 1 \leqslant i \leqslant n\}.\\
\end{aligned}
$$

</center>
  </li>
  <li>克莱尼星号 (<code class="language-plaintext highlighter-rouge">Kleene Star</code>):<br />
    <center>

$$
\begin{aligned}
\mathscr{L^*} &amp;= \{s_1s_2\cdots s_n ~\vert~ n \in \mathbb{N}, s_1, s_2, \cdots, s_n \in \mathscr{L}\} \\ 
&amp;= \bigcup_{n \in \mathbb{N}} \mathscr{L^n}\\
\text{and}\\
\emptyset^* &amp;= \bigcup_{n \in \mathbb{N}} \emptyset^n = \{\epsilon\} = \mathscr{L^0} ~~\text{for all} ~~ \mathscr{L}.\\
\end{aligned}
$$

</center>
  </li>
</ul>

<p><br /></p>

<h2 id="2-使用模式-pattern-描述语言">2. 使用模式 (<code class="language-plaintext highlighter-rouge">Pattern</code>) 描述语言</h2>

<p>我们可以使用在上一节中所定义的模式对语言进行描述:</p>

<blockquote>
  <p>一般地, 我们使用 <code class="language-plaintext highlighter-rouge">|</code> 表示并, 使用 <code class="language-plaintext highlighter-rouge">*</code> 表示克莱尼星号, 使用括号限定相关符号的作用域. 我们可以使用这种方法表示一部分语言. 而为了表示更多的语言, 我们引入了 <strong>正则表达式</strong>.</p>
</blockquote>

<p><br /></p>

<h2 id="3-正则表达式">3. 正则表达式</h2>

<p>正则表达式是对字符串进行操作的逻辑公式. 它是对指定语言中的所有文字基于特定规则过滤的逻辑.一般地, 正则表达式的定义如下:</p>

<p><strong>定义1.3.1</strong> 正则表达式 (<code class="language-plaintext highlighter-rouge">Pattern, Regular Expression</code>)</p>
<blockquote>
  <p>设字母表 $\Sigma$. <strong>正则表达式</strong> 或 <strong>模式</strong> 是基于字母表
\(\Sigma^{\text{pat}} = \Sigma \cup  \{\emptyset, \epsilon, \vert, *, (, )\}\)
中的, 任何由下列的一个或多个递归定义所生成的文字:</p>
  <ul>
    <li>$\Sigma$ 中的任一个字母</li>
    <li>空集 (空模式) $\emptyset$ 或 空文字 $\epsilon$</li>
    <li>某两个正则表达式的并 (<code class="language-plaintext highlighter-rouge">Union</code>)</li>
    <li>某两个正则表达式的连接 (<code class="language-plaintext highlighter-rouge">Concatenation</code>)</li>
    <li>在某个正则表达式上所施加的克莱尼星号<br /></li>
  </ul>

  <p>在正则表达式中, $($ 和 $)$ 用于限定克莱尼星号, 连接算符和取并算符的作用域.</p>
</blockquote>

<p><br /></p>

<p>除了精确地表述某种语言的生成规则外, 正则表达式同样用于模式的识别和文字的提取:</p>

<p><br /></p>

<p><strong>定义1.3.2</strong> 正则表达式的匹配 (<code class="language-plaintext highlighter-rouge">matching</code>)</p>
<blockquote>
  <p>设 $p$ 为基于字母表 $\Sigma$ 的一种模式 (亦即正则表达式), $s$ 为基于 $\Sigma$ 的一个文字. 我们称 $s$ 与 $p$ 匹配, 若下列条件中至少有一种满足:</p>
  <ul>
    <li>该模式为 $\epsilon$, 并且 $s$ 就是空字符 $\epsilon$.</li>
    <li>该模式为 $x, ~~ x \in \Sigma$ 且 $s = x$.</li>
    <li>该模式为 $(p_1p_2)$, 且 $\exists s_1, s_2$ 分别和两个模式 $p_1, p_2$ 匹配, $s = s_1s_2$.</li>
    <li>该模式为 $(p_1 \vert p_2)$, 且 $s$ 匹配 $p_1$ 或 $p_2$.</li>
    <li>该模式形为 $(q^{\star})$, 并且 $s$ 可被表示为和模式 $(q^{\star})$ 匹配的文字 $s_1s_2\cdots s_n$.<br /></li>
  </ul>

  <p>需要注意的是, 根据定义 $\emptyset$ 不与任何文字匹配.</p>
</blockquote>

<p><br /></p>

<p>此外, 正则表达式同样可以用于对某种语言的描述:</p>

<p><br /></p>

<p><strong>定义1.3.3</strong> 由正则表达式描述的语言</p>
<blockquote>
  <p>记 $p$ 为定义在字母表 $\Sigma$ 上的正则表达式.  <strong>由正则表达式 $p$ 所描述的语言</strong> 记为 $\mathscr{L}(p)$, 即:
\(\mathscr{L}(p) = \{s \in \Sigma^\star \vert \text{s 与 p 匹配}\}.\)</p>
</blockquote>

<p>注: <br /></p>
<ul>
  <li>$\mathscr{L}(p_1p_2) = \mathscr{L}(p_1) \cdot \mathscr{L}{p_2},$ <br /></li>
  <li>$\mathscr{L}(p_1 \vert p_2) = \mathscr{L}(p_1) \vert \mathscr{L}{p_2},$ <br /></li>
  <li>$\mathscr{L}(p^{\star}) = (\mathscr{L}(p))^{\star}.$</li>
</ul>

<p><br /></p>

<p><strong>定义1.3.4</strong> 正则语言</p>
<blockquote>
  <p>我们称语言 $\mathscr{L}$ 为 <strong>正则的</strong>, 若存在一个正则表达式 $p$, 使得该语言为基于其字母表上的, 由全部满足 $p$ 的文字所组成的集合. 也即是:
\(\exists p, ~~ s.t. ~~ \mathscr{L} = \mathscr{L(p)}.\)</p>
</blockquote>

<p><br /></p>

<p><strong>命题1.3.1</strong><br /></p>
<blockquote>
  <p>若 $\mathscr{L_1}, \mathscr{L_2}$  均为基于某个字母表 $\Sigma$ 上的正则语言, 则下列语言也是正则语言:</p>
  <ul>
    <li>$\mathscr{L_1} \cup \mathscr{L_2}$</li>
    <li>$\mathscr{L_1} \cdot \mathscr{L_2}$</li>
    <li>$\mathscr{L_1^{*}}$</li>
    <li>$\mathscr{L_1^{n}}$</li>
  </ul>
</blockquote>

<p><br /></p>

<p>在本章中, 我们介绍了文字, 字母, 语言等概念, 以集合的思想对语言进行了表述并引入了基于已有语言生成新语言的方法. 此外, 我们还对正则表达式, 以及使用正则表达式过滤文字, 使用正则表达式描述语言等概念进行了数学意义上的严格解释. 在下一章中, 我们将介绍不同种类的自动机 (<code class="language-plaintext highlighter-rouge">Automata</code>), 并介绍多个实现在自动机和模式 (正则表达式) 之间进行转换的算法.</p>

:ET