I"<h1 id="4-while-语法及其状态描述">4. <code class="language-plaintext highlighter-rouge">While</code> 语法及其状态描述</h1>

<p>在本章中, 我们将引入结构简单的 <code class="language-plaintext highlighter-rouge">While</code> 语法, 作为我们在接下来的章节中所将要介绍和学习的诸多概念的载体. 我们将对该语法本身, 使用该语法构造简单程序的方法流程及使用 <strong>状态</strong> 和 <strong>正则语义</strong> 对使用该语法构造的程序的执行状态的描述方法进行详细介绍:</p>

<h2 id="while-程序语法"><code class="language-plaintext highlighter-rouge">While</code> 程序语法</h2>
<p>程序语法本质上是对我们所希望计算机执行的操作的一种描述方法. 为了让程序完全按照我们的设想执行, 程序语法必须是 <strong>无歧义 (<code class="language-plaintext highlighter-rouge">Unambiguous</code>)</strong> 的. 下面, 我们对 <code class="language-plaintext highlighter-rouge">While</code> 程序语法进行定义:</p>

\[\begin{aligned}
S ::=&amp; ~~ x:=a ~\vert~ \text{skip} ~\vert~ S1; S2 ~\vert~ \text{if} ~b~ \text{then} ~S1~ \text{else} ~S2~ ~\vert~ \text{while} ~b~ \text{do} ~S~ ~\vert~ (S)
\\

b ::=&amp; ~~ \text{true} ~\vert~ \text{false} ~\vert~ a_1 = a_2 ~\vert~ a_1 \leq a_2 ~\vert~  \neg b ~\vert~ b_1 \wedge b_2 ~\vert~ (b)  
\\

a ::=&amp; ~~ v ~\vert~ n ~\vert~ a_1 + a_2 ~\vert~ a_1 - a_2 ~\vert~ a_1 \times a_2 ~\vert~ (a)
\end{aligned}\]

<p>对于该语法, 我们分别定义了 <strong>陈述 (<code class="language-plaintext highlighter-rouge">Statements</code>)</strong>, <strong>布尔表达式(<code class="language-plaintext highlighter-rouge">Boolean Expression</code>)</strong> 和 <strong>运算表达式(<code class="language-plaintext highlighter-rouge">Arithmetic Expression</code>)</strong>.</p>

<p>为了确保该语法的简易性, 我们仅在语法定义中给出了部分基本的程序组成元素, 但使用这些基本的组成元素已经足以让我们将语法的功能按需扩展.</p>

<p>如: 该语法缺失了</p>

\[\text{if} ~...~ \text{then}~...~\]

<p>语句. 而为了实现它, 我们只需对语法所提供的</p>

\[\text{if} ~...~ \text{then}~...~ \text{else} ~...~\]

<p>语句进行简单修改, 因为:</p>

\[[\text{if} ~b~ \text{then}~S~] \equiv [\text{if} ~b~ \text{then}~S~ \text{else} ~\text{skip}~].\]

<p>我们可以这样对语法中其他缺失的语句和特性进行定义.</p>

<p><br /></p>

<h2 id="描述-while-程序执行状态">描述 <code class="language-plaintext highlighter-rouge">While</code> 程序执行状态</h2>

<p>我们下面对该程序语义的 <strong>状态</strong> 进行定义:</p>

<p><strong>定义</strong> (状态)</p>
<blockquote>
  <p>我们称 <strong>状态</strong> 为一个从变量映射到整数的函数:
\(\text{State} = \text{Var} \rightarrow \mathbb{Z}.\)</p>
</blockquote>

<p>我们使用符号 $\sigma$ 表示 <strong>状态</strong>.</p>

<p>例:</p>

<p>定义</p>

\[\sigma = [x \rightarrowtail 5, y\rightarrowtail 7, z\rightarrowtail 0]\]

<p>则有</p>

\[\sigma(x) = 5, \sigma(y) = 7.\]

<p>注意: 我们认为一切变量的默认值均为 $0$, 因此 $\sigma$ 又等价于</p>

\[[x \rightarrowtail 5, y\rightarrowtail 7].\]

<p><strong>定义</strong> (改变状态)</p>
<blockquote>
  <p>我们使用方括号作为 <strong>状态修改符号</strong>.</p>
</blockquote>

<p>例:</p>

<p>令</p>

\[\sigma' = \sigma[x \rightarrowtail v]\]

<p>则有</p>

\[\sigma'(x) = v\]

<p>且对 $\forall~ y \neq x:$</p>

\[\sigma'(y) = y.\]

<p>我们下面对状态更新语法进行描述:</p>

<p>定义如下记号</p>

\[&lt;~S~, ~\sigma~&gt;\]

<p>其中, $S$ 为一个使用 $\text{while}$ 语法的程序, 而 $\sigma$ 为某个状态. 下表描述了状态转换规则:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210505222500.png" alt="20210505222500" /></p>

<p>其中对 $\mathscr{A}$ 和 $\mathscr{B}$ 的定义分别如下:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210505222546.png" alt="20210505222546" /></p>

<p>它们的实质是对 <strong>数值运算</strong> 和 <strong>布尔表达式</strong> 在某个状态 $\sigma$ 下的 <strong>解释 (<code class="language-plaintext highlighter-rouge">Interpretation</code>)</strong>.</p>

<p>使用上表中的状态转换规则, 我们可以描述使用 $\text{while}$ 语法的程序的每一步运行状态. 如:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210505222834.png" alt="20210505222834" /></p>

<h2 id="构造简单数据结构">构造简单数据结构</h2>

<p>我们接下来研究如何将有限的数据结构编码到自然数中. 这意味着对于给定的数据结构, 我们需要定义一个从它到自然数集的双射. 这样, 我们对数据结构的操作可以体现为某个自然数的变化, 而给定任何自然数, 我们也可以基于该映射得出它所被编码的内容.</p>

<p>首先, 我们考虑 <strong>整数</strong>. 考虑如下函数:</p>

\[\beta(x) = \begin{cases} 2x   ~~~~~~~~~~~~~~~~x \geq 0 \\ -2x-1 ~~~~~~\text{else}\end{cases}\]

<p>它将所有非负整数映射到偶数上, 而将负整数映射到奇数上. 并且不难证明, 这个函数是双射.</p>

<p>我们再研究 <strong>数对</strong>. 考虑如下函数:</p>

\[\phi(n, m) = 2^n(2m+1)-1.\]

<p>不难看出, 该函数将任意不同的数对 $(n, m)$ 映射到不同的整数上, 并且它也是双射.</p>

<p>我们最后考虑 <strong>列表</strong>. 由于几乎所有的数据结构都可以被表示成数对和列表的组合, 在完成对 <strong>列表</strong> 的构造后, 我们就具备了构造复杂数据结构的基础.</p>

<p>我们首先回顾对 <strong>列表</strong> 的递归定义:</p>

\[\text{list} = [] ~~\vert~~ n:: \text{list}\]

<p>其中, $n$ 为任意自然数, $[]$ 为某个空列表, 而 $::$ 为链接符, 表示将自然数 $n$ 连接到某个列表的表头.</p>

<p>我们给出如下的递归定义:</p>

\[\begin{aligned}\Phi([]) =&amp; 0 \\ \Phi(n :: l) =&amp; 2^n(2\Phi(l) + 1) = \phi(n, \Phi(l)) + 1.\end{aligned}\]

:ET