I"<h1 id="6-计算正确性">6. 计算正确性</h1>

<p>在本章中, 我们将简述完全正确性和部分正确性的概念, 并介绍霍尔逻辑和正确性的证明方法.</p>

<h2 id="完全正确性和部分正确性">完全正确性和部分正确性</h2>

<p>在描述程序的正确性时, 我们首先需要明确前提条件和对程序的期望, 只有在这一基础上才能对程序是否具备正确性做出判断. 回顾第四章所介绍的定义, 我们认为程序是操纵状态的函数, 也就是说, 程序接收一个初始状态, 并将其变换为某个截止状态. 程序 $P$ 的实际行为可以表示为:</p>

\[\text{Actual}(P) \equiv \{&lt;\sigma_{start}, \sigma_{end}&gt; ~\vert~ &lt;P, \sigma_{start}&gt; \Rightarrow \sigma_{end}\}\]

<p>而我们可以使用两个 <strong>谓词</strong> 描述程序的理想行为: $\text{Pre}$ 表示起始状态, 而 $\text{Post}$ 表示终止状态. 在此处, 我们假设只关心程序在满足起始状态的条件下运行所会发生的情况如何. 这样的理想行为可以描述为</p>

\[\text{Specification}(\text{Pre}, \text{Post}) \equiv \{&lt;\sigma_{start}, \sigma_{end}&gt; ~\vert~ &lt;\text{Pre}(\sigma_{start}) \Rightarrow \text{Post}(\sigma_{end})\}.\]

<p>而我们对程序正确性的判断即是对</p>

\[\text{Specification}(\text{Pre}, \text{Post}) \subseteq \text{Actual}(P).\]

<p>是否成立的判断.</p>

<p>上述的, 对程序正确性的描述存在几个问题: 首先, 这一描述是粗略而不严谨的. 其次, 该描述仅适用于会在有限步内终止的程序, 而不适用于死循环.</p>

<p>若我们不考虑程序永不终止的情况, 即使在某些初始条件下程序始终都不会终止也没关系, 则我们所考虑的正确性即被称为 <strong>部分正确性</strong>, 反之则是 <strong>完全正确性</strong>.</p>

<p>严格上来说, 检查程序是否在终止时满足条件的问题是检查程序部分正确性的问题. 检查程序是否满足其规范并且要求程序始终会终止的问题称为对程序的完全正确性的检验.</p>

<p>在描述程序正确性时, 一个难题是确定 <code class="language-plaintext highlighter-rouge">While</code> 循环的正确性. 由于我们难以确定 <code class="language-plaintext highlighter-rouge">While</code> 的循环次数, 因此执行循环前的状态和循环后的状态之间难以建立确定的联系. 为了解决这一问题, 我们引入 <strong>循环不变量</strong> 的概念:</p>

<p><strong>定义: 循环不变量</strong></p>
<blockquote>
  <p>程序段
\(\text{while} ~b~ \text{do} ~S~\)
的 <strong>循环不变量</strong> 是一个每次循环体 $S$ 执行前后都恒为真的谓词 $P$.</p>

  <p>注意: 它在循环体执行过程中的真伪并不是我们所关心的.</p>
</blockquote>

<p>我们下面介绍描述程序的 <strong>部分正确性</strong> 的公理系统:</p>

<p><br /></p>

<h2 id="霍尔逻辑-描述部分正确性">霍尔逻辑: 描述部分正确性</h2>

<p><strong>定义: 霍尔三元组</strong></p>
<blockquote>
  <p>部分正确性的霍尔三元组 (<code class="language-plaintext highlighter-rouge">Hoare Triple</code>) 是由两个谓词和一个陈述组成的, 记为:
\(\{P\} ~S~ \{Q\}\)
并且我们规定 $P, Q$ 分别为陈述 $S$ 的 <strong>前置条件</strong> 和 <strong>后置条件</strong>.</p>
</blockquote>

<p>若某个霍尔三元组是合法的 (<code class="language-plaintext highlighter-rouge">Valid</code>), 则程序在前置条件下开始执行, 要么永远不会停止, 要么程序终止时所处的状态恰好为后置条件. (即满足部分正确性)</p>

<p>要使用霍尔三元组检查给定程序的部分正确性, 我们将引入一系列规则, 并利用这些规则将程序分割成多条指令, 并对这些指令一一检查.</p>

<p>下面我们介绍使用霍尔三元组检查程序部分正确性的推断规则:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210506221817.png" alt="20210506221817" /></p>

<p><br /></p>

<h2 id="霍尔逻辑-描述完全正确性">霍尔逻辑: 描述完全正确性</h2>

<p>在使用霍尔三元组描述程序的完全正确性时, 我们需要对表示符号作简要修改, 并使用新的 $\text{while}$ 规则替换部分正确性中的推断规则:</p>

<p><strong>定义: 霍尔三元组</strong></p>
<blockquote>
  <p>部分正确性的霍尔三元组 (<code class="language-plaintext highlighter-rouge">Hoare Triple</code>) 是由两个谓词和一个陈述组成的, 记为:
\([P] ~S~ [Q]\)
并且我们规定 $P, Q$ 分别为陈述 $S$ 的 <strong>前置条件</strong> 和 <strong>后置条件</strong>.</p>
</blockquote>

<p>在考虑程序的完全正确性时, 我们要确保循环体总是能在有限步内终止. 为了检测这一点, 我们使用如下的 $\text{while}$ 规则:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210506230348.png" alt="20210506230348" /></p>

<p>其中, $E$ 为一个随着循环执行而递减且其值恒有下界的表达式. 由此, 若某个霍尔三元组满足条件, 则可确定它所表示的是一个一定能在有限步内终止的循环.</p>

<p><br /></p>

<h2 id="正确性证明的技巧及方法">正确性证明的技巧及方法</h2>

<p>程序正确性的证明具有一定的技巧性, 其原因在于我们无法直接地判断任何给定程序的正确性, 因而也就没有某种通用算法. 然而, 证明流程中仅仅在: 1. 构造/寻找/生成 循环不变量 2. 应用 $\text{cons}$(<code class="language-plaintext highlighter-rouge">Consequence</code>) 规则将某个三元组转换为与之等价的另一个三元组 这两个部分中存在较高的技巧性, 而其余的步骤基本上是机械性的赋值, 转换和联结.</p>

<p>一般地:</p>

<p>考虑形如</p>

\[S_1; ~ (\text{while} ~ b ~\text{do}~ S_2); ~ S_3\]

<p>的程序, 假定其前置条件和后置条件分别为 $P, Q$:</p>

<p>不难观察到程序中存在循环体结构 $\text{while}$, 并且程序被分为 前部程序体 循环体 后部程序体 三个部分.</p>

<ol>
  <li>首先, 寻找或构造出循环体的循环不变量 $R$. 并使用基本规则推导</li>
</ol>

\[\{P\} ~ S_1 ~ \{R\}\]

<p>和</p>

\[\{R \wedge \neg b\} ~ S_1 ~ \{Q\}.\]

<p>若无法证明, 则说明所找到的循环不变量不够强, 需要将循环不变量所包含的条件进一步强化后再试.</p>

<ol>
  <li>在得到 前部程序体 和 后部程序体 这两个部分的正确性证明后, 我们对循环体</li>
</ol>

\[\{R \wedge b\} ~S_2~ \{R\}\]

<p>给出证明.</p>

<ol>
  <li>最后, 对表示循环体的霍尔三元组应用 $\text{while}$ 规则, 再使用 $\text{comp}$ 规则将三者联结起来, 证毕.</li>
</ol>

<p>需要注意的是, 循环体的循环不变量不一定存在. 但可以确定的是, 循环不变量必须满足以下条件:</p>

<ol>
  <li>循环不变量必须包含所有循环体在循环中更新 并在循环主体之后或在后置条件中引用的变量.</li>
  <li>我们所希望在循环结束后仍然为真的条件必须包含在循环不变量中.</li>
  <li>循环不变量中需要包含程序中所使用的常量.</li>
  <li>后置条件的形式往往和循环不变量保持一致. 比如: 若后置条件是一个不等式, 我们可以尝试将后置条件这个不等式直接作为循环不变量.</li>
  <li>循环不变量的真伪不会被循环体的执行与否而改变.</li>
</ol>
:ET