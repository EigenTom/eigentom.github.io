<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="由于相关法律法规规定, 该内容无法显示.">
    <meta name="keywords" content="菜">
    <meta name="theme-color" content="#333">

    <!-- Open Graph -->
    <meta property="og:title"
        content="普林斯顿算法4-Ch2 排序 - 某一般线性空间 | Ramdom Linear Space">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="Ch2 排序
">
    
    <meta property="article:published_time" content=" 2021-09-14T00:00:00Z">
    
    
    <meta property="article:author" content="R1NG">
    
    
    <meta property="article:tag" content="数据结构和算法">
    
    <meta property="article:tag" content="扩展自习">
    
    
    <meta property="og:image" content="http://localhost:4000https://github.com/KirisameR.png">
    <meta property="og:url" content="http://localhost:4000/2021/09/14/algHeip-2/">
    <meta property="og:site_name" content="某一般线性空间 | Ramdom Linear Space">

    <title>普林斯顿算法4-Ch2 排序 - 某一般线性空间 | Ramdom Linear Space</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">

    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2021/09/14/algHeip-2/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href=" /css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href=" /css/hux-blog.min.css">
    
    <!-- Local Dev Debugging
    <link rel="stylesheet" href=" /css/font-awesome.min.css"> 
    -->
    

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>

    <!-- 数学公式 -->
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            showProcessingMessages: true, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'], //避开某些标签
                ignoreClass:"comment-content" //避开含该Class的标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX","TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    </script>

    

    <!-- Google AdSense -->
    <script data-ad-client="ca-pub-6487568398225121" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>



<!-- hack iOS CSS :active style -->
<body ontouchstart="">
    
<div class="floatbtn" onclick="document.getElementsByClassName('wrapper')[0].scrollTop = 0">
    <i class="fa fa-arrow-up"></i>
</div>




    <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-times"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>

    <div class="wrapper">    
        <!-- Navigation -->

    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">RANDOM LINEAR SPACE</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script>
        <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-algs4.jpg" width="0" height="0"> -->


<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
    }

    
</style>

<header class="intro-header" >

<img src="/img/post-bg-algs4.jpg" class="bg-image">
    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95" title="数据结构和算法">数据结构和算法</a>
                        
                        <a class="tag" href="/archive/?tag=%E6%89%A9%E5%B1%95%E8%87%AA%E4%B9%A0" title="扩展自习">扩展自习</a>
                        
                    </div>
                    <h1>普林斯顿算法4-Ch2 排序</h1>
                    
                    <h2 class="subheading">Sorting Algorithms</h2>
                    <span class="meta">Posted by R1NG on September 14, 2021</span>

                    
                    <span class="meta" id="busuanzi_container_site_pv">Viewed <b style="color: var(--sidebar-main-color); background-color: transparent !important; font-style: bold;"><i><span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span></i></b> Times</span>
                    
                </div>
            </div>
        </div>
    </div>
</header>






<div class="main-container">
<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<h1 id="ch2-排序">Ch2 排序</h1>

<p>在本章中, 我们将学习数种经典的排序算法, 并实现 <strong>优先队列</strong> 这一基础数据类型, 讨论比较排序算法的理论基础并最后总结若干排序算法和优先队列的应用.</p>

<p><br /></p>

<h2 id="21-初级排序算法">2.1 初级排序算法</h2>

<p>我们首先研究两种 <strong>初级的排序算法</strong> 和其中一种的一个变体. 在此, 我们关注的主要对象是 <strong>重新排列数组元素</strong> 的算法, 其中 <strong>每个元素都有一个主键</strong>. 排序算法的目的就是将 <strong>所有元素的主键</strong> 按照某种方式排列, 在经过排序后索引较大的主键大于等于索引较小的.</p>

<p>下面, 我们规定排序代码的结构和模板:</p>

<p>我们会将排序代码放在类的 <code class="language-plaintext highlighter-rouge">sort()</code> 方法中, 该类还包含辅助函数 <code class="language-plaintext highlighter-rouge">less()</code>, <code class="language-plaintext highlighter-rouge">exch()</code> 和示例用例 <code class="language-plaintext highlighter-rouge">main()</code>, 其中 <code class="language-plaintext highlighter-rouge">less()</code> 方法对元素进行比较, 而 <code class="language-plaintext highlighter-rouge">exch()</code> 方法将元素交换位置. 为了区分不同的算法, 我们还可以为相应的类取不同的名字, 用例可以按照名字调用不同的实现.</p>

<p>为了确保数组的初始状态是不影响排序算法的成功与否的, 我们会在测试代码 <code class="language-plaintext highlighter-rouge">main()</code> 中添加语句 <code class="language-plaintext highlighter-rouge">assert isSorted(a)</code> 来确认经过排序后的数组元素都是有序的.</p>

<p>在确认算法的有效性后, 我们还需要对其性能进行评估. 首先, 我们需要计算各个排序算法在 <strong>不同的随机输入下的基本操作的次数</strong> (包括比较和交换的数量. 对于不交换元素的算法, 我们需要计算访问数组的次数). 随后, 我们用这些数据来估计算法的性能.</p>

<p>除此以外, 我们也需要关注排序算法的 <strong>额外内存开销</strong>. <strong>原地排序算法</strong> 是 <strong>除了函数调用所需的栈和固定数目的实例变量之外无需额外内存</strong> 的算法, 而需要额外内存空间来存储一份数组副本的则被列为 <strong>其他排序算法</strong>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// see each sorting algorithms</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">less</span><span class="o">(</span><span class="nc">Comparable</span> <span class="n">v</span><span class="o">,</span> <span class="nc">Comparable</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">exch</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Comparable</span> <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">StdOut</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSorted</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">In</span><span class="o">.</span><span class="na">readStrings</span><span class="o">();</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="k">assert</span> <span class="nf">isSorted</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="n">show</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<h3 id="选择排序">选择排序</h3>

<p>选择排序是最简单的排序算法之一. 它的工作原理如下:</p>

<p>首先在数组的 $n$ 个元素中找到 <strong>最小的元素</strong>, 将其和 <strong>数组的第一个元素</strong> 交换位置, 无论数组的第一个元素是否为数组中最小的元素.</p>

<p>随后, 在剩下的 $n-1$ 个元素中再找到最小的, 并和整个数组中的第二位交换位置, 如此往复直到只剩下 $1$ 个待排序元素, 此时整个数组显然已经被完全排序. 我们称这种排序方法为 <strong>选择排序</strong>, 因为它 <strong>不断地在选择剩余元素中的最小者</strong>.</p>

<p>选择排序的内循环仅仅在比较 <strong>当前元素</strong> 和 <strong>目前已知的最小元素</strong>, 而交换元素的代码在内循环之外. 由于每次交换必能排定一个元素, 故交换的总次数为 $N$, 算法的时间效率取决于 <strong>比较的次数</strong>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Selection</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>   <span class="c1">// length of the array a</span>
        <span class="c1">// then we exchange a[i] with the smallest elem in a[i+1, ..., N]</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>   
            <span class="kt">int</span> <span class="n">min</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>  <span class="c1">// index of the min element</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">min</span><span class="o">]))</span> <span class="o">{</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>命题 2.1</strong></p>
<blockquote>
  <p>对于长度为 $N$ 的数组, 选择排序大约需要 $\frac{N^2}{2}$ 次比较和 $N$ 次交换.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>基于算法的 <strong>排序轨迹</strong> 和 <strong>工作原理</strong> 可知, 由于每次交换只会对 $1$ 个元素进行排序, 因此对于长度为 $N$ 的数组总共交换次数也为 $N$.<br />
由于数组索引 $i \in [N-1]$ 的元素都会进行 $N-1-i$ 次比较, 因此将整个数组进行排列共需要</p>

\[\sum_{i=1}^{N-1}i = \frac{N(N-1)}{2} \sim \frac{N^2}{2}\]

  <p>次比较. $\blacksquare$</p>
</blockquote>

<p>总结: <br /></p>

<p>选择排序是一种简单的排序算法, 其具备两个显著特征:</p>

<ol>
  <li>
    <p><strong>运行时间和输入无关</strong>:<br />
 选择排序无法利用输入数组的 <strong>初始状态</strong>, 它对一个已经有序或者元素全部相等的数组进行排序所耗费的时间和对一个乱序数组而言是 <strong>完全相同的</strong>, 因为它在对任何一个元素进行排序时执行的每一次全数组扫描都不能为下一次排序提供任何有效信息, 这一性质在某些情况下是制约运行速度的缺点.</p>
  </li>
  <li>
    <p><strong>数据移动最少</strong>: <br />
由于每次交换均会改变 <strong>两个数组元素的值</strong>, 因此选择排序对数组的交换次数和数组大小是 <strong>线性关系</strong>, 而我们即将讨论的其他任何算法都不具备该特征.</p>
  </li>
</ol>

<p><br /></p>

<h3 id="插入排序">插入排序</h3>

<p>要理解插入排序的原理, 我们可以从扑克牌的整理方式中获得启发. 和理牌时我们需要将一张牌插入到其他 <strong>已经有序</strong> 的牌中的适当位置一样, 在插入排序的实现中, 为了给要插入的元素腾出空间, 需要将 <strong>其余所有元素</strong> 在插入之前都 <strong>右移一位</strong>.</p>

<p>与选择排序相同, 当前索引左侧的所有元素都是有序的, 只不过它们的最终位置还不确定, 但当 <strong>索引到达数组右端</strong> 时, 数组排序就完成了. 不同于选择排序, 插入排序的耗时受输入中元素初始顺序的影响.</p>

<p><strong>命题 2.2</strong></p>
<blockquote>
  <p>对于随机排列的长为 $N$ 且 <strong>主键不重复</strong> 的数组, 平均情况下插入排序需要约 $\frac{N^2}{4}$ 次比较和交换. 最坏情况下需要约 $\frac{N^2}{2}$ 次比较和交换, 最好情况下需要 $N-1$ 次比较和 $0$ 次交换.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>通过一个 $N \times N$ 的 <strong>排序轨迹表</strong> 可以很容易地得到交换和比较的次数. 最坏情况下, 轨迹表 <strong>对角线之下</strong> 的所有元素都需要移动位置, 而最好情况下都不需要; 对于 <strong>随机排列</strong> 的数组, 在平均情况下每个元素都可能向后移动 <strong>半个数组的长度</strong>, 故交换总数总是对角线之下元素总数的 $\frac{1}{2}$.</p>

  <p>比较的总次数为交换的次数 <strong>减去一个额外项</strong> 再加上 $N$. 这个额外项是, 在所有的插入操作中, 将被插入的元素恰好是数组中位于索引前的那部分中的最小元素这种情况总共出现的次数. 在最坏情况下, 这一项相比交换总数可以 <strong>忽略不计</strong>, 而在最好情况下, 这一项等于 $1$. $\blacksquare$</p>
</blockquote>

<p>(注: 为了方便理解此处的额外项恰好是原书描述的额外项取 <strong>相反数再加 $N$</strong>, 原文为 “an additional term equal to N minus the number of times the item inserted is the smallest so far”.)</p>

<p>对于实际应用中常见的某些类型的 <strong>非随机数组</strong>, 插入排序是很有效的: 当我们使用插入排序尝试对一个有序数组或所有主键均相同的数组进行排序时, 插入排序能够立即识别每个元素都在合适的位置之上 (因为其执行交换操作的内层循环判断条件就是元素是否依序排列), 此时 <strong>其运行时间是线性的</strong>, 而选择排序就需要 $n^2$ 级别的运行时间.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Insertion</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// insert element a[i] into the already-sorted sub-arrray:</span>
            <span class="c1">// [a[0], ..., a[n-2], a[n-1]]</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                <span class="c1">// less(a[j], a[j-1]) == "a[j]&lt;a[j-1]? true : false"</span>
                <span class="c1">// it means we only proceed the iteration iff a[j] is not being </span>
                <span class="c1">// placed into the right place yet</span>
                <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>我们下面考虑 <strong>部分有序数组</strong>:</p>

<p><strong>定义</strong>: 倒置</p>
<blockquote>
  <p>数组中两个 <strong>顺序颠倒</strong> 的元素称为 <strong>倒置</strong>.</p>
</blockquote>

<p><strong>定义</strong>: 部分有序数组</p>
<blockquote>
  <p>如果数组中 <strong>倒置的数量</strong> 小于 <strong>数组大小的某个倍数</strong>, 则称这个数组是 <strong>部分有序</strong> 的.</p>
</blockquote>

<p>一些典型的部分有序数组是:</p>
<ol>
  <li>数组中每个元素距离其正确位置都不远.</li>
  <li>一个有序的大数组接一个小数组.</li>
  <li>只有几个元素的位置不正确的数组.</li>
</ol>

<p><strong>命题 2.3</strong></p>
<blockquote>
  <p>插入排序所需要的交换操作和数组中 <strong>倒置的数量</strong> 相同, 且有:<br />
倒置数量 $+$ 数组大小 $-1 \geqslant$ 需要的比较次数 $\geqslant$ 倒置的数量.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>插入排序执行的每一次交换都改变了 <strong>一对顺序颠倒的元素位置</strong>, 等价于 <strong>减少了一对倒置</strong>. 而当 <strong>倒置数量为 $0$</strong> 时, 排序就完成了, 而每次交换都和一次比较对应, 因此 (需要的比较次数 $\geqslant$ 倒置的数量); 而 $1$ 到 $N-1$ 之间的每个 $i$ 都可能需要一次 <strong>额外的比较</strong>, 故 (倒置数量 $+$ 数组大小 $-1 \geqslant$ 需要的比较次数). $\blacksquare$</p>
</blockquote>

<p><br /></p>

<h3 id="对插入排序和选择排序算法的比较">对插入排序和选择排序算法的比较</h3>

<p>下面我们讨论插入排序和选择排序的性能孰优孰劣. 比对算法的速度这个问题会在我们今后对算法的学习中反复出现. 根据 <code class="language-plaintext highlighter-rouge">Ch 1.4</code> 所介绍的方法, 我们将通过以下的步骤对比两个算法:</p>

<ol>
  <li>实现并调试它们.</li>
  <li>分析它们的基本性质.</li>
  <li>对它们的相对性能作出猜想.</li>
  <li>设计并进行实验对猜想进行验证.</li>
</ol>

<p>在前两个小节中我们已经给出了选择排序和插入排序算法的实现, 因此我们已经完成了第一步. 而上两个小节中所描述和证明的三个命题组成了流程的第二步. 我们下面将依次完成第三步和第四步.</p>

<p>在实现了算法后, 我们需要确定一个适当的输入模型. 对排序而言, 上两个小节中的三个命题使用的自然输入模型假设数组中的元素 <strong>随机排序</strong>, 且 <strong>主键值不会重复</strong>. 而对于有 <strong>很多重复主键</strong> 的应用而言, 我们需要一个更复杂的模型.</p>

<p>我们已经知道, 对于随机排序数组, 两个算法的运行时间都是 $n^2$ 级别. 我们可由此得到下列猜想:</p>

<p><strong>性质</strong></p>
<blockquote>
  <p>对于 <strong>随机排序的无重复主键的数组</strong>, 插入排序和选择排序的运行时间是 <strong>$n^2$ 级别</strong> 的, 两者之比应该是一个较小的常数.</p>
</blockquote>

<p>对于性能实验的设计和猜想的验证, 详见原书翻译版 $\text{P}254-257$ 页, 此处不做摘录和笔记.</p>

<p><br /></p>

<h3 id="希尔排序">希尔排序</h3>

<p>下面我们讨论一种 <strong>基于插入排序</strong> 的快速的排序算法. 插入排序对于 <strong>大规模乱序数组表现不佳</strong>, 因为它只会 <strong>交换相邻的元素</strong>, 因为元素只能一点点的 <strong>从数组的一端移动到另一端</strong>.</p>

<p>为了加快速度, 希尔排序通过 <strong>交换不相邻的元素对数组的局部进行排序并最终用插入排序将局部有序的数组排序</strong> 对插入排序进行了简单的改进.</p>

<p><strong>定义</strong>: $h$ 有序数组</p>
<blockquote>
  <p>$h$ 有序数组是由 $h$ 个相互独立的有序数组编织在一起组成的一个数组, 在这个数组中, 任意间隔为 $h$ 的元素都是有序的.</p>
</blockquote>

<p>$h$ 为希尔排序中可自定义的一个控制被交换元素距离的参数, 其思想是让 <strong>数组中任意间隔为 $h$ 的元素都是有序的</strong>. 在进行排序时, 如果 $h$ 很大的话, 只需要经过一次交换我们就能将元素移动到很远的地方.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Shell</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// dynamically calculate h's val</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="no">N</span><span class="o">/</span><span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">h</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// in this implementation, we use geometric progression: </span>
        <span class="c1">// [1, 3, 9, ..., N/3] for h in different iterations</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">h</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// insert a[i] into [a[i-h], a[i-2h], a[i-3h], ...]</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="o">]);</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>    <span class="c1">// decrease h after each iteration</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>希尔排序权衡了子数组的 <strong>规模</strong> 和 <strong>有序性</strong>. 在排序之初, 各个子数组都很短, 排序后各个子数组部分有序, 这两种情况都适合插入排序, 而子数组部分有序的程度取决于递增序列的选择.</p>

<p>选择递增序列是一项复杂的工作, 算法的性能取决于 $h$ 与序列中 $h$ 之间的数学性质. 我们在上文的实现中采用的简单递增序列与复杂递增序列的性能接近, 但可以证明复杂的序列在最坏情况下的性能表现是优于这个简单的序列的.</p>

<p>和选择排序, 插入排序不同的是, 希尔排序也可以用于 <strong>大型数组</strong>, 它对任意排序的数组表现也很好.</p>

<p><br /></p>

<h2 id="22-归并排序">2.2 归并排序</h2>

<p>我们在本节中将要讨论的算法都基于 <strong>归并</strong> 这个操作, 也就是将 <strong>两个有序的数组</strong> 归并成一个 <strong>更大的有序数组</strong>.</p>

<p>一种简单的递归排序算法: <strong>归并排序</strong> 的工作原理就是基于这个操作之上的. 要将一个数组排序, 可以先 <strong>递归地</strong> 将它分成两半分别排序, 然后将结果归并起来. 归并排序能保证, 它排序 <strong>任意长度为 $N$ 的数组</strong> 所需要的时间和 $N\log(N)$ 成正比, 而它需要的额外空间和 $N$ 成正比.</p>

<h3 id="原地归并的抽象方法">原地归并的抽象方法</h3>

<p>实现归并的一种简单方法是将两个不同的有序数组归并到第三个数组中. 虽然我们利用两个数组中的元素都实现了 <code class="language-plaintext highlighter-rouge">Comparable</code> 接口的特性可以指甲创建一个适当大小的数组并将两个数组中的元素由小到大依次放入其中, 但在需要进行多次归并 (如对一个很大的数组排序) 时, 如果每次归并都需要创建一个新数组存储排序结果就会带来存储空间使用上的问题. 因此, 我们需要考虑一种 <strong>能够在原地归并</strong> 的方法, 这样就可以分别将前半部分和后半部分排序, 然后在数组中移动元素而无需使用额外的空间.</p>

<p>下面我们给出一个抽象化原地归并操作的静态方法, 它将归并过程中涉及到的所有元素复制到一个辅助数组中, 然后再将归并的结果放回到原数组中:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// merge a[lo...mid] and a[mid+1...high]</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
    
    <span class="c1">// first copy a[lo...high] to aux[lo...high]</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">high</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">aux</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">// then merge them and modify a[]</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">&gt;</span><span class="n">mid</span><span class="o">)</span> <span class="o">{</span>            <span class="c1">// used all left-side subarray</span>
            <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">hi</span><span class="o">)</span> <span class="o">{</span>      <span class="c1">// used all right-side subarray</span>
            <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>  <span class="c1">// right &lt; left</span>
            <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>                            <span class="c1">// left &lt; right</span>
            <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>该方法先将 <code class="language-plaintext highlighter-rouge">a[]</code> 中的所有元素复制到新数组 <code class="language-plaintext highlighter-rouge">aux[]</code> 中, 然后再归并回 <code class="language-plaintext highlighter-rouge">a[]</code>. 方法在执行归并时进行了四个 <code class="language-plaintext highlighter-rouge">for</code> 条件判断: 左半边子数组用尽 (故取右半边), 右半边子数组用尽 (故取左半边), 右半边子数组元素小于等于左半边和左半边子数组元素小于等于右半边 (故取较小的那一个).</p>

<p><br /></p>

<h3 id="自顶向下的归并排序">自顶向下的归并排序</h3>

<p>我们再介绍一个基于 <strong>原地归并的抽象实现</strong> 实现了 <strong>递归归并</strong> 的算法:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Merge</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Comparable</span> <span class="n">aux</span><span class="o">[];</span>     <span class="c1">// auxiliary array used in merge()</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span> <span class="n">a</span><span class="o">[])</span> <span class="o">{</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Comparable</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>       <span class="c1">// sort left side</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>     <span class="c1">// sort right side</span>
        <span class="n">merge</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>  <span class="c1">// then merge them finally</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>要理解归并排序, 我们可以研究该方法 <strong>调用的动态情况</strong>. 要将 $a[0…15]$ 排序, <code class="language-plaintext highlighter-rouge">sort</code> 方法会调用自身将 $a[0…7]$ 排序, 再在其中调用自己将 $a[0..3]$ 和 $a[4..]$ 排序, 而在将 $a[0], a[1]$ 排序后才会开始反过来合并数组. 在合并回 $a[0…7]$ 后, 再去进行后续的归并. 显然, <code class="language-plaintext highlighter-rouge">sort()</code> 方法的作用实际上在于 <strong>安排多次 <code class="language-plaintext highlighter-rouge">merge()</code> 方法调用的正确顺序</strong>.</p>

<p>我们同样可以通过树状图理解下列的命题: 在图中, 每个结点都表示一个 <code class="language-plaintext highlighter-rouge">sort()</code> 方法通过 <code class="language-plaintext highlighter-rouge">merge()</code> 方法归并而成的子数组, 这棵树恰好有 $n$ 层. 对于 $0$ 到 $n-1$ 之间的任意 $k$, 自顶向下的第 $k$ 层有 $2^k$ 个子数组, 每个数组的长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较, 故每层的比较次数为 $2^k \cdot 2^{n-k} = 2^n$, $n$ 层总共为 $n \cdot 2^n = N\cdot \lg(N) ~~~ \small{(n = \lg(N)})$.</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20210913204532.png" alt="20210913204532" /></p>

<p><strong>命题 2.4</strong></p>
<blockquote>
  <p>对于长度为 $N$ 的任意数组, 自顶向下的归并排序需要 $\frac{1}{2}N\cdot \lg(N)$ 到 $N\cdot \lg(N)$ 次比较.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>记 $C(N)$ 表示将一个长度为 $N$ 的数组排序时所需要的比较次数. 立刻可知: $C(0) = C(1) = 0$. <br />
对于 $N&gt;0$, 通过递归的 <code class="language-plaintext highlighter-rouge">sort()</code> 方法可以由相应的归纳关系得到比较次数的上限:</p>

\[C(N) \leqslant C(\lfloor\frac{N}{2}\rfloor) +  C(\lceil\frac{N}{2}\rceil) + N.\]

  <p>其中, 不等号右侧分别为将数组左半部分和右半部分排序所用的比较次数, 以及归并所用的比较次数. 由于归并所需要的比较次数最少为 $\lfloor\frac{N}{2}\rfloor$, 故比较次数的下限是:</p>

\[C(N) \geqslant C(\lfloor\frac{N}{2}\rfloor) +  C(\lceil\frac{N}{2}\rceil) + \lfloor\frac{N}{2}\rfloor.\]

  <p>当 $N$ 为 $2$ 的幂且等号成立时我们能得到一个解: 由于 $\lfloor\frac{N}{2}\rfloor = \lceil\frac{N}{2}\rceil = 2^{n-1}$, 可得:<br /></p>

\[C(2^n) = 2\cdot C(2^{n-1}) + 2^n\]

  <p>即<br /></p>

\[\frac{C(2^n)}{2^n} = \frac{C(2^{n-1})}{2^{n-1}} + 1\]

  <p>故知<br /></p>

\[\frac{C(2^{n-1})}{2^{n-1}} = \frac{C(2^{n-2})}{2^{n-2}} + 1\]

  <p>因此有<br /></p>

\[\frac{C(2^n)}{2^n} = (\frac{C(2^{n-2})}{2^{n-2}} + 1) +1\]

  <p>重复该替换过程可得:<br /></p>

\[\frac{C(2^n)}{2^n} = (\frac{C(2^{0})}{2^{0}}+(n-1)) + 1\]

  <p>也就是<br /></p>

\[\frac{C(2^n)}{2^n} = \frac{C(2^{0})}{2^{0}}+n\]

  <p>去分母得<br /></p>

\[C(N) = C(2^n) = n \cdot 2^n = N\cdot \lg(N).\]
</blockquote>

<p>对于一般的 $N$, 对其比较次数的上下界不等式使用放缩的技巧同样不难证明前述结论成立. $\blacksquare$</p>

<p><br /></p>

<p><strong>命题 2.5</strong></p>
<blockquote>
  <p>对于长度为 $N$ 的任意数组, 自顶向下的归并排序最多需要访问数组 $6N\cdot \lg(N)$ 次.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>由于在每一次归并中最多需要访问数组 $6N$ 次: $2N$ 次用于复制, $2N$ 次用于将排好序的元素移动回去, 另外最多比较 $2N$ 次, 结合上一命题立刻可得, 本命题成立. $\blacksquare$</p>
</blockquote>

<p>上述的两个命题告诉我们, <strong>归并排序所需要的时间和 $N\cdot \lg(N)$</strong> 成正比, 远远快于我们在上一节中讨论的初级排序算法. 它表明, 我们只需要 <strong>比遍历整个数组多个对数因子的时间</strong> 就能将整个庞大的数组排序, 这使得使用归并排序处理大小为百万级别甚至更大规模的数组在事实上可行. 相应的, 归并排序的主要缺点则是 <strong>辅助数组所使用的额外空间和数组的大小成正比</strong>. 不过, 通过一些细致的思考我们还可以进一步地缩短归并排序的运行时间.</p>

<p><br /></p>

<h3 id="优化-对小规模子数组使用插入排序">优化: 对小规模子数组使用插入排序</h3>

<p>对不同的方法处理小规模问题能改善 <strong>大多数递归数组</strong> 的性能, 因为递归会使 <strong>小规模问题中方法的调用过于频繁</strong>, 因此改进对它们的处理方式就能改善整个算法. 在排序问题上, 基于上一节的讨论, 我们已经知道插入排序或选择排序非常简单, 因此它们很可能在小规模数组上比归并排序更快. 使用插入排序处理小规模的子数组 (如长度小于 $15$), 一般就可以将归并排序的运行时间缩短 $10 \sim 15 \%.$</p>

<h3 id="优化-测试数组是否已经有序">优化: 测试数组是否已经有序</h3>

<p>针对子数组有序的情况, 我们可以添加判别条件检测 $a[\text{mid}]$ 是否小于等于 $a[\text{mid+1}]$. 如果确实如此的话, 我们就可以直接将其拼接起来而跳过 <code class="language-plaintext highlighter-rouge">merge</code> 方法. 这样的优化不影响排序的递归调用, 但对于 <strong>任意有序的子数组</strong>, 算法的运行时间就变成线性的了.</p>

<h3 id="优化-不将元素复制到辅助数组">优化: 不将元素复制到辅助数组</h3>

<p>我们还可以节省将数组元素复制到用于归并的辅助数组所消耗的时间. 我们需要两种排序方法实现这一优化: 一种是将数据从输入数组排序到辅助数组, 另一种则是将数据从辅助数组排序到输入数组, 而在递归调用的每一层对输入数组和辅助数组的角色进行对换.</p>

<p><br /></p>

<h3 id="自底向上的归并排序">自底向上的归并排序</h3>

<p>递归实现的归并排序是算法中 <strong>分治算法</strong> 的典型应用. 实现归并排序的另一种方法是先归并那些小规模的子数组, 然后再成对归并得到的更大的子数组:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeBU</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Comparable</span><span class="o">[]</span> <span class="n">aux</span><span class="o">;</span>    <span class="c1">// auxiliary array used for sorting</span>

    <span class="c1">// merge() is identical to Merge class</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Comparable</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sz</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">sz</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lo</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">lo</span><span class="o">&lt;</span><span class="no">N</span><span class="o">-</span><span class="n">sz</span><span class="o">;</span> <span class="n">lo</span><span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sz</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">merge</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lo</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">lo</span><span class="o">+</span><span class="n">sz</span><span class="o">+</span><span class="n">sz</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>自底向上的归并排序会 <strong>多次遍历整个数组</strong>, 根据子数组大小进行 <strong>两两合并</strong>. 子数组的大小 <code class="language-plaintext highlighter-rouge">sz</code> 初始值为 $1$, 每次循环加倍一次. 最后一个子数组的大小只有在数组大小为 <code class="language-plaintext highlighter-rouge">sz</code> 的偶数倍时才会与其相等, 否则它会比 <code class="language-plaintext highlighter-rouge">sz</code> 小.</p>

<p><strong>命题 2.6</strong></p>
<blockquote>
  <p>对于长度为 $N$ 的任意数组, 自底向上的归并排序需要 $\frac{1}{2}N\cdot \lg(N)$ 到 $N\cdot \lg(N)$ 次比较, 并最多访问数组 $6N\cdot \lg(N)$ 次.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>处理一个数组的遍数恰好为 $\lfloor \lg(N) \rfloor$, 而每一遍会访问数组 $6N$ 次, 比较次数介于 $\frac{N}{2}$ 和 $N$.</p>
</blockquote>

<p>注意, 当数组长度为 $2$ 的幂时, 自顶向下和自底向上的归并排序所用的比较次数和数组访问次数 <strong>恰好相同</strong>, 只是顺序刚好相反. 在其他情况下, 二者的比较和访问数组的次序均有不同.</p>

<p>自底向上的归并排序适合 <strong>用链表组织的数据</strong>. 这种方法只需要重新组织链表链接即可将链表 <strong>原地排序</strong>.</p>

<p><br /></p>

<h3 id="排序算法的复杂度">排序算法的复杂度</h3>

<p>归并排序是证明 <strong>计算复杂性领域</strong> 的一个重要结论的基础, 而计算复杂性有助于我们理解排序自身 <strong>固有的难易程度</strong>. 我们下面就对排序算法的计算复杂性进行详细讨论.</p>

<p>为了研究复杂度, 首先需要建立 <strong>计算模型</strong>. 对排序而言, 我们研究的对象是 <strong>基于比较的算法</strong>, 它们对数组元素的操作是由 <strong>对主键的比较</strong> 所决定的. 一个基于比较的算法在两次比较之间可能会进行任意规模的计算, 但它只能通过 <strong>主键的比较</strong> 得到关于某个主键的信息. 注意: 由于我们局限于实现了 <code class="language-plaintext highlighter-rouge">Comparable</code> 接口的对象, 本章中讨论的所有算法都属于这一类; 此外, 我们还 <strong>忽略了访问数组的开销</strong>.</p>

<p><strong>命题 2.7</strong></p>
<blockquote>
  <p>没有任何基于比较的算法能够保证使用少于 $\lg(N!) ~ \sim ~ N \cdot \lg(N)$ 次比较以将长度为 $N$ 的数组排序.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>我们首先假设没有重复的主键, 这是任何排序算法都能处理的情况. 我们下面使用二叉树来表示算法对某个数组进行排序后可能的所有情况. 二叉树中的结点要么是一片 <strong>表示排序完成并且展示元素排序顺序的叶子</strong>, 要么是一个 <strong>表示两个元素之间的一次比较操作的内部结点</strong>. 从 <strong>根结点</strong> 到 <strong>叶子结点</strong> 的每一条路径都对应着算法在建立叶子结点所示顺序时进行的所有比较, 如下图:</p>

  <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20210914181927.png" alt="20210914181927" /></p>

  <p>从比较树得到的第一个重要结论是: <strong>这棵树至少有 $N!$ 个叶子结点</strong>. 如果叶子结点的数量少于这个值, 那么一定 <strong>有一些排列顺序被遗漏了</strong>.</p>

  <p><strong>从根结点到叶子结点的一条路径上的内部结点</strong> 的数量就是某种输入下算法进行比较的次数. 我们所关心的是这种路径的长度几何, 也就是树的高度是什么, 因为这就是算法比较次数的最坏情况. 我们在这里介绍二叉树的一个基本的组合学性质: <strong>高度为 $h$ 的树最多只可能有 $2^h$ 个叶子结点</strong>, 我们称拥有 $2^k$ 个结点的树为 <strong>完美平衡</strong> 的, 或称为 <strong>完全树</strong>.</p>

  <p>结合上述的分析可知, <strong>任意基于比较的排序算法都必然和一棵高为 $h$ 的比较树所对应</strong>, 因此有:<br /></p>

\[N! \leqslant \text{叶子结点的数量} \leqslant 2^h\]

  <p>其中 $h$ 的值就是 <strong>最坏情况下的比较次数</strong>, 因此对不等式两边同取对数可得任意算法比较次数的下界为 $\lg(N!)$. 由 <code class="language-plaintext highlighter-rouge">Stirling</code> 公式: $\lg(N!) \sim N\cdot \lg(N). \blacksquare$</p>
</blockquote>

<p>本结论揭示了 <strong>设计排序算法时所能达到的理论最佳效果</strong>. <code class="language-plaintext highlighter-rouge">命题 2.6</code> 表明归并排序在最坏情况下的比较次数约为 $N \cdot \lg(N)$, 这也是 <strong>其他排序算法复杂度的上限</strong>. 同时, <code class="language-plaintext highlighter-rouge">命题 2.7</code> 告诉我们, 不存在只需要少于 $N \cdot \lg(N)$ 次比较就可完成数组排序的算法, 因此这也是 <strong>其他排序算法复杂度的下限</strong>, 即使最好的算法, 在最坏的情况下仍然至少需要这么多次比较. 因此我们有:</p>

<p><strong>命题 2.8</strong></p>
<blockquote>
  <p>归并排序是一种 <strong>渐进最优</strong> 的, 基于 <strong>比较排序</strong> 的算法.</p>
</blockquote>

<p>归并排序的最优性远远不意味着对排序算法研究的结束. 实际上, 本节中为了讨论而进行的一些假设具备明显的局限性. 比如:</p>

<ol>
  <li>归并排序的 <strong>空间复杂度</strong> 不是最优的.</li>
  <li>在实践中我们不一定会遇到最坏情况.</li>
  <li>除了 <strong>比较</strong>, 算法的其他操作 (如对数组的访问) 也可能同样重要.</li>
  <li><strong>不进行比较</strong> 也可以将某些数据排序.</li>
</ol>

<p>因此, 我们下面继续研究其他的一些排序算法.</p>

<p><br /></p>

<h2 id="23-快速排序">2.3 快速排序</h2>

<p>快速排序可能是应用最为广泛的排序算法. 其流行的原因是 <strong>实现简单, 适用于各种不同的数据</strong> 且在一般应用中 <strong>比其他排序算法快很多</strong>.</p>

<p>快速排序是一种 <strong>原地排序</strong> (它只需要很小的一个辅助栈), 且将长度为 $N$ 的数组排序所耗时间和 $N \cdot \lg(N)$ 成正比. 这两个优点在我们已经学习的排序算法中只有快速排序同时具备. 此外, 快速排序的内循环 <strong>比大多数排序算法都要短小</strong>, 这意味着它 <strong>无论是在理论上还是在实际中都要更快</strong>. 而其主要缺点是它非常脆弱, 许多错误都能导致其实际性能的劣化, 因此在实现时要非常小心.</p>

<h3 id="基本算法">基本算法</h3>

<p>快速排序也是一种 <strong>分治</strong> 的排序算法, 它将一个数组 <strong>分为两个子数组</strong>, 并将两部分独立地排序.</p>

<p>和上一节中介绍的 <strong>归并排序</strong> 相比, 它有以下几个主要的不同:</p>
<ol>
  <li>归并排序将数组分为两个子数组分别排序, 并将有序的子数组归并以将整个数组排序; 而快速排序则是当两个子数组都有序时, 整个数组也就自然有序了.</li>
  <li>在归并中, 递归调用发生在 <strong>处理整个数组之前</strong>, 而在快速排序中, 发生在 <strong>处理整个数组之后</strong>.</li>
  <li>在归并排序中, 一个数组被分为两段, 而在快速排序中, <strong>切分</strong> 的位置取决于数组的内容.</li>
</ol>

<p>快速排序的实现过程如下列代码所示:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Quick</span> <span class="o">{</span>
    <span class="c1">// constructor</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StdRandom</span><span class="o">.</span><span class="na">shuffle</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// the real sort method</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>   <span class="c1">// split a[] into two parts</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>   <span class="c1">// sort left side: a[lo...j-1]</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>   <span class="c1">// sort left side: a[j+1...hi]</span>
    <span class="o">}</span>

    <span class="c1">// core: partitioning</span>
    <span class="c1">// we will come back to implement it...very soon</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>快速排序递归地将子数组 <code class="language-plaintext highlighter-rouge">a[lo...hi]</code> 排序: 先用 <code class="language-plaintext highlighter-rouge">partition()</code> 方法将 <code class="language-plaintext highlighter-rouge">a[j]</code> 放到一个合适的位置, 然后用递归调用将其他位置的元素排序. 该方法的关键在于 <strong>切分</strong>, 该过程使得数组满足下列的三个条件:</p>

<ol>
  <li>对于某个 <code class="language-plaintext highlighter-rouge">j</code>, <code class="language-plaintext highlighter-rouge">a[j]</code> 已经排定.</li>
  <li><code class="language-plaintext highlighter-rouge">a[lo]</code> 到 <code class="language-plaintext highlighter-rouge">a[j-1]</code> 中的所有元素都不大于 <code class="language-plaintext highlighter-rouge">a[j]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">a[j+1]</code> 到 <code class="language-plaintext highlighter-rouge">a[hi]</code> 中的所有元素都不小于 <code class="language-plaintext highlighter-rouge">a[j]</code>.</li>
</ol>

<p>由于切分过程 <strong>总是能排定一个元素</strong>, 故用归纳法不难证明 <strong>递归能正确地将数组排序</strong>: 
若左子数组和右子数组都是有序的, 则由左子数组 (有序, 且没有任何大于切分元素的键), 切分元素和右子数组 (有序, 且没有任何小于切分元素的键) 组成的结果数组也 <strong>一定有序</strong>. 上述代码实现了一个基于这个思路的递归程序. 因为它在将数组排序之前 <strong>会将其随机打乱</strong>, 因此它是一个 <strong>随机化的</strong> 算法.</p>

<p>要完成这个实现, 需要完成 <strong>切分方法</strong>: 我们一般的策略是 <strong>随意地</strong> 取 <code class="language-plaintext highlighter-rouge">a[lo]</code> 作为 <strong>切分元素</strong>, 也就是那个将会被排定的元素.</p>

<p>随后, 从数组 <strong>左端开始向右</strong> 扫描, 直到找到一个 <strong>大于等于 <code class="language-plaintext highlighter-rouge">a[lo]</code></strong> 的元素, 再从数组 <strong>从右向左</strong> 扫描, 直到找到一个 <strong>小于等于它</strong> 的元素. 显然, 此时找到的这一对元素 <strong>尚未排定</strong>, 因此我们需要 <strong>交换他们的位置</strong>. 如此继续, 就可以确保 <strong>左指针 $i$ 的右侧元素都不大于切分元素 <code class="language-plaintext highlighter-rouge">a[lo]</code></strong>, 且 <strong>右指针 $j$ 的左侧元素都不小于切分元素 <code class="language-plaintext highlighter-rouge">a[lo]</code></strong>. 在两个指针相遇时, 只需要 <strong>交换左子数组最右侧的元素 <code class="language-plaintext highlighter-rouge">a[j]</code></strong> 和切分元素交换并 <strong>返回 <code class="language-plaintext highlighter-rouge">j</code></strong> 即可. 快速排序切分的实现如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">lo</span><span class="o">;</span>   <span class="c1">// left scanning ptr</span>
    <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// right scanning ptr</span>
    <span class="nc">Comparable</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>   <span class="c1">// partition element</span>

    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[++</span><span class="n">i</span><span class="o">],</span> <span class="n">v</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">a</span><span class="o">[--</span><span class="n">j</span><span class="o">]))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">lo</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>     <span class="c1">// put v=a[j] into the right place</span>
    <span class="k">return</span> <span class="n">j</span><span class="o">;</span>           <span class="c1">// then we have a[lo...j-1] &lt;= a[j] &lt;= a[j+1...hi]</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在上述的这段代码中, 我们 <strong>按照 <code class="language-plaintext highlighter-rouge">a[lo]</code> 的值</strong> 进行切分, 当指针 <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">j</code> 相遇时 <strong>主循环退出</strong>. 在循环中, <code class="language-plaintext highlighter-rouge">a[i]</code> $&lt;$ <code class="language-plaintext highlighter-rouge">v</code> 时我们减小 <code class="language-plaintext highlighter-rouge">j</code>, 然后交换 <code class="language-plaintext highlighter-rouge">a[i]</code>, <code class="language-plaintext highlighter-rouge">a[j]</code> 来确保 <code class="language-plaintext highlighter-rouge">i</code> 左侧的元素都 <strong>不大于 <code class="language-plaintext highlighter-rouge">v</code></strong>, <code class="language-plaintext highlighter-rouge">j</code> 右侧的元素都不小于 <code class="language-plaintext highlighter-rouge">v</code>. 当指针相遇时交换 <code class="language-plaintext highlighter-rouge">a[lo]</code> 和 <code class="language-plaintext highlighter-rouge">a[j]</code>, 切分结束.</p>

<p>在实现快速排序时, 我们必须注意以下几点:</p>
<ol>
  <li>请使用原地切分. 若使用辅助数组实现切分, 将切分后的数组复制回去的开销可能会明显降低排序的速度.</li>
  <li>注意扫描指针的越界问题. 如果切分元素恰好是整个数组中最小或最大的, 此时就要在 <code class="language-plaintext highlighter-rouge">partition()</code> 方法中进行明确的检测以避免数组越界的情况出现.</li>
  <li>确保数组元素经过一次乱序排列, 以保持随机性.</li>
  <li>确保排序的切分循环的结束条件是有效的.</li>
  <li>注意处理切分元素值有重复的情况. 左侧/右侧扫描最好是在遇到 <strong>大于等于/小于等于</strong> 切分元素值的元素时停下. 在典型应用中, 它能够避免算法的运行时间变为 <strong>平方级别</strong>.</li>
</ol>

<p>快速排序切分方法的内循环会 <strong>用一个递增的索引</strong> 将数组元素和 <strong>一个定值</strong> 比较. 归并排序和希尔排序一般都比快速排序慢, 一个原因就是 <strong>它们还会在内循环中移动数据</strong>.</p>

<p>快速排序的另外一个速度优势在于 <strong>它的比较次数很少</strong>. 排序效率最终依赖于 <strong>切分数组的效果</strong>, 而这一效果又依赖于 <strong>切分元素的值</strong>. 切分的效果是将一个较大的随机数组分成两个随机子数组, 而实际上对于 <strong>元素不重复的数组而言</strong>, 这样的分割可能发生在 <strong>数组的任意位置</strong>.</p>

<p><br /></p>

<h3 id="性能特点">性能特点</h3>

<p>下面我们对快速排序算法进行简单分析, 讨论一下它和理想方法之间的差距:</p>

<p>在理想情况下, 快速排序每次 <strong>恰好将数组对半分割</strong>, 这种情况下的比较次数正好满足分支递归公式:</p>

\[C_N = 2 \cdot C_{\frac{N}{2}} + N\]

<p>其中 $2 \cdot C_{\frac{N}{2}}$ 表示 <strong>将两个子数组排序的成本</strong>, $N$ 表示用 <strong>切分元素</strong> 和 <strong>所有数组元素</strong> 进行比较的成本. 由 <code class="language-plaintext highlighter-rouge">命题 2.4</code> 可知, 该递归公式的解是 $N \cdot \lg(N)$. 虽然实际上我们不可能每次切分都恰好是理想情况, 但 <strong>平均而言</strong> 切分元素都能落在数组中间. 下面我们来对快速排序的性能表现进行证明:</p>

<p><strong>命题 2.9</strong></p>
<blockquote>
  <p><strong>快速排序</strong> 将长度为 $N$ 的 <strong>无重复数组</strong> 排序平均需要 $\sim 2N \cdot \ln(N)$ 次比较.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>记 $C_N$ 为 <strong>将 $N$ 个不同元素排序平均所需的比较次数</strong>. 显然, $C_0 = C_1 = 1$. 对于 $N &gt; 1$, 由递归程序可得如下的归纳关系:</p>

\[C_N = N+1 + \frac{(C_0 + C_1 + \cdots + C_{N-2} + C_{N-1})}{N} + \frac{(C_{N-1}+C_{N-2}+\cdots+C_0)}{N}\]

  <p>第一项是 <strong>切分的成本</strong>, 总共为 $(N+1)$. 第二项是将长可能为 $0$ 到 $N-1$ 的左子数组 <strong>排序的平均成本</strong>, 而第三项则是将右子数组 <strong>排序的平均成本</strong>. 去分母后可得:</p>

\[N \cdot C_N = N(N+1) + (C_0 + C_1 + \cdots + C_{N-2} + C_{N-1}) + (C_{N-1}+C_{N-2}+\cdots+C_0)\]

  <p>将该等式减去其 <strong>$N-1$ 时的相同等式</strong> 可得:</p>

\[N\cdot C_N - (N-1)C_{N-1} = 2N + 2\cdot C_{N-1}\]

  <p>整理等式并将两边同除 $N(N+1)$ 可得:</p>

\[\frac{C_N}{N+1} = \frac{C_{N-1}}{N} + \frac{2}{N+1}\]

  <p>由归纳推导得:</p>

\[C_N \sim 2(N+1)(\frac{1}{3} + \frac{1}{4} + \cdots + \frac{1}{N+1})\]

  <p>近似于</p>

\[C_N \sim \int_{1}^{N}\frac{2}{x}dx + 1 \sim 2N \ln(N).\]

  <p>注意到 $2N \ln(N) \approx 1.39 \lg(N)$. 也就是说, <strong>平均比较次数只比最好情况多了 $39\%$.</strong></p>
</blockquote>

<p>快速排序的实现还有一个 <strong>潜在的缺点</strong>: 在切分不平衡时程序可能会极其低效. 这也是我们需要在执行快速排序前将数组 <strong>随机排序</strong> 的主要原因.</p>

<p><strong>命题 2.10</strong></p>
<blockquote>
  <p>快速排序最多需要 $\frac{N^2}{2}$ 次比较, 但随机打乱数组能预防这种情况.</p>
</blockquote>

<p><br /></p>

<h3 id="算法改进">算法改进</h3>

<ol>
  <li>切换到插入排序: 对于小数组, 快速排序慢于插入排序. 我们可以在排序小数组时切换到插入排序提升算法的性能.</li>
  <li>三取样切分: 我们可以使用 <strong>子数组的一小部分元素的中位数</strong> 来切分数组以得到更好的切分效果, 而将 <strong>取样大小设为 $3$</strong> 并用大小居中的元素切分的效果更好.</li>
  <li>熵最优的排序: 在实际应用中可能遇到 <strong>含有大量重复元素</strong> 的数组, 而快速排序会将本不需继续排序的, 元素全部重复的子数组继续切分, 因此可以通过将数组切分为对应 <strong>小于, 等于, 大于</strong> 切分元素的三个部分避免性能损失.</li>
</ol>

<p><br /></p>

<h2 id="24-优先队列">2.4 优先队列</h2>

<p>队列是一种先进先出的数据结构. 元素在队列尾追加, 而从队列头删除. 在优先队列中, 元素被赋予 <strong>优先级</strong>. 我们将在本节中讨论优先队列的基本表现形式, 然后会学习基于 <strong>二叉堆</strong> 数据结构的, 一种 <strong>优先队列的经典实现</strong>, 用数组保存元素并按照优先级排序, 以实现对数级别的高效元素删除/插入操作.</p>

<p>通过插入一列元素并一个个地 <strong>删除其中最小的元素</strong>, 我们也可以用优先队列实现排序算法, 一种名为 <strong>堆排序</strong> 的重要排序算法也来自 <strong>基于堆的优先队列的实现</strong>. 在后续的章节中我们还会学习如何使用优先队列构造其他算法.</p>

<h3 id="api的设计与实现">API的设计与实现</h3>

<p>作为一种 <strong>抽象数据类型</strong>, 我们同样需要定义一组 <code class="language-plaintext highlighter-rouge">API</code> 为该数据解雇的用例提供足够的信息. 优先队列最重要的操作是 <strong>删除最大元素</strong> 和 <strong>插入元素</strong>. 我们称删除最大元素和插入元素的方法分别名为 <code class="language-plaintext highlighter-rouge">delMax()</code> 和 <code class="language-plaintext highlighter-rouge">insert()</code>. 按照惯例, 我们使用辅助函数 <code class="language-plaintext highlighter-rouge">less()</code> 对它们进行比较. 和排序算法相同, 若允许重复元素,  <strong>最大</strong> 所表示的是 <strong>这些相同的最大元素之一</strong>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"><code class="language-plaintext highlighter-rouge">public class</code></th>
      <th style="text-align: left"><code class="language-plaintext highlighter-rouge">MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;</code></th>
      <th style="text-align: left"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">MaxPQ()</code></td>
      <td style="text-align: left">创建一个优先队列</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">MaxPQ(int max)</code></td>
      <td style="text-align: left">创建一个最大容量为 <code class="language-plaintext highlighter-rouge">max</code> 的优先队列</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">MaxPQ(Key[] a)</code></td>
      <td style="text-align: left">用 <code class="language-plaintext highlighter-rouge">a[]</code> 中的元素创建一个优先队列</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">void</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Insert(Key v)</code></td>
      <td style="text-align: left">向优先队列中插入一个元素</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Key</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">max()</code></td>
      <td style="text-align: left">返回最大元素</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Key</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">delMax()</code></td>
      <td style="text-align: left">删除并返回最大元素</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">boolean</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td style="text-align: left">检查队列是否为空</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">int</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td style="text-align: left">返回队列中的元素个数</td>
    </tr>
  </tbody>
</table>

<h3 id="初级实现">初级实现</h3>

<p>我们在 <strong>第一章</strong> 中讨论过的四种基础数据结构是实现优先队列的起点. 我们可以使用 <strong>有序或无序的数组或链表</strong> 实现它:</p>

<ol>
  <li>数组实现 (无序)</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQwArray</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">pq</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">max</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="nc">Key</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">Insert</span><span class="o">(</span><span class="nc">Key</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">++]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> 
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">delMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">--];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>数组实现 (有序)</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQwArray</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">pq</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">max</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="nc">Key</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">Insert</span><span class="o">(</span><span class="nc">Key</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[++</span><span class="no">N</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">pq</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">exch</span><span class="o">(</span><span class="n">pq</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">delMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">--];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>链表实现</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQwLlist</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">pq</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="nc">Item</span> <span class="n">item</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="nc">Key</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">Insert</span><span class="o">(</span><span class="nc">Key</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">oldpq</span> <span class="o">=</span> <span class="n">pq</span><span class="o">;</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">();</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">oldpq</span><span class="o">;</span>
        <span class="no">N</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Double</span><span class="o">.</span><span class="na">NEGATIVE_INFINITY</span><span class="o">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">pq</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">item</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">delMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Double</span><span class="o">.</span><span class="na">NEGATIVE_INFINITY</span><span class="o">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">pq</span><span class="o">;</span>
        <span class="n">node_last</span> <span class="o">=</span> <span class="n">pq</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">item</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">node_last</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="no">N</span><span class="o">--;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">last</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="堆的定义">堆的定义</h3>

<p>数据结构 <strong>二叉堆</strong> 能很好地实现优先队列的基本操作. 在二叉堆的数组中,  每个元素都要保证 <strong>大于等于另外两个特定位置的元素</strong>, 相应地这些位置的元素要 <strong>至少大于等于</strong> 数组中的 <strong>另外两个元素</strong>. 当我们将 <strong>二叉堆</strong> 中的所有元素画成一棵 <strong>二叉树</strong>, 将每个较大元素和两个较小元素用边连接就能直观地看出这种结构.</p>

<p><strong>定义</strong></p>
<blockquote>
  <p>当一棵二叉树的每个结点都 <strong>大于等于</strong> 它的 <strong>两个子结点</strong> 时, 称其为 <strong>堆有序</strong>.</p>
</blockquote>

<p>相应地, 在 <strong>堆有序</strong> 的二叉树中, 每个结点都 <strong>小于等于</strong> 其父节点. 从任意结点向上, 我们都能得到一列 <strong>非递减</strong> 的元素; 从任意结点向下, 都能得到一列 <strong>非递增</strong> 的元素. 特别地:</p>

<p><strong>命题 2.11</strong></p>
<blockquote>
  <p>根结点是堆有序的二叉树中的最大结点.</p>
</blockquote>

<p>我们下面讨论二叉堆的表示法:</p>

<p>如果使用 <strong>指针</strong> 表示 <strong>堆有序的二叉树</strong>, 则每个元素需要 <strong>三个指针</strong> 来定位它的上下结点, 父节点和两个子结点各一个.</p>

<p>若使用 <strong>完全二叉树</strong>, 就可以更为方便地表达. 要画出这样的完全二叉树, 可以先定下跟结点, 然后层层从上到下, 从左到右, 在每个结点的下方连接两个更小的结点直到全部连接完毕. 只要将二叉树的结点按照层级顺序放入数组中, 就可以只用数组而不需要指针就能表示完全二叉树.</p>

<p><strong>定义</strong></p>
<blockquote>
  <p><strong>二叉堆</strong> 是一组能够用 <strong>堆有序的完全二叉树</strong> 排序的元素, 并在数组中按照层级储存.</p>
</blockquote>

<p>我们下面 <strong>将二叉堆简称为堆</strong>. 在一个堆中, 位置 $k$ 的结点的父节点的位置为 $\lfloor \frac{k}{2} \rfloor$, 因此我们可以通过 <strong>计算数组的索引</strong> 在树中 <strong>上下移动</strong>:</p>

<p><strong>要从 <code class="language-plaintext highlighter-rouge">a[k]</code> 向上一层, 就可令 $k = \frac{k}{2}$, 要向下一层的话就可令 $k=2k$ 或 $2k+1$.</strong></p>

<p><strong>命题 2.12</strong></p>
<blockquote>
  <p>大小为 $N$ 的完全二叉树的高度为 $\lfloor \lg(N) \rfloor$.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>在 $N=1, 2$ 的情形下, 命题显然成立. <br />
下面考虑 $N &gt; 2$ 的情况. 不妨假设 $N=k$ 时命题成立, 此时有</p>

\[h(k) = \lfloor \lg(k) \rfloor.\]

  <p>当 $N = k+1$ 时, 有下列的两种情况:</p>

\[\begin{cases} 1. ~ h(k+1) = h(k)+1 ~~~~~~ \exists r, ~ \text{s.t.} ~ 2^r = k+1.  \\ 2. ~ h(k+1) = h(k) ~~~~~~~~~~~~~ \text{else}\end{cases}\]

  <p>对于情形 $1$: $h(k)+1 = \lfloor \lg(k)+1 \rfloor$. 由二叉树的组合性质:</p>

\[h(k+1) = r = \lg(k+1) =  \lfloor \lg(k+1) \rfloor. ~~(*)\]

  <p>对于情形 $2$: 由于此时 $k+1$ 不是 $2$ 的幂, 故 $\exists r_1$, 使得 $2^{r_1} \leqslant k &lt; k+1 &lt; 2^{r_1+1}$. 也就是:</p>

\[r_1 \leqslant \lg(k) &lt; \lg(k+1) &lt; r_1 + 1\]

  <p>由此有</p>

\[\lfloor \lg(k) \rfloor = \lfloor \lg(k+1) \rfloor\]

  <p>所以同样有</p>

\[h(k+1) = \lfloor \lg(k+1) \rfloor. ~~(**)\]

  <p>结合 $(*), (**)$ 可知, 原命题成立. $\blacksquare$</p>
</blockquote>

<p>堆的表示如下图所示:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20210921211450.png" alt="20210921211450" /></p>

<p><br /></p>

<h3 id="堆的算法">堆的算法</h3>

<p>我们用长度 $N+1$ 的数组 <code class="language-plaintext highlighter-rouge">pq</code> 表示一个大小为 $N$ 的堆. 此数组的首元素 <code class="language-plaintext highlighter-rouge">pq[0]</code> 被闲置, 而堆元素被放在后面的 $N$ 个元素 <code class="language-plaintext highlighter-rouge">pq[1], ..., pq[N]</code>中.</p>

<p><strong>定义</strong></p>
<blockquote>
  <p>我们称打破堆的状态, 随后遍历它并按照要求将堆的状态恢复的过程为 <strong>堆的有序化</strong>.</p>
</blockquote>

<p>在有序化的过程中, 我们可能需要 <strong>自下而上</strong> 或 <strong>自上而下</strong> 地恢复堆的状态. 前者可能发生于 <strong>某个结点的优先级上升</strong> 或 <strong>在堆底加入了一个新元素</strong> 时, 而后者可能在 <strong>某个结点的优先级下降</strong> 时.</p>

<ol>
  <li>
    <p>自下而上的堆有序化 (上浮)
 如果堆的有序状态被打破的原因是其某个结点变得 <strong>比它的父结点更大</strong>, 我们可以通过交换它和它的父节点实现状态的修复. 即使在交换后它仍然比其父节点更大, 通过有限次重复这一过程, 我们仍可以最终完全将堆的状态恢复:</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">while</span> <span class="o">(</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">k</span><span class="o">))</span> <span class="o">{</span>
         <span class="n">exch</span><span class="o">(</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
         <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">swim()</code> 方法中的循环确保当且仅当位置 $k$ 上的结点大于它的父节点时才会打破堆的有序状态, 因此通过让该结点 <strong>不再大于</strong> 它的父结点, 就可以恢复有序状态.</p>
  </li>
  <li>
    <p>自上而下的堆有序化 (下沉)
相应地, 如果堆的有序状态因为某个结点变得 <strong>比它的两个子结点 (的其中之一) 更小</strong> 而因此被打破, 通过将该结点与其子结点中 <strong>更大的那一个</strong> 交换, (也许同样需要交换多次) 我们最终就可以修复有序状态.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">while</span> <span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
         <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">;</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">j</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
             <span class="n">j</span><span class="o">++;</span>
         <span class="o">}</span>
         <span class="k">if</span> <span class="o">(!</span><span class="n">less</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
             <span class="k">break</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="n">exch</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
         <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ol>

<p>上述的两种方法是我们高效实现 <strong>优先队列API</strong> 的基础:</p>

<ol>
  <li>
    <p>插入元素:
 只需要将新元素加到数组末尾,增加堆的大小并将这个新元素 <strong>上浮到合适的位置</strong> 即可.</p>
  </li>
  <li>
    <p>删除最大元素:
 从数组顶端删去最大元素, 并将 <strong>数组的最后一个元素放到顶端</strong>, 减小堆的大小并 <strong>让这个元素下沉到合适的位置</strong>.</p>
  </li>
</ol>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20210921233643.png" alt="20210921233643" /></p>

<p>下列的算法对优先队列 <code class="language-plaintext highlighter-rouge">API</code> 的实现确保了 <strong>插入元素和删除最大元素</strong> 这两个操作的用时和队列的大小 <strong>成对数关系</strong>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaxPQ</span><span class="o">&lt;</span><span class="nc">Key</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Key</span><span class="o">[]</span> <span class="n">pq</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">maxN</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Key</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Comparable</span><span class="o">[</span><span class="n">maxN</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">N</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="nc">Key</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pq</span><span class="o">[++</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
        <span class="n">swim</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">delMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Key</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>    <span class="c1">// fetch the largest element</span>
        <span class="n">exch</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="no">N</span><span class="o">--);</span>       <span class="c1">// exchange it with the last elem (equals to deleting it)</span>
        <span class="n">pq</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>     <span class="c1">// eliminate the ptr to the original max, prevent exceeding boundary</span>
        <span class="n">sink</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>            <span class="c1">// let this element sink to its proper position, recover the heap's order</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// these helpers are defined in the before this code snippet</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">less</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">exch</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>命题 2.13</strong></p>
<blockquote>
  <p>对一个含有 $N$ 个元素的, 基于堆的优先队列, <strong>插入元素操作</strong> 只需不超过 $\lg(N)+1$ 次比较, <strong>删除最大元素操作</strong> 需要的比较次数不超过 $2\lg(N)$.</p>
</blockquote>

<p><strong>证明</strong></p>
<blockquote>
  <p>两种操作都涉及在根结点和堆底之间的元素移动. 由 <strong>命题 2.12</strong> 得: 这种元素移动的路径不超过 $\lg(N)$, 结合代码段不难得出命题对 <strong>插入元素操作</strong> 的描述成立. 由于 <strong>删除最大元素</strong> 需要两次比较: 一次用于找出更大的那个子结点, 一次用来判断该子结点是否需要上浮, 因此剩下的描述也成立. $\blacksquare$</p>
</blockquote>

<h3 id="堆排序">堆排序</h3>

<p>将所有元素插入一个 <strong>查找最小元素的优先队列</strong>, 并 <strong>重复调用删除最小元素</strong> 的操作将它们按顺序删去, 这样的操作使用 <strong>无序数组</strong> 实现的优先队列来实现就相当于进行了 <strong>插入排序</strong>, 而使用 <strong>基于堆</strong> 的优先队列实现, 就相当于 <strong>堆排序</strong>.</p>

<p>堆排序基本上分为两个阶段. 在 <strong>堆的构造阶段</strong> 中, 我们将原始数组重新组织并安排进一个堆中, 而在 <strong>下沉排序</strong> 阶段, 则可从堆中按递减顺序取出所有元素并得到排序结果.</p>

<h4 id="构造堆">构造堆</h4>

<p>我们可以简单地 <strong>从左到右遍历数组</strong>, 用 <code class="language-plaintext highlighter-rouge">swim()</code> 确保 <strong>扫描指针左侧所有元素都已经是一棵有序的完全数</strong> 即可. 这样的方法耗费的时间与 $N \cdot \log(N)$ 成正比.</p>

<p>更高效的方式是 <strong>从右到左</strong> 用 <code class="language-plaintext highlighter-rouge">sink()</code> 函数构造子堆. 我们可以将数组中的每个元素都视为 <strong>某个子堆的根结点</strong>, 因此 <code class="language-plaintext highlighter-rouge">sink()</code> 方法自然对每个元素对应的子堆都适用. 如果一个结点的两个子结点都已经是堆, 则在该结点上调用 <code class="language-plaintext highlighter-rouge">sink()</code> 就可以将它们三个变成一个更大的堆. 递归地重复这一过程, 我们就可以建立起堆的秩序.</p>

<p><strong>命题 2.14</strong></p>
<blockquote>
  <p>用 <code class="language-plaintext highlighter-rouge">sink()</code> 操作由 $N$ 个元素构造一个堆只需 <strong>少于 $2N$ 次比较</strong> 和 <strong>少于 $N$ 次交换</strong>.</p>
</blockquote>

<p>堆排序的算法实现如下:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">--)</span> <span class="o">{</span>
        <span class="n">sink</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="no">N</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="no">N</span><span class="o">--);</span>
        <span class="n">sink</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2021/09/03/algHeip-1/" data-toggle="tooltip" data-placement="top" title="普林斯顿算法4-Ch1 基础">
                        Previous<br>
                        <span>普林斯顿算法4-Ch1 基础</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2021/09/25/algHeip-3/" data-toggle="tooltip" data-placement="top" title="普林斯顿算法4-Ch3 查找">
                        Next<br>
                        <span>普林斯顿算法4-Ch3 查找</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
        
                <a data-sort="0109" 
                    href="/archive/?tag=COMP12111"
                    title="COMP12111"
                    rel="10">COMP12111</a>
        
                <a data-sort="0072" 
                    href="/archive/?tag=%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0"
                    title="课程笔记"
                    rel="47">课程笔记</a>
        
                <a data-sort="0079" 
                    href="/archive/?tag=%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0"
                    title="前端学习"
                    rel="40">前端学习</a>
        
                <a data-sort="0079" 
                    href="/archive/?tag=50P50D"
                    title="50P50D"
                    rel="40">50P50D</a>
        
                <a data-sort="0104" 
                    href="/archive/?tag=COMP24011"
                    title="COMP24011"
                    rel="15">COMP24011</a>
        
                <a data-sort="0107" 
                    href="/archive/?tag=%E9%80%BB%E8%BE%91%E5%AD%A6"
                    title="逻辑学"
                    rel="12">逻辑学</a>
        
                <a data-sort="0109" 
                    href="/archive/?tag=COMP15111"
                    title="COMP15111"
                    rel="10">COMP15111</a>
        
                <a data-sort="0110" 
                    href="/archive/?tag=%E6%89%A9%E5%B1%95%E8%87%AA%E4%B9%A0"
                    title="扩展自习"
                    rel="9">扩展自习</a>
        
                <a data-sort="0110" 
                    href="/archive/?tag=COMP21111"
                    title="COMP21111"
                    rel="9">COMP21111</a>
        
                <a data-sort="0112" 
                    href="/archive/?tag=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"
                    title="机器学习"
                    rel="7">机器学习</a>
        
                <a data-sort="0112" 
                    href="/archive/?tag=COMP11212"
                    title="COMP11212"
                    rel="7">COMP11212</a>
        
                <a data-sort="0115" 
                    href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"
                    title="数据结构和算法"
                    rel="4">数据结构和算法</a>
        
                <a data-sort="0115" 
                    href="/archive/?tag=COMP15212"
                    title="COMP15212"
                    rel="4">COMP15212</a>
        
                <a data-sort="0115" 
                    href="/archive/?tag=COMP23111"
                    title="COMP23111"
                    rel="4">COMP23111</a>
        
                <a data-sort="0117" 
                    href="/archive/?tag=%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7"
                    title="奇技淫巧"
                    rel="2">奇技淫巧</a>
        
                <a data-sort="0117" 
                    href="/archive/?tag=%E7%AE%97%E6%B3%95"
                    title="算法"
                    rel="2">算法</a>
        
                <a data-sort="0117" 
                    href="/archive/?tag=Lab"
                    title="Lab"
                    rel="2">Lab</a>
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="http://ryanxin.cn">琳若尘泥 十里琅居</a></li>
  
  <li><a href="https://flyhigher.top">无垠 - 飞翔的天空无限大</a></li>
  
  <li><a href="https://graynekocafe.net">灰貓咖啡廳</a></li>
  
  <li><a href="Gnefil.github.io">GNEFIL</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

</div>


<!-- add support for mathjax by voleking-->


<!-- add busuanzi statistics support-->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "KirisameR";
    var disqus_identifier = "/2021/09/14/algHeip-2";
    var disqus_url = "http://localhost:4000/2021/09/14/algHeip-2/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

    
        <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  <li>
    <a href="https://twitter.com/eigentom">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="http://t.me/Kirisame_Marisa">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-telegram fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/KirisameR">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="https://www.linkedin.com/in/yilu-82589933">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; 某一般线性空间 2022
                    <br>
                    Powered by <a href="616.sb">Hux Enhanced</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '/search.json',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>
        <!-- Image to hack wechat -->
        <img src="/img/icon_wechat.png" width="0" height="0" />
        <!-- Migrate from head to bottom, no longer block render and still work -->
    </div>
</body>

</html>
