<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>某一般线性空间</title>
    <description>由于相关法律法规规定, 该内容无法显示.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 03 May 2022 22:45:37 +0100</pubDate>
    <lastBuildDate>Tue, 03 May 2022 22:45:37 +0100</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>数据结构与算法： El Gamal加密算法</title>
        <description>&lt;h1 id=&quot;el-gamal-加密算法&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 加密算法&lt;/h1&gt;

</description>
        <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/25/Ch7-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/25/Ch7-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>并行计算和系统资源分配</title>
        <description>&lt;h1 id=&quot;并行计算和系统资源分配&quot;&gt;并行计算和系统资源分配&lt;/h1&gt;

&lt;h2 id=&quot;1-solidity&quot;&gt;1. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt;&lt;/h2&gt;

</description>
        <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/15/Ch4-COMP26020/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/15/Ch4-COMP26020/</guid>
        
        <category>课程笔记</category>
        
        <category>并行计算</category>
        
        
      </item>
    
      <item>
        <title>编译器引论</title>
        <description>&lt;h1 id=&quot;编译器引论&quot;&gt;编译器引论&lt;/h1&gt;

&lt;p&gt;任何使用程序设计语言编写的计算机程序在被实际执行前都必须 &lt;strong&gt;转译为机器语言&lt;/strong&gt;, 而负责这一转译过程的软件系统就是 &lt;strong&gt;编译器&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Compiler&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;在本章中, 我们将简要介绍 &lt;strong&gt;编译&lt;/strong&gt; 流程的基本原理和技术, 并简单讨论在构造编译器时可能遇到的一些常见问题.&lt;/p&gt;

&lt;h2 id=&quot;1-绪论&quot;&gt;1. 绪论&lt;/h2&gt;

&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;我们首先为 &lt;strong&gt;编译器&lt;/strong&gt; 的概念给出形式化的定义.&lt;/p&gt;

&lt;p&gt;一种说法是, 任何接收一种一段程序字段作为输入, 并以另一种语言的程序字段作为输出, 且输入和输出的含义保持一致的程序就被称为 &lt;strong&gt;编译器&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;我们也可认为, 任何读入用一种语言编写的程序, 并将其翻译为另一种语言下的等价形式的程序也是 &lt;strong&gt;编译器&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;解释器&lt;/strong&gt; 的概念为: 任何读入一段 &lt;strong&gt;源程序&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Source Program&lt;/code&gt;) 并产出 &lt;strong&gt;执行这段源程序的结果&lt;/strong&gt; 的程序.&lt;/p&gt;

&lt;p&gt;必须使用 &lt;strong&gt;编译器&lt;/strong&gt; 才能生成可被直接运行的可执行文件的程序设计语言被称为 &lt;strong&gt;编译型语言&lt;/strong&gt;, 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C/C#/C++&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LaTeX&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;而无需编译可被解释器直接运行的语言称为 &lt;strong&gt;解释型语言&lt;/strong&gt;, 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python, PHP, JavaScript&lt;/code&gt; 等.&lt;/p&gt;

&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;

&lt;p&gt;编译器作为衔接两种不同语言之间的桥梁, 其最基础的功能就是 &lt;strong&gt;在翻译过程中确保程序所含的语义 (意义) 保持不变&lt;/strong&gt;. 而在实际情况中, 编译器往往还承担了对源代码进行 (各种意义上的) 优化的功能, 如:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提升编译后的程序的运行速度&lt;/li&gt;
  &lt;li&gt;减少编译后的程序的占用空间&lt;/li&gt;
  &lt;li&gt;向用户提供有价值的反馈和信息&lt;/li&gt;
  &lt;li&gt;在编译失败时能够返回便于调试的错误信息&lt;/li&gt;
  &lt;li&gt;以较高的效率编译源码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而一般地, 我们认为优秀的编译器至少需要具备下列的其中一些特质:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314213639.png&quot; alt=&quot;20220314213639&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上, 编译技术的应用场景不仅局限在对程序设计语言的转换上. 它还可用于优化计算机机构, 实现自动的并行式计算, 提升软件安全性等.&lt;/p&gt;

&lt;h3 id=&quot;基本结构&quot;&gt;基本结构&lt;/h3&gt;

&lt;p&gt;下面我们考虑编译器的基本结构.&lt;/p&gt;

&lt;p&gt;我们在上面的介绍中已经知道, 编译器以 &lt;strong&gt;源代码&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Source Code&lt;/code&gt;) 作为输入, 将其转换输出 &lt;strong&gt;目标代码&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object Code&lt;/code&gt;). 因此, 正常工作的编译器需要具备的最基础性质是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;生成的目标代码必须是正确的, 保持源代码的语义不变.&lt;/li&gt;
  &lt;li&gt;必须具备识别源代码中错误的能力.&lt;/li&gt;
  &lt;li&gt;必须具备对源代码进行分析与合成目标代码的能力.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进一步地, 编译器内部又被划分为 &lt;strong&gt;前端&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Front-End&lt;/code&gt;) 以及 &lt;strong&gt;后端&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Back-End&lt;/code&gt;) 两个部分, 前端 &lt;strong&gt;输入源代码, 输出中间表示&lt;/strong&gt;, 而后端以 &lt;strong&gt;中间表示作为输入, 输出目标代码&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt; 负责对源代码进行 &lt;strong&gt;分析&lt;/strong&gt;, 源代码的合法性和可能存在的错误需要在这一阶段中被识别并反馈; 同时, 前端需要 “理解” 并收集源代码蕴含的语义, 并由此生成代码的 &lt;strong&gt;中间表示&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt; 负责对目标代码的 &lt;strong&gt;合成&lt;/strong&gt;: 在这一阶段中, 后端将对中间表示中每一行指令和运算选择合适的指令, 并由此将中间表示翻译为目标语言.&lt;/p&gt;

&lt;p&gt;需要注意, 前端涉及的大部分操作都可以被 &lt;strong&gt;自动化&lt;/strong&gt;, 因此对常见的编译器而言执行前端操作的时间复杂度为 $O(n)$ 级别, 而后端所需要处理的问题则为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; (要想确保完全解决这类问题需要至少指数级别的时间复杂度) 的.&lt;/p&gt;

&lt;p&gt;编译器中 &lt;strong&gt;前后端分离&lt;/strong&gt; 的架构便于编译器的 &lt;strong&gt;模块化&lt;/strong&gt;, 它允许我们将 &lt;strong&gt;能够生成或处理相同类型的中间表示的&lt;/strong&gt;, 针对不同语言的前后端进行 &lt;strong&gt;拼接&lt;/strong&gt;, 从而构造出可以编译不同语言, 适配不同平台的编译器.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215002.png&quot; alt=&quot;20220314215002&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;前端结构&quot;&gt;前端结构&lt;/h3&gt;

&lt;p&gt;我们下面讨论编译器前端的基本结构.&lt;/p&gt;

&lt;p&gt;编译器前端一般由 &lt;strong&gt;词法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexical Analysis&lt;/code&gt;), &lt;strong&gt;语法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Syntax Analysis&lt;/code&gt;), &lt;strong&gt;语义分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semantic Analysis&lt;/code&gt;) 和 &lt;strong&gt;中间表示生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intemediate Code Generation&lt;/code&gt;) 四个部分组成.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215256.png&quot; alt=&quot;20220314215256&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先考虑 &lt;strong&gt;词法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexical Analysis&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scanning&lt;/code&gt;). 在这一步中, 编译器前端需要:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;扫描, 读入源代码的字符&lt;/strong&gt;, 并将其 &lt;strong&gt;分组为词汇&lt;/strong&gt; 形成有意义的 &lt;strong&gt;词素序列&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexeme&lt;/code&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成词汇, 并分析不同词汇的 &lt;strong&gt;类型&lt;/strong&gt;, 生成将要传递到下一步中进行语法分析的 &lt;strong&gt;词法单元&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;). 其形式一般为&lt;/p&gt;

\[\text{&amp;lt;type, lexeme&amp;gt;}\]

    &lt;p&gt;或&lt;/p&gt;

\[\text{&amp;lt;token\_class, attribute&amp;gt;}\]
  &lt;/li&gt;
  &lt;li&gt;此外, 在生成词法单元时, 词法分析器还需要维护 &lt;strong&gt;符号表&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Symbol Table&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;在词法分析中, 空格, 注释等和程序逻辑无关的内容都会被过滤.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其次考虑 &lt;strong&gt;语法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Syntax Analysis&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parsing&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;在语法分析这一步中, 第一步中生成的各词法单元将被 &lt;strong&gt;解析&lt;/strong&gt;, 从而生成 &lt;strong&gt;树状的中间表示&lt;/strong&gt;, 常用的就是 &lt;strong&gt;语法树&lt;/strong&gt;. 树状的语法结构将被用于编译器的后续步骤来分析源程序并生成目标程序.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220308.png&quot; alt=&quot;20220314220308&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般地, 生成树还会被进一步通过删去多余的信息被简化为 &lt;strong&gt;抽象语法树&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abstract Syntax Tree&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AST&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220818.png&quot; alt=&quot;20220314220818&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后考虑 &lt;strong&gt;语义分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semantic Analysis&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context Handling&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;语义分析由 &lt;strong&gt;语义分析器&lt;/strong&gt; 完成, 负责收集语义信息, 检查语义错误, 如类型检查, 检测变量是否被合法地声明, 进行变量与函数的命名检查等. 它还将使用语法树和符号表中的信息检查源程序是否和源语言定义的语义一致.&lt;/p&gt;

&lt;p&gt;此外, 语义分析器也会收集 &lt;strong&gt;类型信息&lt;/strong&gt;, 并将这些信息放在语法树或符号表中.&lt;/p&gt;

&lt;p&gt;语义分析器最重要的功能是 &lt;strong&gt;类型检查&lt;/strong&gt;: 检测每个运算符 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operator&lt;/code&gt;) 是否具有 &lt;strong&gt;匹配的运算分量&lt;/strong&gt;, 若目标语言要求某个数组的下标必须是整数, 则若用浮点数作为下标的时候编译器就会将这种操作认定为类型错误.&lt;/p&gt;

&lt;p&gt;最后考虑 &lt;strong&gt;中间表示生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intemediate Code Generation&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;编译器会在完成源代码的词法分析, 语法分析和语义分析后生成一个 &lt;strong&gt;明确的, 类机器语言的中间表示&lt;/strong&gt;. 本质上, 中间表示是一种对源代码的抽象, 合格的中间表示必须是便于生成且便于翻译的, 常用的中间表示形式是 &lt;strong&gt;三地址指令&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Three-Address Instruction&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;后端结构&quot;&gt;后端结构&lt;/h3&gt;

&lt;p&gt;继续讨论编译器的后端结构.&lt;/p&gt;

&lt;p&gt;编译器后端一般由 &lt;strong&gt;中间表示优化&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intermediate Code Optimisation&lt;/code&gt;), &lt;strong&gt;代码生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code Generation&lt;/code&gt;), &lt;strong&gt;目标代码优化&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target Code Optimisation&lt;/code&gt;) 和 &lt;strong&gt;目标代码生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target Code Generation&lt;/code&gt;) 构成.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314221932.png&quot; alt=&quot;20220314221932&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先讨论 &lt;strong&gt;中间代码优化&lt;/strong&gt;. 在这一步中, 编译器后端会尝试基于预先给定的目标 (如生成能耗更低/更短/更快的代码) 对传入的中间代码进行优化.&lt;/p&gt;

&lt;p&gt;而在后续的步骤中, 需要以经过优化的中间代码作为输入, 并将其映射为目标语言. 若目标语言是机器语言, 还需要在这一步中 &lt;strong&gt;选择合适的机器指令, 为每个变量分配寄存器或指定内存位置&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314222308.png&quot; alt=&quot;20220314222308&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503223953.png&quot; alt=&quot;20220503223953&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224004.png&quot; alt=&quot;20220503224004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224023.png&quot; alt=&quot;20220503224023&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-词法分析-lexical-analysis&quot;&gt;2. 词法分析 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexical Analysis&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;在本节中, 我们讨论词法分析步骤中的基本原理.&lt;/p&gt;

&lt;p&gt;回顾定义, 词法分析是读入程序源码并将其转换为一系列词素 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;) 的过程.&lt;/p&gt;

&lt;p&gt;为了避免人工编码复杂的词法分析器, 简化程序语言的语法定义和实现, 词法分析器对编译器而言至关重要.&lt;/p&gt;

&lt;p&gt;为了便于后续的解释, 此处引入一系列定义:&lt;/p&gt;

&lt;h3 id=&quot;基本定义&quot;&gt;基本定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;定义 2.1&lt;/strong&gt; (单词表, 字符串, 语言和语法)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;称由一系列不同符号组成的集合为单词表.&lt;/li&gt;
    &lt;li&gt;称由一系列单词表中的符号组成的有序队列为字符串.&lt;/li&gt;
    &lt;li&gt;称由所有定义在某个单词表上的字符串组成的集合为语言.&lt;/li&gt;
    &lt;li&gt;称任何一种有限的, 表示语言的方式为语法.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 2.2&lt;/strong&gt; (上下文无关语法, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context-Free Grammar&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;记上下文无关语法 $G$ 为四元组&lt;/p&gt;

\[G = (S, N, T, P):\]

  &lt;ol&gt;
    &lt;li&gt;$S$: 起始符号 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Starting Symbol&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;$N$: 非终止符号 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Non-Terminal Symbol&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;$T$: 终止符号 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Terminal Symbol&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;$P$: 生成规则&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此我们也可将语言定义为由某个上下文无关语法生成的所有终止的字符串组成的集合. 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222240.png&quot; alt=&quot;20220429222240&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一般情况下非终止符号均用大写字母表示.&lt;/li&gt;
  &lt;li&gt;上面的例子中使用的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LeftMost Derivation&lt;/code&gt;: 基于规则从左到右逐步构建字符串.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上下文无关语法对于词法分析至关重要. 使用恰当的表示方法, 我们即可利用上下文无关语法高度的结构性和过程性对程序语言的语法进行编码. 下面简介其中一种恰当的表示法: &lt;strong&gt;正则表达式&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;正则表达式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Regular Expression&lt;/code&gt;) 用于表示正则语言, 我们可以使用正则表达式表示无穷种字符串.&lt;/p&gt;

&lt;p&gt;正则表达式的基本语法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222758.png&quot; alt=&quot;20220429222758&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意, 正则表达式的基础语法恰为前三条, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shorthands&lt;/code&gt; 实为对前三条规则的简化封装, 类似语法糖.&lt;/p&gt;

&lt;p&gt;虽然 &lt;strong&gt;正则表达式无法用于表示所有语言&lt;/strong&gt;, 但它足够解决绝大多数的问题. 下面给出正则表达式表示整数, 浮点型和变量名的例子. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt; 表达式的例子中, 我们使用正则表达式分别用常规方式和科学技术法表示了浮点型数字.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222904.png&quot; alt=&quot;20220429222904&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上文所述, 理论上我们完全可以将词法分析规则硬编码, 但这样做会极大降低分析器的可扩展性, 难以修改, 且工作量巨大. 正则表达式恰可以 &lt;strong&gt;自动化词法分析的过程&lt;/strong&gt;, 极大地简化我们在构造词法分析器时的工作.&lt;/p&gt;

&lt;p&gt;如下图所示, 正则表达式实际上可以被表示为状态转换图.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223259.png&quot; alt=&quot;20220429223259&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中的转换图可以被相应地 &lt;strong&gt;等价表示&lt;/strong&gt; 为下列的转换表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223347.png&quot; alt=&quot;20220429223347&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在转换表中, 第一列表示当前状态的编号, 第二列表示在当前状态下接受不同输入将会导致状态转换 (切换, 更新) 到什么新的状态上, 如在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state0&lt;/code&gt; 时, 若输入为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; 则所处状态将转换到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state1&lt;/code&gt;, 而任何其他输入都无法让当前状态转换.&lt;/p&gt;

&lt;p&gt;进一步地, 在将正则表达式所表示的状态转换图转化为状态转换表后, 我们就可以通过在词法分析逻辑中查询和调用状态转换表, 明显地优化性能.&lt;/p&gt;

&lt;p&gt;需要注意的是, 能够被利用的状态转换表必须是 &lt;strong&gt;确定性&lt;/strong&gt; 的, 也就是在任何状态下, 给定任何输入, 其状态转换效果必须唯一. 我们下面对不同类型的状态转换图, 转换表和状态机进行讨论.&lt;/p&gt;

&lt;h3 id=&quot;nfa-dfa-和转换与简化&quot;&gt;NFA, DFA 和转换与简化&lt;/h3&gt;

&lt;p&gt;在介绍各种状态机前, 我们首先明确它们在构建词法分析器的步骤中起到的作用:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223851.png&quot; alt=&quot;20220429223851&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们首先使用正则表达式编码程序设计语言的语法规则, 并通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thompson's Construction&lt;/code&gt; 先将其转换为非确定性有穷状态机, 再使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 将其转换为未经精简的确定性有穷状态机, 最后使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hopecroft's Algorithm&lt;/code&gt; 将其精简的方式得到可供特定的词法分析器生成工具作为输入的, 精简的确定性有穷状态机.&lt;/p&gt;

&lt;p&gt;首先回顾确定性有穷状态机 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt;) 和非确定性有穷状态机 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt;) 的定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223741.png&quot; alt=&quot;20220429223741&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;正则表达式到-nfa-的转换&quot;&gt;正则表达式到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 的转换&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thompson‘s Construction&lt;/code&gt; 的构造规则如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224213.png&quot; alt=&quot;20220429224213&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以使用这些表示正则表达式基本元素的中间件构造复杂的非确定性有穷状态机, 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224253.png&quot; alt=&quot;20220429224253&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;nfa-到-dfa-的转换&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的转换&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 的核心逻辑由两个操作组成:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move(s_i, a)&lt;/code&gt;: 找出从状态 $s_i$ 开始, 通过输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 所可以转换到的全部新状态.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure(s_i)&lt;/code&gt;: 所有从状态 $s_i$ 开始, 通过空输入 $\epsilon$ 所可以 &lt;strong&gt;直接或间接&lt;/strong&gt; 转换到的状态.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用于将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 转换到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 的基本逻辑是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 的 &lt;strong&gt;初始状态节点&lt;/strong&gt; 开始查找其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;对找到的所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt;, 结合它们所可以接收到的所有类型的新输入 应用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;对新生成的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt; 再循环反复应用上述规则, 直到再也无法生成新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt; 为止.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此时, 所生成的所有不同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt; 就代表我们得到的, 等价的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的所有节点. 依据转换规则将这些新节点编号, 连接, 就得到了和原来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 所等价的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224921.png&quot; alt=&quot;20220429224921&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中, 我们从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 的初始状态节点 $0$ 开始应用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt;, 一步步扩展最终得到了五个不同的闭包. 上述 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 即被相应地转换为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225030.png&quot; alt=&quot;20220429225030&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 得到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 存在大量冗余节点. 下面使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hopecroft's Algorithm&lt;/code&gt; 将其简化.&lt;/p&gt;

&lt;h4 id=&quot;dfa-的精简&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的精简&lt;/h4&gt;

&lt;p&gt;在对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 进行精简时, 我们将合并全部状态转换规则相同的节点, 检查冗余节点的方式为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hopecroft's Algorithm&lt;/code&gt; 的基本思想:&lt;/p&gt;

&lt;p&gt;首先将输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的全部节点分为两个部分: 终止节点, 和非终止节点.&lt;/p&gt;

&lt;p&gt;其次, 根据不同输入分别判断: 非终止节点中是否有某个或某些节点在输入某些符号时状态转换的规则和其他的不一致. 如果对于任何一种输入出现了这种情况有的话, 将其聚类并拆分.&lt;/p&gt;

&lt;p&gt;对拆分后的节点集继续进行相同的检测, 直到无法再拆为止. 此时我们得到的一系列拆分后的节点集合就表明了原 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 中哪些节点是互相等价, 可以合并的. 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225556.png&quot; alt=&quot;20220429225556&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225756.png&quot; alt=&quot;20220429225756&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;构造高效的词法分析器&quot;&gt;构造高效的词法分析器&lt;/h4&gt;

&lt;p&gt;在上面一小节中我们已经解释了如何从正则表达式通过数种中间形态转换到精简的确定性有穷状态机的过程. 而在将确定性有穷状态机转换成完全等价的状态转换表后, 它就可以被词法分析器调用以相对高效地完成词法分析任务.&lt;/p&gt;

&lt;p&gt;然而调用状态转换表仍然相对低效, 且会产生可观的内存开销. 因此, 契合实际的解决方案是: 将状态转换表编码的转换规则使用工具直接 &lt;strong&gt;自动化地集成&lt;/strong&gt; 到词法分析器中.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429230219.png&quot; alt=&quot;20220429230219&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在业界中, 常用的转换工具为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flex&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429230310.png&quot; alt=&quot;20220429230310&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它可以直接接受正则表达式为输入.&lt;/p&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;

&lt;p&gt;词法分析器将由一系列符号组成的源码经过分析和转换, 变为一系列词素. 这一过程是完全自动化的, 遵循 “正则表达式 - 非确定性有穷状态机 - 确定性有穷状态机” 的流程. 由于正则表达式具有表达多种复杂模式的强大功能, 它常被用于自动化词法分析的流程.&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析-1&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224133.png&quot; alt=&quot;20220503224133&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-语法分析-syntax-analysis&quot;&gt;3. 语法分析 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Syntax Analysis&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;在上面一节中, 我们已经介绍了词法分析的作用, 原理, 操作方法, 涉及的主要定理/算法与其他细节. 下面我们讨论完成词法分析后的下一步骤: 用于 &lt;strong&gt;生成构造出词法分析给出的一系列词素的流程&lt;/strong&gt; 的 &lt;strong&gt;语法分析&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430152802.png&quot; alt=&quot;20220430152802&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们首先明确语法分析的对象. 乔姆斯基的语法层级将语言大致按照逻辑严密性区分为了四个类别:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430152930.png&quot; alt=&quot;20220430152930&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中人类日常交流使用的自然语言语法位于最高 (也是逻辑性最差) 的一级, 正则语法的逻辑性最强, 而语法分析所需要处理的语言则为位于倒数第二级的 &lt;strong&gt;上下文无关语法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;这是由于正则语言存在两点无法避免的局限性:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430153315.png&quot; alt=&quot;20220430153315&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正则语言无法表示存在对称性和需要计数的字符串语言, 也无法直接应用未经完备定义的非终止符号.&lt;/p&gt;

&lt;p&gt;语法分析的目的是基于给定的语法, 分析出给定语素序列的 &lt;strong&gt;推导过程&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derivation&lt;/code&gt;), 以及推导过程对应的 &lt;strong&gt;分析树&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse Tree&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;在分析推导过程时, 在每一步分析时都需要选择某个非终止符号并用合适的语法生成规则取代它, 而在每一步中选择不同的符号都会导致最后得出不同的生成规则.&lt;/p&gt;

&lt;p&gt;在编译器构造问题中, 我们主要关注的推导过程类型分为两种, 左起推导和右起推导:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430154501.png&quot; alt=&quot;20220430154501&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而分析树则是对推导过程的可视化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430154731.png&quot; alt=&quot;20220430154731&quot; /&gt;&lt;/p&gt;

&lt;p&gt;语法分析需要避免歧义性, 否则分析过程中会涉及相当数量的错误选择和回溯. 回顾定义, 我们知道, &lt;strong&gt;歧义性语言&lt;/strong&gt; 就是那些可以使用不止一种方式生成某些文字, 也就是分析过程会生成不止一种生成树的语言.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430155122.png&quot; alt=&quot;20220430155122&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了避免歧义性, 我们需要确保被分析语言的语法是不具歧义的. 解决这一问题的方法是 &lt;strong&gt;重写语法规则&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;下面先介绍两种常用的语法分析方法: &lt;strong&gt;自顶向下分析&lt;/strong&gt; 和 &lt;strong&gt;自底向上分析&lt;/strong&gt;, 并分别再讨论不同语法分析方法中解除歧义性的方法.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430155502.png&quot; alt=&quot;20220430155502&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意, 编译器常使用自底向上分析法.&lt;/p&gt;

&lt;h3 id=&quot;自顶向下分析&quot;&gt;自顶向下分析&lt;/h3&gt;

&lt;p&gt;自顶向下分析从 &lt;strong&gt;语法规定的起始符号&lt;/strong&gt; 开始, 从根开始 &lt;strong&gt;自顶向下&lt;/strong&gt; 分析语素序列, 构造对应的语法树, 直到我们构造的推导规则完整匹配了给定的序列为止:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160037.png&quot; alt=&quot;20220430160037&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而有效执行自顶向下分析的前提是在每一步分析时都选择语法中正确 (合适) 的生成规则, 否则分析器就需要回溯, 造成时间和资源的浪费. 举例而言, 基于下图所示的语法处理给定的字符串, 就有可能得到两种完全不同的生成规则:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160248.png&quot; alt=&quot;20220430160248&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而由于自顶向下分析的特征, 我们需要确保对应的语法 &lt;strong&gt;不为左递归 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;left-Recursive&lt;/code&gt;)&lt;/strong&gt; 的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160449.png&quot; alt=&quot;20220430160449&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而通过重写消除左递归, 我们就可以确保新的语法具有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LL(1)&lt;/code&gt; 性质:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160755.png&quot; alt=&quot;20220430160755&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在将语法生成规则重写确保它不为左递归的之后, 我们就可以开始考虑在语法分析时如何进行生成规则的选择. 得益于重写语法, 我们只需要在选择时从被分析的字符开始 &lt;strong&gt;向前看一位&lt;/strong&gt;, 就可以从重写后的规则中找到合适的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160822.png&quot; alt=&quot;20220430160822&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;自底向上分析&quot;&gt;自底向上分析&lt;/h3&gt;

&lt;p&gt;与自顶向下分析不同, 自底向上分析生成语法树的方式是 &lt;strong&gt;从最底下的叶子节点开始反推&lt;/strong&gt;, 直到反向推出根节点 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goal&lt;/code&gt;, 这也就是从给定的输入字符串开始, 反推到起始符号的过程.&lt;/p&gt;

&lt;p&gt;回顾语法分析的目的是构造出一个生成序列, 使得从起始符号 $S$ 开始能够一步步构造出作为输入的被分析字符串 $\text{sentence}$:&lt;/p&gt;

\[S \rightarrow \delta_0 \rightarrow \delta_1 \rightarrow \cdots \rightarrow \cdots \rightarrow \delta_{n-1} \rightarrow \text{sentense}.\]

&lt;p&gt;要从后往前地, 基于中间字符串 $\delta_{i}$ 反向推导出 $\delta_{i-1}$, 我们需要选择 $\delta_{i}$ 中的某个字符 $x$, 利用语法中现存的分析规则&lt;/p&gt;

\[A\rightarrow x\]

&lt;p&gt;将 $x$ 替换为 $A$ 从而得到 $\delta_{i-1}$. 这一步骤也被称为 &lt;strong&gt;还原 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduction&lt;/code&gt;)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此, 自底向上分析中最为重要的步骤就是在每一步中进行 &lt;strong&gt;合适的还原&lt;/strong&gt;. 而寻找还原的实质是, 找到:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个匹配生成语法中某条规则右侧结果&lt;/strong&gt;, 而且在需要被处理的字符串中 &lt;strong&gt;出现&lt;/strong&gt; 的子串. 我们称这样的子串为一个 &lt;strong&gt;还原柄&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430171124.png&quot; alt=&quot;20220430171124&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;显然对于没有歧义的语法规则而言, 任何一条规则的右侧结果都 &lt;strong&gt;唯一对应&lt;/strong&gt; 一个还原柄.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在还原柄的形式化表示中, $k$ 代表的是 &lt;strong&gt;子串的最右侧元素在字符串中所处的位置&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430184943.png&quot; alt=&quot;20220430184943&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;举例而言, 在上图中, 尝试匹配 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a A bcde&lt;/code&gt; 时, 对应的子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abc&lt;/code&gt; 在字符串中的 $k$ 就应该是 $4$.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在通过还原得到了这些还原柄后, 我们就可以相应地构建对字符串的推导过程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430171411.png&quot; alt=&quot;20220430171411&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面看一个例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430191708.png&quot; alt=&quot;20220430191708&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中, 我们手动地执行了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt; 入栈和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; 替换的操作, 最终得到了一个反向从字符串倒推回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goal&lt;/code&gt; 的构造序列.&lt;/p&gt;

&lt;p&gt;抽象地, 寻找还原柄和生成推导过程的逻辑可被表示为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce Parser&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430171522.png&quot; alt=&quot;20220430171522&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而自底向上分析仍然存在两个问题需要解决. 仅从上面处理 $x-2y$ 的例子就可看出, 在黄色行处, 需要作出正确的选择: 不直接从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Expr&lt;/code&gt; 反向匹配到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goal&lt;/code&gt;, 而是继续 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt; 入栈才能得到正确的结果.&lt;/p&gt;

&lt;p&gt;这意味着在一些情况下存在这样的问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;语法分析器无法决定是执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt; 还是执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;语法分析器无法决定执行哪个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt; 规则&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前者可以通过修改语法或人为规定优先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt; 解决冲突, 而后者就很难通过简单的操作缓解.&lt;/p&gt;

&lt;p&gt;因此, 为了高效执行 &lt;strong&gt;自底向上分析&lt;/strong&gt;, 需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle-Finding Mechanism&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce Parsing&lt;/code&gt; 确定化和自动化, 需要我们确保给定的上下文无关语法具备 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 性质:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430192609.png&quot; alt=&quot;20220430192609&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意此处在确保上下文无关语法是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 的之后, 决定执行哪个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt; 规则时也只需要和自顶向下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LL(1)&lt;/code&gt; 一样向前多看一位即可.&lt;/p&gt;

&lt;p&gt;基于具备 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 性质的上下文无关语法下的, 自底向上的语法分析称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR Parsing&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;它除了和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce Parser&lt;/code&gt; 一样需要逐个从左向右, 自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input Buffer&lt;/code&gt; 读入语素 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;) 外, 还需要在入栈的每个符号后加入表示状态的额外信息.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430193235.png&quot; alt=&quot;20220430193235&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它需要使用两个额外的信息表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430193128.png&quot; alt=&quot;20220430193128&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GOTO&lt;/code&gt; 信息表包含了满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 条件的, 上下文无关语法的语法规则, 并且可以决定在什么情况下执行什么样的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce&lt;/code&gt; 操作. 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION&lt;/code&gt; 表的列数恰为终止符号的数量, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GOTO&lt;/code&gt; 表的列数为非终止符号的数量, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION-GOTO&lt;/code&gt; 联表的列数为二者列数之和 + 1, 因为还需要额外一列存储状态信息.&lt;/p&gt;

&lt;p&gt;自此, 我们可以利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR-Parsing&lt;/code&gt; 自动化地执行语法分析.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430193429.png&quot; alt=&quot;20220430193429&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面使用自测题中较为复杂的一道 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 查表题介绍如何解决这一类的题目:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430195453.png&quot; alt=&quot;20220430195453&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给定字符串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(())()&lt;/code&gt;, 转换语法和对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION-GOTO&lt;/code&gt; 联表, 要求 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1) Parser&lt;/code&gt; 基于给定信息生成的字符串构造顺序.&lt;/p&gt;

&lt;p&gt;求解这类题目时首先在草稿上画出三列联表: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack, Input, Action&lt;/code&gt;, 初始状态下栈内只有一个表示栈头的元素 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;, 以及初始状态 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input&lt;/code&gt; 行恰为给定字符串, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Action&lt;/code&gt; 栏为空.&lt;/p&gt;

&lt;p&gt;然后将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input&lt;/code&gt; 中字符串的 &lt;strong&gt;左边第一个元素&lt;/strong&gt; 视为状态 $0$ 时的输入, 对应查表得到, 在状态 $0$ 下输入为 $($ 时需要执行的操作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S3&lt;/code&gt;, 也就是: &lt;strong&gt;先 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;, 然后通过给推入栈的新元素右侧补上 $3$ 的方式表明状态转换到了 $3$&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;随后对应更新三列联表, 开始考虑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;())()&lt;/code&gt;. 由于此时处于状态 $3$, 输入为 $($, 查表可知需执行 $S6$, 也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt; + 通过在入栈的新元素右侧记录$6$ 表示转换状态到 $6$.&lt;/p&gt;

&lt;p&gt;然后考虑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;))()&lt;/code&gt;. 查表知状态 $6$ 下输入为 $)$, 需执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S10&lt;/code&gt;: 入栈, 记录新元素对应状态为 $10$, 状态转移到 $10$.&lt;/p&gt;

&lt;p&gt;随后考虑状态 $10$ 下输入 $)()$: 对应查表知需执行操作 $R5$ (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Replacement Rule 5&lt;/code&gt;): 也就是执行替换规则 $5$. 注意在该类情况下的状态转换问题:&lt;/p&gt;

&lt;p&gt;根据提示检查替换规则 $5$, 知需要反向将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt; 替换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;. 此时将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(6)10&lt;/code&gt;连同字符 (括号) 后对应的状态标记 $6$ 和 $10$ 一起替换. 替换后此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; 中只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$0(3&lt;/code&gt;, 意味着状态转换到了 $3$.&lt;/p&gt;

&lt;p&gt;再查表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GOTO&lt;/code&gt;, 知状态 $3$ 下输入为 $P$, 状态需要对应转换到 $5$, 因此 $P$ 的状态标记就是 $5$, 此时栈内元素更新为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$0(3P5&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;以此类推可得:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430201412.png&quot; alt=&quot;20220430201412&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意推导过程必须直到查表对应 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Action&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accept&lt;/code&gt; 方能结束.&lt;/p&gt;

&lt;p&gt;最后我们总结如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430201517.png&quot; alt=&quot;20220430201517&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析-2&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224209.png&quot; alt=&quot;20220503224209&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224222.png&quot; alt=&quot;20220503224222&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224240.png&quot; alt=&quot;20220503224240&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-编译器中端-middle-end&quot;&gt;4. 编译器中端 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Middle-End&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;在上面一节中我们已知, 通过词法分析和语法分析, 编译器可以确定输入的源码是指定程序设计语言的一段合法的代码, 也就是说如果将输入的源码视为一段字符串, 则可知:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输入源码中语素的顺序满足语法规定, 是指定语言的合法句子.&lt;/li&gt;
  &lt;li&gt;并且通过语法分析, 可以得到基于语言的语法规则生成这个句子的流程.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般地, 语法分析的产物都是一棵 &lt;strong&gt;分析树&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse Tree&lt;/code&gt;), 以图形化的方式表示了如何从给定语言的起始符号开始使用不同生成规则构造出作为输入的句子 (字符串/源码) 的过程.&lt;/p&gt;

&lt;p&gt;因此, 分析树可以作为编译器生成 &lt;strong&gt;和源代码完全等价, 但相对更为高效&lt;/strong&gt; 的 &lt;strong&gt;中间表示&lt;/strong&gt; 的基础. 需要注意的是, 在完成语法分析后, 我们并未完全完成对代码中潜在的其他错误, 如变量类型错误, 变量声明和引用错误等 &lt;strong&gt;语法分析器无法检测出&lt;/strong&gt; 的 &lt;strong&gt;非语法错误&lt;/strong&gt;, 因此在生成中间表示之前还需要执行 &lt;strong&gt;非语法错误检查&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;非语法错误检查&quot;&gt;非语法错误检查&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430212422.png&quot; alt=&quot;20220430212422&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中, 虽然给定的程序代码不存在任何语法错误, 但我们可以明确看出变量声明存在错误, 函数调用中变量多于函数声明时指定的数目, 参数化输出中给定参数类型不匹配等 &lt;strong&gt;非语法问题&lt;/strong&gt;. 这些非语法问题常常是 &lt;strong&gt;上下文相关&lt;/strong&gt; 的, 即单独拎出一行来分析语法错误不存在任何问题, 但放在全文中则会将问题暴露. 由于上下文无关语法无法解决和处理这类问题, 我们需要提出针对性的策略.&lt;/p&gt;

&lt;p&gt;我们可以引入 &lt;strong&gt;类型系统&lt;/strong&gt; 检测源代码中变量类型不匹配的问题.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430212825.png&quot; alt=&quot;20220430212825&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相似地, 其他类型的上下文无关语法问题也需要有对应的解决方案. 我们可以通过定义上下文相关语法将检测形式化, 但这极其困难, 且在处理一些特殊情形 (如检查变量是否在使用前声明) 时会导致需要匹配的规则数量过大以至于无法完成检测.&lt;/p&gt;

&lt;p&gt;更为实际的做法是: 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ad hoc techniques&lt;/code&gt;, 结合某个 &lt;strong&gt;符号表&lt;/strong&gt; 进行对应的检测.&lt;/p&gt;

&lt;p&gt;符号表就是存储 &lt;strong&gt;词法分析/语法分析/代码错误检查时所需&lt;/strong&gt; 的 &lt;strong&gt;全体事实&lt;/strong&gt; 的数据结构, 它在词法分析时生成, 并在后续的剩余编译过程中持续被频繁调用. 通过查询和更新符号表, 编译器就可完成诸如 “变量是否都在使用之前提前声明”, 以及 “数值运算和逻辑运算涉及变量的类型是否匹配” 一类的困难问题. 而符号表中可能存储的信息类型同样是非常复杂的, 以至于实际上编译器可能需要同时维护多个符号表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213426.png&quot; alt=&quot;20220430213426&quot; /&gt;&lt;/p&gt;

&lt;p&gt;符号表可以使用线性列表, 二叉树和哈希表实现, 契合实际的实现方式是哈希表.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213520.png&quot; alt=&quot;20220430213520&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而哈希表的相关知识在上学期的数据结构与算法课程中已经详细介绍过, 此处不再赘述.&lt;/p&gt;

&lt;p&gt;此外, 在非语法错误检查中还会涉及诸如哈希表中哈希函数的选择, 变量命名域等复杂问题, 这些问题不属于本课程的介绍重点, 因此不再赘述.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213719.png&quot; alt=&quot;20220430213719&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;中间表示生成&quot;&gt;中间表示生成&lt;/h3&gt;

&lt;p&gt;我们下面讨论实际的中间表示生成步骤. 合适的中间表示应该满足下列的要求:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213828.png&quot; alt=&quot;20220430213828&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中间表示的类型包含:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图形 (结构可视化) 式, 一般形如树, 结构贴近源码但可能具有大量的边和节点, 导致其极其复杂.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性式, 一般为伪代码的形式, 更贴近目标代码.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;混合式, 结合了图形式和线性式的特征.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面分别介绍一种图形式和线性式的代表:&lt;/p&gt;

&lt;h4 id=&quot;抽象语法树-abstract-syntax-tree-ast&quot;&gt;抽象语法树 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abstract Syntax Tree, AST&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;抽象语法树基于分析树 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse Tree&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214258.png&quot; alt=&quot;20220430214258&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;三地址码-three-address-code&quot;&gt;三地址码 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Three-Address Code&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214333.png&quot; alt=&quot;20220430214333&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, 一些辅助信息也会作为中间表示的一部分:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214416.png&quot; alt=&quot;20220430214416&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后介绍一些常用的代码优化方法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214510.png&quot; alt=&quot;20220430214510&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214644.png&quot; alt=&quot;20220430214644&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及另一种优化循环的方法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214752.png&quot; alt=&quot;20220430214752&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Loop Unrolling&lt;/code&gt; 的目的是减少执行循环体的次数, 从而降低在执行循环条件判断和循环跳转过程中的各种开销.&lt;/p&gt;

&lt;p&gt;最后总结如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在编译器的中间表示生成步骤中有多种不同的中间表示类型可选, 本课程简要介绍了抽象语法树和三地址码两种.&lt;/li&gt;
  &lt;li&gt;在这一步中我们同样可见, 除了正确地表示源码的含义外, 检查源码中潜在的非语法错误同样是一件极其困难的任务, 现代编译器一般使用基于哈希表实现的符号表处理这一问题.&lt;/li&gt;
  &lt;li&gt;在本节中我们同样介绍了数种与硬件无关的中间表示代码优化方法, 但为了实现极致的优化, 实际的编译器往往还要在目标代码生成时执行更复杂的, 更底层的优化手段.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;相关题目解析-3&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224329.png&quot; alt=&quot;20220503224329&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224341.png&quot; alt=&quot;20220503224341&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-代码生成&quot;&gt;5. 代码生成&lt;/h2&gt;

&lt;p&gt;代码生成属于编译器后端需要完成的任务, 它接受编译器中端生成的中间表示, 并将其经过转换和优化后, 生成最后的目标代码.&lt;/p&gt;

&lt;p&gt;在这一过程中, 主要会涉及两个问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何使用 &lt;strong&gt;模式识别 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pattern Matching&lt;/code&gt;)&lt;/strong&gt; 选择合适的目标语言指令?&lt;/li&gt;
  &lt;li&gt;如何基于目标硬件平台的特性进行针对性的代码优化?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在本课程中, 我们将只关注下面的三个问题: 指令选择, 寄存器分配和指令调度.&lt;/p&gt;

&lt;h3 id=&quot;指令选择-instruction-selection&quot;&gt;指令选择 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction Selection&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;指令选择这一步中的主要任务是基于 &lt;strong&gt;模式识别&lt;/strong&gt; 将中间表示和目标代码相匹配. 在这一步中, 我们不进行任何优化, 且假设寄存器的数量完全足够.&lt;/p&gt;

&lt;p&gt;我们将在下面的讨论中使用如下图所示的, 形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC&lt;/code&gt; 汇编语言的伪机器语言:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501092510.png&quot; alt=&quot;20220501092510&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;数值运算表达式-arithmetic-expressions-的代码生成&quot;&gt;数值运算表达式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Arithmetic Expressions&lt;/code&gt;) 的代码生成&lt;/h4&gt;

&lt;p&gt;在生成数值运算表达式的代码时, 编译器采取的遍历策略是 &lt;strong&gt;类似遍历树一样的后序遍历&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501092726.png&quot; alt=&quot;20220501092726&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而针对相关的问题, 也有对应的处理策略:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501092808.png&quot; alt=&quot;20220501092808&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;优先遍历左子树的原因是我们总是需要优先考虑对寄存器有更高利用需求的子树.&lt;/li&gt;
  &lt;li&gt;将常规乘法转换为多个 &lt;strong&gt;可表为$2$的幂的数和变量相乘&lt;/strong&gt; 的形式后, 就可以使用 &lt;strong&gt;位运算&lt;/strong&gt; 提升计算速度, 降低资源开销.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;数组引用代码生成&quot;&gt;数组引用代码生成&lt;/h4&gt;

&lt;p&gt;程序设计语言定义数组的方式一般分为 &lt;strong&gt;行主导定义 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Row-Major Order&lt;/code&gt;)&lt;/strong&gt; 和 &lt;strong&gt;列主导定义 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Column-Major Order&lt;/code&gt;)&lt;/strong&gt;, 我们目前所学习的绝大多数程序设计语言所使用的都是行主导定义.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093208.png&quot; alt=&quot;20220501093208&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在明确了数组首元素的内存地址和需要引用的数组元素坐标后, 就可以结合数组的定义方式快速地计算出需要被引用元素的内存地址:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093158.png&quot; alt=&quot;20220501093158&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;控制语句代码生成&quot;&gt;控制语句代码生成&lt;/h4&gt;

&lt;p&gt;对于形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if...else...&lt;/code&gt; 的控制语句, 在生成其对应目标代码时, 首先需要生成条件判断部分的代码, 其次分别生成对应条件分支对应的代码.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093318.png&quot; alt=&quot;20220501093318&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while..., loop..., do loop...&lt;/code&gt; 的循环语句, 需要在循环开始前和循环结束后都生成条件判断语句对应的代码以控制循环.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093427.png&quot; alt=&quot;20220501093427&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时, 也可以通过类似树遍历的方式处理复杂的布尔表达式. 注意在此处可以利用短路特性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Short-Circuit Evaluation&lt;/code&gt;) 简化表达式.&lt;/p&gt;

&lt;h4 id=&quot;程序函数方法代码生成&quot;&gt;程序/函数/方法代码生成&lt;/h4&gt;

&lt;p&gt;程序, 方法和函数的引入便于人类理解和编写复杂程序, 但它们对于编译器和计算机而言非但是完全不必要的, 反而会在编译过程中带来一定的困难. 由于计算机执行代码的过程实际上是顺序流式的, 因此编译器需要在编译过程中 “模拟” 出函数/方法, 如通过分支跳转等方式调用函数, 为不同的函数和方法划分单独的寄存器空间存储函数变量等.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093951.png&quot; alt=&quot;20220501093951&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对函数/方法的模拟的代价是较大的资源开销. 因此, 包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 在内的一些语言在编译时会尽可能地通过直接将对应的函数代码段插入过程流的方式减少在实际目标代码中涉及的, 所需要模拟的方法数量.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501094002.png&quot; alt=&quot;20220501094002&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;寄存器分配-register-allocation&quot;&gt;寄存器分配 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Register Allocation&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;在指令选择这一步中, 我们假设可供使用的寄存器数量是无限的, 这显然不符合事实. 因此, 代码生成的下一步就是通过执行寄存器分配优化目标代码中寄存器的使用数量, 使其满足实际物理机上寄存器数量的限制.&lt;/p&gt;

&lt;p&gt;下面首先给出一些定义:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt;: 最长的, 不含任何分支跳转 (限于控制流语句和循环语句) 的代码段.&lt;/li&gt;
  &lt;li&gt;局部寄存器分配: 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中执行的寄存器分配.&lt;/li&gt;
  &lt;li&gt;全局寄存器分配: 在程序全体中执行的寄存器分配.&lt;/li&gt;
  &lt;li&gt;寄存器分配: 决定将什么变量/数据存储到寄存器中的过程.&lt;/li&gt;
  &lt;li&gt;寄存器赋值: 选择特定寄存器存储数据的过程.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现代处理器包含多种, 大量寄存器, 因此寄存器分配问题是非常复杂的. 本小节只对寄存器分配的原理和规则进行极为简单的介绍.&lt;/p&gt;

&lt;h4 id=&quot;变量的生命概念和生命周期&quot;&gt;变量的生命概念和生命周期&lt;/h4&gt;

&lt;p&gt;引入这一概念的主要目的是解决 “在某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中最多需要多少个寄存器” 的问题, 通过引入生命周期, 我们就可以计算出 “同时有多少个变量正在被程序使用” 以及 “特定的变量何时不再被使用, 可被清除” 的问题.&lt;/p&gt;

&lt;p&gt;我们称变量的生命周期介于 &lt;strong&gt;变量被声明&lt;/strong&gt; 以及 &lt;strong&gt;变量最后一次被调用/使用&lt;/strong&gt; 之间, 可以表示为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中的一个分段 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interval&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;如果某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中的任何时间段里, 活跃的变量数超过了物理寄存器上限, 就需要基于一定的规则踢掉 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spill&lt;/code&gt;) 某些变量, 为其他变量创造空间.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501102404.png&quot; alt=&quot;20220501102404&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501102632.png&quot; alt=&quot;20220501102632&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过估计踢掉特定变量的 &lt;strong&gt;成本&lt;/strong&gt; 决定在寄存器不足时需要踢掉哪个变量:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103904.png&quot; alt=&quot;20220501103904&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;寄存器分配原则&quot;&gt;寄存器分配原则&lt;/h4&gt;

&lt;p&gt;我们着重关注局部寄存器分配问题. 局部寄存器分配问题的解决方案分为 &lt;strong&gt;自顶向下寄存器分配&lt;/strong&gt; 和 &lt;strong&gt;自底向上寄存器分配&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;自顶向下寄存器分配原则为使用最频繁的值优先保留寄存器空间, 但这可能导致在上一段代码中频繁使用, 而在下一段代码中几乎不使用的变量挤占了下一段代码的寄存器空间, 因此不切实际.&lt;/p&gt;

&lt;p&gt;自底向上寄存器分配原则使用 “寄存器池” 的概念: 任何变量开始生命周期时都从池子里拿走一个寄存器, 而在生命周期结束时返还寄存器到池子里, 若池子里没有足够的寄存器, 就需要让 &lt;strong&gt;在最远的未来才会被调用的寄存器&lt;/strong&gt; 释放值, 这也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Best's Algorithm&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;使用图染色方法解决寄存器分配问题&quot;&gt;使用图染色方法解决寄存器分配问题&lt;/h4&gt;

&lt;p&gt;我们还可以使用图染色方法解决寄存器分配问题.&lt;/p&gt;

&lt;p&gt;其基本逻辑是: 生命周期不互相干涉 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interference&lt;/code&gt;) 的变量可以共享同一个寄存器.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103206.png&quot; alt=&quot;20220501103206&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图染色问题的定义在此不作说明. 下面给出 &lt;strong&gt;干涉&lt;/strong&gt; 的定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103248.png&quot; alt=&quot;20220501103248&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意如果在某时刻, 上一个变量的生命周期恰好结束而下一个变量的生命周期刚刚开始, 则我们 &lt;strong&gt;不认为&lt;/strong&gt; 这两个变量之间发生了干涉.&lt;/p&gt;

&lt;p&gt;而我们一般使用 &lt;strong&gt;自顶向下染色&lt;/strong&gt; 的方式构造 $k$-染色: 先排序, 然后从高到低依次为节点染色.&lt;/p&gt;

&lt;p&gt;回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lab3&lt;/code&gt;, 我们使用的排序策略是基于编号和邻居数量的复合策略.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103439.png&quot; alt=&quot;20220501103439&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, 自底向上染色的方式也很常见.&lt;/p&gt;

&lt;h4 id=&quot;使用控制流图检测全局生命周期&quot;&gt;使用控制流图检测全局生命周期&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103626.png&quot; alt=&quot;20220501103626&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;指令调度-instruction-scheduling&quot;&gt;指令调度 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction Scheduling&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;我们最后讨论指令调度.&lt;/p&gt;

&lt;p&gt;由于任何指令从执行到返回结果都不可避免地需要耗费一定的时间, 因此通过合理的安排指令调度, 我们就可以优化指令执行所需要的时间, 这也是指令调度的主要目的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501104303.png&quot; alt=&quot;20220501104303&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在执行指令调度时, 编译器已经预先知道不同类型的指令对应的延迟数据.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501105857.png&quot; alt=&quot;20220501105857&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而由于现代计算机可以在同一个周期中执行多条指令, 且指令的结果必须在延迟后才能返回, 因此可以利用这一特性进行一些以提高寄存器利用率为代价的, 针对性的优化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110114.png&quot; alt=&quot;20220501110114&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举例而言, 在下图所示的例子中, 右侧的优化通过增加了一个对寄存器的引用使得我们可以减少三个周期 (恰为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt; 的延迟长度) 的程序运行时间.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110216.png&quot; alt=&quot;20220501110216&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面介绍对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 的指令调度的优化技术:&lt;/p&gt;

&lt;p&gt;其基本思想是构造 &lt;strong&gt;优先图&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Precedence Graph&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data Dependence Graph&lt;/code&gt;), 为图中的每个节点使用某个 &lt;strong&gt;优先函数 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Priority Funtion&lt;/code&gt;)&lt;/strong&gt; 计算优先权重, 然后使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List Scheduling&lt;/code&gt; 的手段构造指令调度.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110421.png&quot; alt=&quot;20220501110421&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意优先图考虑的是 &lt;strong&gt;每一条指令之间的依赖关系&lt;/strong&gt;, 而非 &lt;strong&gt;寄存器数据之间的依赖关系&lt;/strong&gt;. 如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110626.png&quot; alt=&quot;20220501110626&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在得到优先图后, 就需要对图中的每个节点进行优先权重的计算:&lt;/p&gt;

&lt;p&gt;在下面的例子中, 我们假定每个节点的权重都等于该节点代表指令本身的延迟 + 其所有子节点中最大权重的值. 因此, 优先图的构建是自底向上的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110752.png&quot; alt=&quot;20220501110752&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随后我们就可以开始构建指令调度顺序. 首先考虑优先图中没有任何依赖的全体节点, 最先执行权重最大的, 在本例中为 $6$.&lt;/p&gt;

&lt;p&gt;随后, 将上一轮中被考虑的那些剩余节点以及 &lt;strong&gt;执行了 $6$ 之后满足依赖条件可以被执行的新节点&lt;/strong&gt; 放在一起按照权重排序, 仍然选择权重最高的优先执行 (在本例中, 因为 $7$ 需要同时满足 $2$ 和 $6$, 因此只执行了 $6$ 之后也不能执行任何新节点, 所以选择 $1$).&lt;/p&gt;

&lt;p&gt;依次判断推导, 可知第三步中需要考虑的节点为 $2, 4, 3$, 而在此之中 $2$ 权重最高.&lt;/p&gt;

&lt;p&gt;最后可得下图所示的调度顺序:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501111147.png&quot; alt=&quot;20220501111147&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List Scheduling&lt;/code&gt; 还可以结合多种优化手段. 此处不再详细介绍:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501111248.png&quot; alt=&quot;20220501111248&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后我们可以将编译器的完整结构总结如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501111349.png&quot; alt=&quot;20220501111349&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析-4&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224419.png&quot; alt=&quot;20220503224419&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224430.png&quot; alt=&quot;20220503224430&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 64x+16x-x)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224503.png&quot; alt=&quot;20220503224503&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 函数调用不视为branching)&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/14/Ch3-COMP26020/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/14/Ch3-COMP26020/</guid>
        
        <category>课程笔记</category>
        
        <category>编译理论</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： 单纯形法</title>
        <description>&lt;h1 id=&quot;单纯形法&quot;&gt;单纯形法&lt;/h1&gt;

&lt;p&gt;本章介绍 &lt;strong&gt;单纯形法&lt;/strong&gt;. 我们首先通过介绍线性规划问题的图像化表示引入单纯形法的基本思路, 并通过几个例子说明如何使用它.&lt;/p&gt;

&lt;h2 id=&quot;线性规划问题的图像化表示&quot;&gt;线性规划问题的图像化表示&lt;/h2&gt;

&lt;p&gt;我们下面回顾 &lt;strong&gt;线性规划问题的图像化表示&lt;/strong&gt;. 考虑下列问题:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220321072245.png&quot; alt=&quot;20220321072245&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将约束式的边界条件视为一次函数并将其在平面直角坐标系上绘制出来, 不难看出各约束条件所限制的, 平面可取区域的重叠处:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220321072528.png&quot; alt=&quot;20220321072528&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此问题中的可取区域为 $x_1$ 的正方向, $x_2$ 轴和所有一次函数所围成的区域.&lt;/p&gt;

&lt;p&gt;显然, 可取区域包含了原点: $(0, 0)$. 我们将介绍适用于这种情形下的线性规划问题最优解计算方法, 而对 &lt;strong&gt;可取区域不包含原点&lt;/strong&gt; 的线性规划问题的求解问题则在下一周内容中讨论.&lt;/p&gt;

&lt;h2 id=&quot;单纯形法-1&quot;&gt;单纯形法&lt;/h2&gt;

&lt;p&gt;单纯形法的基本原理是: 形如 &lt;strong&gt;凸超多边形&lt;/strong&gt; 的可行域的 &lt;strong&gt;顶点之一&lt;/strong&gt; 必为最优解. 因此:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为了确保可行域形为凸超多边形, 单纯形法要求被求解的线性规划问题在矩阵表示形式下满足&lt;/p&gt;

\[\mathbf{b} \geqslant 0\]

    &lt;p&gt;也就是说线性规划问题在被转换为标准形式前, 其表示中不会出现 $=$ 或 $\leqslant$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基于第一点的约束, 不难看出在满足上述条件的问题下 $0$ (零向量, 对应平面的原点) 必为该类问题的一个解.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面简单解释形如 &lt;strong&gt;凸 (超) 多边形&lt;/strong&gt; 的 (超) 平面区域中的最优解必在顶点的原因:&lt;/p&gt;

&lt;p&gt;不妨考虑一个目标函数为 $c^{T}x$ 的最小化问题, 设其在可行域内部的最优解为 $x_0$.&lt;/p&gt;

&lt;p&gt;由于 &lt;strong&gt;凸多边形内部任何一点均可表示为顶点的线性组合&lt;/strong&gt;, 因此对顶点 $x_k, ~ k\in [n]$, 有:&lt;/p&gt;

\[x_0 = \sum_{k=1}^{n} \lambda_k \cdot x_k\]

&lt;p&gt;其中&lt;/p&gt;

\[\sum_{k=1}^{n} \lambda_k = 1.\]

&lt;p&gt;假设, $x_i$ 是所有顶点中 &lt;strong&gt;使得 $c^Tx$ 最小的顶点&lt;/strong&gt;, 故有&lt;/p&gt;

\[\begin{aligned}c^Tx_0 &amp;amp;= \sum_{k=1}^{n} \lambda_k c^T x_k \\ &amp;amp;\geqslant \sum_{k=1}^{n} \lambda_k c^T x_i \\ &amp;amp;= c^Tx_i\end{aligned}\]

&lt;p&gt;因此必有一个顶点, 其目标函数值不差于内部点.&lt;/p&gt;

&lt;p&gt;heurisic: pick the var with largest negative coefficient as the entry var (it drags our result down the most!)&lt;/p&gt;

&lt;p&gt;pick the one with the smallest slack as the exiting var.&lt;/p&gt;

&lt;h2 id=&quot;线性规划的松弛形式&quot;&gt;线性规划的松弛形式&lt;/h2&gt;

&lt;p&gt;本节介绍 &lt;strong&gt;线性规划的松弛形式&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在上一章中, 我们已经了解了线性规划的标准形式和矩阵形式.&lt;/p&gt;

&lt;h2 id=&quot;顶点转换&quot;&gt;顶点转换&lt;/h2&gt;
</description>
        <pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/12/Ch6-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/12/Ch6-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： 线性规划</title>
        <description>&lt;h1 id=&quot;线性规划&quot;&gt;线性规划&lt;/h1&gt;

&lt;p&gt;本章将引入线性规划问题的一般概念并讨论表示它们的不同方式.&lt;/p&gt;

&lt;h2 id=&quot;1-线性规划问题的定义和表示&quot;&gt;1. 线性规划问题的定义和表示&lt;/h2&gt;

&lt;p&gt;我们称 &lt;strong&gt;线性规划问题&lt;/strong&gt; 为: 在给定一系列 &lt;strong&gt;约束条件&lt;/strong&gt; 的前提下, 要求 &lt;strong&gt;最小化或最大化某个评价参数&lt;/strong&gt; 的 &lt;strong&gt;优化问题&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;一般地, 一个标准的线性规划问题由下列的元素组成:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;具线性表达形式的问题需求&lt;/p&gt;

\[a_1x_1 + \cdots + a_nx_n\]
  &lt;/li&gt;
  &lt;li&gt;由不等号 (如 $\leqslant$, $\geqslant$) 表示的 &lt;strong&gt;约束关系&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;均大于等于 $0$ 的变量&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;考虑下面的这个简单例子:&lt;/p&gt;

&lt;p&gt;假设某个农民有数量为 $F$ 和 $P$ 的肥料与农药, 可供耕种的土地容量为 $A$, 规划种植小麦 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wheat&lt;/code&gt;) 和大麦 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Barley&lt;/code&gt;) 的量设为 $x_W$ 和 $x_B$, 这两种农作物的单价为 $S_B, S_W$. 而单位小麦和大麦所需要的肥料量与农药量分别为 $F_W, F_B$ 和 $P_W, P_B$. 问: 如何规划种植小麦和大麦的数量使得获利最多?&lt;/p&gt;

&lt;p&gt;将上述的问题解释为线性规划问题, 则有如下的表示方法:&lt;/p&gt;

&lt;p&gt;首先我们需要优化的对象是总获利:&lt;/p&gt;

\[S_B\cdot x_B + S_W \cdot x_W\]

&lt;p&gt;其次, 我们有下列的三个约束:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
\[x_B+ x_W \leqslant A\]
  &lt;/li&gt;
  &lt;li&gt;
\[F_B \cdot x_B + F_W \cdot x_W \leqslant F\]
  &lt;/li&gt;
  &lt;li&gt;
\[P_B \cdot x_B + P_W \cdot x_W \leqslant F\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这三个约束分别表示:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;对这两种作物的规划种植量恰好不超过土地的承载能力.&lt;/li&gt;
  &lt;li&gt;持有的肥料恰好满足这两种作物的需求.&lt;/li&gt;
  &lt;li&gt;持有的农药也恰好满足这两种作物的需求.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-线性规划问题的求解&quot;&gt;2. 线性规划问题的求解&lt;/h2&gt;

&lt;p&gt;我们进一步将上一节中提及的种植规划问题形式化, 将问题中的 &lt;strong&gt;优化目标&lt;/strong&gt; 和 &lt;strong&gt;问题约束&lt;/strong&gt; 形式化为 &lt;strong&gt;目标式&lt;/strong&gt; 和 &lt;strong&gt;约束式&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314104452.png&quot; alt=&quot;20220314104452&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此有:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314104508.png&quot; alt=&quot;20220314104508&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-线性规划问题的矩阵表示法&quot;&gt;3. 线性规划问题的矩阵表示法&lt;/h2&gt;

&lt;p&gt;线性规划问题除了可以表示为上述的标准形式外, 还可以使用矩阵表示法表达.&lt;/p&gt;

&lt;p&gt;考虑下列的线性规划问题:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314104809.png&quot; alt=&quot;20220314104809&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在将该问题从标准形式表示转换为矩阵表示前, 首先将所有公式 (无论是目标式还是约束式) 中变量的顺序调整到完全一致, 如上图中的顺序 $x_1, x_2, x_3$.&lt;/p&gt;

&lt;p&gt;然后, 就可以将变量和常数全部分离为列向量或矩阵, 如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314104956.png&quot; alt=&quot;20220314104956&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时该问题就被转换成了下面的形式:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314105015.png&quot; alt=&quot;20220314105015&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/12/Ch5-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/12/Ch5-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： 最小生成树</title>
        <description>&lt;h1 id=&quot;最小生成树&quot;&gt;最小生成树&lt;/h1&gt;

&lt;p&gt;本章将引入 &lt;strong&gt;最小生成树&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Minimum Spanning Tree&lt;/code&gt;) 和 &lt;strong&gt;图分割&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cut of a graph&lt;/code&gt;) 的概念, 并介绍数种可用于寻找给定图的最小生成树的算法.&lt;/p&gt;

&lt;h2 id=&quot;1-最小生成树的定义与最小生成树问题&quot;&gt;1. 最小生成树的定义与最小生成树问题&lt;/h2&gt;

&lt;p&gt;如果将单源最短路径问题类比为在现存的铁路网中找到一条从出发地到目的地的, 耗时最短或经停站数最少的路线的话, 最小生成树问题就可视为, 给定所有我们希望连通的站点以及建设站点间连线铁路的成本, 要求给出一个建设成本最低但又能确保连通所有站点的建设规划.&lt;/p&gt;

&lt;h3 id=&quot;1-问题定义&quot;&gt;1. 问题定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;定义 1.1&lt;/strong&gt; (最小生成树, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Minimum Spanning Tree&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;对任意给定的有权图 $G = \langle V, E\rangle$, 其 &lt;strong&gt;最小生成树&lt;/strong&gt; $T = \langle V, E’ \rangle$ 为 &lt;strong&gt;总权重最小&lt;/strong&gt; 的, 恰能连通 $G$ 内每个节点的 &lt;strong&gt;树&lt;/strong&gt;.&lt;/p&gt;

  &lt;p&gt;显然可知, 图 $G$ 的最小生成树 $T$ 的顶点集与 $G$ 相同, 而其边集为 $G$ 的子集.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面基于对最小生成树的定义形式化最小生成树问题:&lt;/p&gt;

&lt;p&gt;定义如下记号. 考虑 &lt;strong&gt;连通的无向图&lt;/strong&gt; $G = \langle V, E\rangle$, 其中:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$V$ 为需要连接的所有节点&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$E$ 为所有可选的连通边组成的集合&lt;/p&gt;

\[E = \{(u, v) ~ \vert ~ w(u, v) \neq \infty\}\]
  &lt;/li&gt;
  &lt;li&gt;对任何 $(u, v) \in E$, $w(u, v)$ 为连接 $u, v$ 的成本 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cost&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;随后定义问题: 要求找到边集 $E$ 的一个 &lt;strong&gt;无圈子集&lt;/strong&gt; $T \subseteq E$ 使得 &lt;strong&gt;$V$ 中的所有节点均被连通&lt;/strong&gt;, 且 &lt;strong&gt;涉及的边的权重之和最小&lt;/strong&gt;:&lt;/p&gt;

\[w(T) = \sum_{(u, v) \in T} w(u, v)\]

&lt;p&gt;$T$ 是 &lt;strong&gt;无圈的&lt;/strong&gt;, 且由于它要将所有节点相连, 这意味着 $T$ 是 &lt;strong&gt;树&lt;/strong&gt;, 且 $G$ 为它的 &lt;strong&gt;扩展图&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spanning Graph&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt; 问题就是: 求满足上述条件的 $T$.&lt;/p&gt;

&lt;h3 id=&quot;2-通用贪心算法&quot;&gt;2. 通用贪心算法&lt;/h3&gt;

&lt;p&gt;下面介绍一个可用于求解 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt; 问题的简单算法: &lt;strong&gt;通用贪心算法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Generic Greedy Algorithm&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;通用贪心算法的基本原则是: 逐步构造 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt;, 每一步只取一条局部最优的边. 其伪代码如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312213002.png&quot; alt=&quot;20220312213002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们将在讨论完该算法的正确性后解释何为 “安全的边” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Safe Edge&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;通用贪心算法的循环不变量是: 在任何循环执行前, $A$ 均是某个最小生成树的组成部分.&lt;/p&gt;

&lt;p&gt;在每一步中, 我们基于某些原则选择一条不属于 $A$ 的边 $(u, v)$, 且这条边需要满足下列条件:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$A \cup {(u, w)} \subseteq T$.&lt;/li&gt;
  &lt;li&gt;(u, v) 也是一条安全的边.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们下面说明循环不变量在整个算法执行过程中都保持:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在初始状态下, 第 $0$ 次循环执行前显然 $A$ 满足循环不变量的条件.&lt;/li&gt;
  &lt;li&gt;在执行随后的任何一次循环时, 只有安全的边被加入进 $A$ 中构成新的部分解.&lt;/li&gt;
  &lt;li&gt;在循环终止时, 由于已知在任意一次循环中加入到 $A$ 中的边都属于某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt;, 因此所得到的 $A$ 必然也是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此, 算法的正确性得证. $\blacksquare$&lt;/p&gt;

&lt;p&gt;下面引入 &lt;strong&gt;图分割&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cut&lt;/code&gt;) 的概念:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2&lt;/strong&gt; (图分割)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称对图 $G$ 的顶点集 $V$ 的 &lt;strong&gt;划分&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Partition&lt;/code&gt;) $(S, V-S)$ 为一个对图 $G$ 的 &lt;strong&gt;分割&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cut&lt;/code&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以形象化地将某个对图 $G$ 的分割视为一条横贯图 $G$, 经过 $G$ 的某些边, 将图拆分成两个部分的分割线:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312215053.png&quot; alt=&quot;20220312215053&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们认为某条边 &lt;strong&gt;穿越了分割&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cross the cut&lt;/code&gt;), 若该边的两个节点一个位于 $V-S$ 中, 另一个位于 $S$ 中.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3&lt;/strong&gt; (最轻边, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Light Edge&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称某条边是 &lt;strong&gt;最轻的&lt;/strong&gt;, 若他属于穿越了分割的边中 &lt;strong&gt;权重最小的&lt;/strong&gt;.&lt;/p&gt;

  &lt;p&gt;需要注意, 最轻边可能不是唯一的.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Respect&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称某个分割对边集 $A$ 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Respect&lt;/code&gt; 的, 若分割不穿越 $A$ 中的任何一条边.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后我们定义何为 &lt;strong&gt;安全的边&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.5&lt;/strong&gt; (安全的边, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Safe&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称满足下列条件的边 $(u, v)$ 是 &lt;strong&gt;安全&lt;/strong&gt; 的:&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;考虑无向图 $G = \langle V, E \rangle$, 且 $E = {(u, v) ~ \vert ~ w(u, v) \neq \infty}$.&lt;/li&gt;
    &lt;li&gt;对图 $G$ 边集 $E$ 的子集 $A$, 它包含于某个图 $G$ 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt; 中.&lt;/li&gt;
    &lt;li&gt;存在对图 $G$ 的分划 $(S, V-S)$, 且该分划对边集 $A$ 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Respect&lt;/code&gt; 的.&lt;/li&gt;
    &lt;li&gt;$(u,v)$ 是被分划 $(S, V-S)$ 所穿越的边中的最轻边.&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;则称 $(u, v)$ &lt;strong&gt;对边集 $A$ 而言是安全的&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-kruskal-算法&quot;&gt;2. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法&lt;/h2&gt;

&lt;p&gt;下面介绍另一个可用于寻找最小生成树的算法: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法是基于上文所介绍的通用贪心算法的扩展. 和通用贪心算法不同的是, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法在每一步中都会优先选择 &lt;strong&gt;权重最小&lt;/strong&gt; 的边. 其伪代码如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220313234232.png&quot; alt=&quot;20220313234232&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法中涉及了 &lt;strong&gt;并查集&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Make-Set(x)&lt;/code&gt; 的作用是 &lt;strong&gt;创建一个只包含 $x$&lt;/strong&gt; (自然地, 也就以 $x$ 为代表) 的 &lt;strong&gt;并查集&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220313234557.png&quot; alt=&quot;20220313234557&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;且注意此处的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x.rank&lt;/code&gt; 指 &lt;strong&gt;从 $x$ 所代表的并查集中的任意子节点到 $x$ 的最长路径所包含边数的上界 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Upper bound&lt;/code&gt;)&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Find-Set(x)&lt;/code&gt; 所返回的是指向存有 $x$ 的集合的表示元 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Representative&lt;/code&gt;):&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220313234818.png&quot; alt=&quot;20220313234818&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Union(x, y)&lt;/code&gt; 表示将分别包含 $x$, $y$ 的两个不同的并查集合并, 合并规则为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Union By Rank&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220313234931.png&quot; alt=&quot;20220313234931&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Union By Rank&lt;/code&gt; 规则指: 在合并两个并查集时, 始终将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rank&lt;/code&gt; 更小的那个合并到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rank&lt;/code&gt; 更大的那个中, 且以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rank&lt;/code&gt; 更大的并查集的代表元作为其自身的代表元.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314083304.png&quot; alt=&quot;20220314083304&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后给出该算法时间复杂度的结论: 在 &lt;strong&gt;使用路径压缩 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Compression&lt;/code&gt;)&lt;/strong&gt; 以及使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Union-By-Rank&lt;/code&gt; 规则进行并查集合并的情况下, 其时间复杂度为&lt;/p&gt;

\[O(\vert E\vert \log(\vert V\vert)).\]

&lt;h2 id=&quot;3-prims-算法&quot;&gt;3. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法&lt;/h2&gt;

&lt;p&gt;下面介绍另一个最小生成树算法: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法可视为基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法基础上的扩展. 其基本思路是:&lt;/p&gt;

&lt;p&gt;选定任意节点 $r$ 作为要生成的最小生成树的根节点, 并循环考虑图 $G$ 的边集 $V$ 中的每个节点.&lt;/p&gt;

&lt;p&gt;为图中的每个节点 $u$ 赋予一个 &lt;strong&gt;权重&lt;/strong&gt;: 该权重表示 &lt;strong&gt;从 $u$ 的任意父节点连接到 $u$ 的边的权重中的最小值&lt;/strong&gt;, 初始状态下除了选定的根节点权重设为 $0$ 外, 其余的节点权重都被初始化为 $\infty$.&lt;/p&gt;

&lt;p&gt;随后将 $V$ 放入一个 &lt;strong&gt;基于权重排序的最小优先队列 $Q$&lt;/strong&gt; 中, 并循环检查 $Q$ 中的每个节点, 若该节点此前并不在我们的部分解 $A$ 中 (这是通过检查该点的权重判断的, 如果在部分解中的话其权值必不为 $\infty$ ), 则将该点包含到 $A$ 内, 同时更新其权值.&lt;/p&gt;

&lt;p&gt;在 $Q$ 中再无元素时, 说明图中所有节点全部被划入解中, 且由于对节点的排序基于其权重, 我们可以确保得到的生成树的确是最小的.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法的伪代码如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314085033.png&quot; alt=&quot;20220314085033&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后讨论 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法的时间复杂度, 显然其时间复杂度取决于最小堆的实现方式.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314085116.png&quot; alt=&quot;20220314085116&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/01/Ch4-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/01/Ch4-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>基于 Spring 框架的软件工程实践</title>
        <description>&lt;h1 id=&quot;基于-spring-框架的软件工程实践&quot;&gt;基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 框架的软件工程实践&lt;/h1&gt;

&lt;h2 id=&quot;week1-mvc-架构模式&quot;&gt;Week1: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 架构模式&lt;/h2&gt;

&lt;p&gt;我们称程序的设计结构为 &lt;strong&gt;架构模式&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Architectural Pattern&lt;/code&gt;), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 就属于架构模式的一种.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 意为 “&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Model, View, Controller&lt;/code&gt;”, 即 “模型, 视图和控制”. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 中, 任何程序都在结构上被抽象成三个层级:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;视图层: 程序的操作界面, 直接面向用户, 接受用户的指令并向用户显示信息, 负责人机交互.&lt;/li&gt;
  &lt;li&gt;控制层: 程序的核心逻辑, 连接一, 三两层, 负责基于所接收的用户指令执行实际的数据处理.&lt;/li&gt;
  &lt;li&gt;模型层: 储存程序所需要操作的数据和信息, 定义了程序的数据结构.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述三层在功能上紧密联系, 但在结构上互相独立, 每一层只要对外提供对应的接口以供调用即可实现模块化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220303091603.png&quot; alt=&quot;20220303091603&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;week2-设计用户界面&quot;&gt;Week2: 设计用户界面&lt;/h2&gt;

&lt;p&gt;界面设计实质上是从用户需求向以设计为载体的最终成品的转化. 要着手进行设计, 首先需要理解用户需求.&lt;/p&gt;

&lt;p&gt;对用户需求的理解可以从拆分需求中的 &lt;strong&gt;功能需求&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Functional Requirement&lt;/code&gt;), 即我们的程序必须实现的功能, 和 &lt;strong&gt;非功能需求&lt;/strong&gt;, 如安全性, 程序性能, 易用性等尚未被明确作为需求的指标, 开始.&lt;/p&gt;

&lt;p&gt;我们可以通过列举使用场景, 调查用户反馈, 将设计可视化等方式抓住需求的核心并检查/修补设计中可能存在的缺陷以及对需求的误解. 需要注意, 相同的需求有多种不同的实现方式, 因此在设计用户界面时无需拘泥于某个特定的模版或结构.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307100221.png&quot; alt=&quot;20220307100221&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可见, 上述的不同界面都提供了相同的功能: ”Establish an area where user can search a property“.&lt;/p&gt;

&lt;p&gt;在将需求转换为最终设计的过程中, 我们的设计一般会随着对需求理解的逐渐深化和调整而变得愈发精确. 一般地, 用户界面设计会自底向上地经历下列的四个阶段:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;草图. 它一般作为线框模型的草稿, 展示最初始的设计大纲, 不具备正式性, 但也是一种有效表达想法的方式.&lt;/li&gt;
  &lt;li&gt;线框模型 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wireframe&lt;/code&gt;). 相比草图, 线框模型更加正式. 它被用于模拟和规划界面元素的编排, 在这一阶段下界面板式和涉及元素被基本确定.&lt;/li&gt;
  &lt;li&gt;样板模型 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mockups&lt;/code&gt;). 样板模型在形式上最接近于实际成品, 它在线框模型的基础上包含了界面设计所需具备的样式, 基本上就是实际设计的静态展示.&lt;/li&gt;
  &lt;li&gt;原型 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prototype&lt;/code&gt;): 原型相比样板模型加入了基本的操作逻辑, 允许动态的用户交互, 实际上最接近于成品.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般地, 程序设计的精确度越高, 所需要消耗的时间也就越多. 理想情况下, 大部分的时间应当被用于实现程序逻辑, 而非浪费在原型或可交互化样板模型的开发上.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307101510.png&quot; alt=&quot;20220307101510&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们下面对实物展示环节 (mockups) 存在的意义简单的总结:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们可以在此过程中通过与客户进行交流确保我们的设计符合用户需求, 且可以在此过程中交换意见, 并为客户提供不同的选择.&lt;/li&gt;
  &lt;li&gt;我们可以利用这一过程及时消除设计和实现所存在的缺陷以及对用户需求的误解.&lt;/li&gt;
  &lt;li&gt;我们可以使用自顶向下地方法从用户需求中提取对应的任务.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面介绍用户界面设计的八条黄金原则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;确保用户界面设计的一致性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Consistency&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;确保用户界面对绝大多数的用户群体而言都具备足够的易用性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Usability&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;用户界面所提供的任何反馈都应能提供有价值的信息.&lt;/li&gt;
  &lt;li&gt;为用户界面中的任何操作流程提供引导, 在流程结束时提供流程完结的反馈.&lt;/li&gt;
  &lt;li&gt;尽量避免用户执行错误操作的几率, 并确保在操作错误时提供合理的反馈.&lt;/li&gt;
  &lt;li&gt;提供明显的方法允许用户撤销操作.&lt;/li&gt;
  &lt;li&gt;为用户提供掌控感, 通过确保设计符合直观确保获得用户信任.&lt;/li&gt;
  &lt;li&gt;减少用户的短时记忆负担, 确保界面设计足够简洁.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;week3-数据建模&quot;&gt;Week3: 数据建模&lt;/h2&gt;

&lt;p&gt;本节介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 的数据建模和数据持久化.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Model&lt;/code&gt;) 是用户在使用应用程序时所生成/需要调用的数据或方法, 它是基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 架构的程序中的核心组成部分. 下面讨论如何在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 程序中构造和持久化某个模型.&lt;/p&gt;

&lt;h3 id=&quot;1-基本数据建模&quot;&gt;1. 基本数据建模&lt;/h3&gt;

&lt;p&gt;我们下面考虑本课程小组项目中涉及的概念: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Venue&lt;/code&gt;, 即事件发生的地点. 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Plain Old Java Object&lt;/code&gt; 
对其建模的效果是:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307103040.png&quot; alt=&quot;20220307103040&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意: 变量域需要设为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;, 必须有一个向外界暴露的构造器, 且变量的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getter&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setter&lt;/code&gt; 的命名需要和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 的常规一致, 如: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getId()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setId()&lt;/code&gt;, 只有通过这种方式才能确保 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 知道你写的是什么.&lt;/p&gt;

&lt;p&gt;要确保 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 知道如何将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Venue&lt;/code&gt; 对象存储到数据库中, 我们需要为这个类加上一些 &lt;strong&gt;标注&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Annotation&lt;/code&gt;):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Entity&lt;/code&gt; 标注说明我们希望这个类作为数据库表的基础 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt;). 每个该类的实例都将作为数据表的一行存储在数据库中.&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Table&lt;/code&gt; 标注说明我们希望这个表的名称是什么: 在本例中它被标注为 “venues”.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在下面的例子中, 经过这样的标注, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 会生成一个名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venues&lt;/code&gt; 的表, 自动构造出表结构分别存储 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt;, 并自行处理数据的序列化和反序列化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307104142.png&quot; alt=&quot;20220307104142&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, 我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Id&lt;/code&gt; 标注该表的主键, 还可以将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Id&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@GeneratedValue&lt;/code&gt; 标注一起使用 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in conjunction with&lt;/code&gt;) 令 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 在这个模型被存储时自动生成主键.&lt;/p&gt;

&lt;h3 id=&quot;2-数据关系&quot;&gt;2. 数据关系&lt;/h3&gt;

&lt;p&gt;我们接下来讨论数据关系. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 中, 可以使用下列的标注表明对象之间的数据关系:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307104238.png&quot; alt=&quot;20220307104238&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-数据存取架构&quot;&gt;3. 数据存取架构&lt;/h3&gt;

&lt;p&gt;在完成对模型的建模, 确立了它和其他实体之间的关系后, 我们下一步需要考虑的问题是如何从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 自动为我们创立的数据库中存取 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Storing and Retrieving&lt;/code&gt;) 信息.&lt;/p&gt;

&lt;p&gt;下面介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 的数据存取架构. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 在数据库和实现程序逻辑的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 之间建立了抽象层, 因此我们无需关系数据库的具体实现.&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 架构中, 对数据的处理逻辑位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Model&lt;/code&gt; 部分中, 而在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 中数据处理逻辑独立于用于隔离数据库的抽象层而存在.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307105845.png&quot; alt=&quot;20220307105845&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Model&lt;/code&gt; 进一步拆分成负责数据库实现与数据库存取指令抽象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt; 层和负责数据的处理逻辑的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service Layer&lt;/code&gt; 层.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307105835.png&quot; alt=&quot;20220307105835&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 充分利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interface&lt;/code&gt; 标记不同类型. 由于我们无从得知 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt; 中对数据库的抽象, 即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Venue Repository Impl&lt;/code&gt; 是如何实现的,  我们使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt; 标注让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 自行基于我们构造的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interface&lt;/code&gt; 寻找到合适的实现.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service Layer&lt;/code&gt; 中, 我们同样适用一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interface&lt;/code&gt; 来控制 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt; 层向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 暴露的方法有哪些, 而这样的架构会在每一个存储于模型中的实体上应用, 因此在我们的例子中它除了出现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Venue&lt;/code&gt; 实体上, 还会应用在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Events&lt;/code&gt; 上.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们可以通过这种方式控制每个实体类型所可使用的操作, 甚至可以为不同的实体类型分配不同类型的数据库.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307110723.png&quot; alt=&quot;20220307110723&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面讨论如何定义 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt;, 并且简单介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; 界面的基本特征.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 提供了多种 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt; 实现, 如:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VenueRepository&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CrudRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Venue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// CRUD: create, read, update, delete&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Note: `Venue' is the entity type that we want our repo to store&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//       `Long': the type of the entity's primary key&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们只需要声明这样的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interface&lt;/code&gt;, 即可构造出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Venue&lt;/code&gt; 实体的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt;. 这样的模式也被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Marker Interface&lt;/code&gt;: 它相当于告知 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 自动为对应的实体生成具体的实现.&lt;/p&gt;

&lt;p&gt;默认情况下, 该实现会为我们提供下列的预定义方法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307111245.png&quot; alt=&quot;20220307111245&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而我们只需要为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Venue Repository&lt;/code&gt; 定义一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Marker Interface&lt;/code&gt; 就可以得到这一切, 无需多写半行代码.&lt;/p&gt;

&lt;p&gt;我们也可以在这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Marker Iinterface&lt;/code&gt; 中定义其他的自定义方法, 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307111430.png&quot; alt=&quot;20220307111430&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意: 这些自定义方法均遵循 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 的自动转换规则, 能够将这些符合条件的空方法转换成预置的具体实现.&lt;/p&gt;

&lt;p&gt;此外, 这些方法的参数类型和返回值类型都需要和相关的对象的类的变量域的类型保持一致.&lt;/p&gt;

&lt;p&gt;在第四周的小组项目任务中, 我们可以利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findByNameContaining()&lt;/code&gt; 方法.&lt;/p&gt;

&lt;p&gt;我们最后讨论如何通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service Interface&lt;/code&gt; 查询数据. 该层的存在意义在于:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;将具体的数据操作逻辑和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt; 层隔离.&lt;/li&gt;
  &lt;li&gt;即使我们希望重定义查询语句的功能或封装执较为复杂的数据查询操作, 我们也同样不希望这些实现被放在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 层中破坏不同功能层间的隔离性.&lt;/li&gt;
  &lt;li&gt;控制哪些方法被直接暴露给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在下面的例子中, 可见 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findAll()&lt;/code&gt; 方法被直接暴露给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt;. 而若我们只希望返回经过字母顺序排序后的搜索结果, 我们就可以重新定义 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findAll()&lt;/code&gt; 方法来实现这一点. 这样, 我们就可以实现逻辑隔离并确保 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 尽可能地简单.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307112552.png&quot; alt=&quot;20220307112552&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;week4-数据安全和隐私&quot;&gt;Week4: 数据安全和隐私&lt;/h2&gt;

&lt;p&gt;本节讨论网页程序的数据安全与用户隐私问题.&lt;/p&gt;

&lt;p&gt;我们首先明确在网页程序的讨论范围内, 需要被保护的东西是什么: 一般地, 我们需要妥善保护包括用户信息, 程序文件等在内的实体资产和公司声誉等无形资产.&lt;/p&gt;

&lt;p&gt;我们其次明确为了保护资产, 所需要对抗的对象是什么. 可能的威胁或攻击者可能是半桶水的脚本小子, 心怀不满的竞争者, 想捡大漏的用户甚至奇妙深刻的境外势力.&lt;/p&gt;

&lt;p&gt;一般地, 这样的设计模式被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scurity-By-Design Approach&lt;/code&gt;, 设计步骤分为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Identify Assets&lt;/li&gt;
  &lt;li&gt;Perform Threat Modeling&lt;/li&gt;
  &lt;li&gt;Choose Mitigation Techniques&lt;/li&gt;
  &lt;li&gt;Design and Test&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;潜在的安全威胁种类无法估量. 下面是2017年排名前十的安全威胁类型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307152343.png&quot; alt=&quot;20220307152343&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在此之中, 我们主要讨论 &lt;strong&gt;功能残缺的身份验证&lt;/strong&gt; 和 &lt;strong&gt;注入攻击&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;1-身份验证&quot;&gt;1. 身份验证&lt;/h3&gt;

&lt;p&gt;首先给出 &lt;strong&gt;身份验证&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Authentication&lt;/code&gt;) 的定义: 我们称确认用户身份的过程为身份验证, 它所预防的是 &lt;strong&gt;欺骗身份攻击&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spoofing identity attack&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;其流程是: 将用户所提供的身份验证信息和存储在安全数据库中的信息进行比对, 只放行能够提供可以在数据库中匹配的安全信息的用户.&lt;/p&gt;

&lt;p&gt;基本上, 身份验证信息的构造基于三个可能的思路: &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Who we are&lt;/code&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;What we know&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;What we have&lt;/code&gt;&lt;/strong&gt;. 例如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307152823.png&quot; alt=&quot;20220307152823&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们下面以当前仍然最为常见的 &lt;strong&gt;用户名-密码&lt;/strong&gt; 验证方式为例讨论其安全性.&lt;/p&gt;

&lt;p&gt;最简单的实现方式是将密码 &lt;strong&gt;明文存储&lt;/strong&gt; 在后端数据库中. 其安全风险是: 一旦后端数据库发生信息泄露, 掌握数据库的恶意一方可以立即获得所有的用户信息并获得对账户的完全掌控权.&lt;/p&gt;

&lt;p&gt;改进的实现方式是在前端使用哈希函数将密码进行哈希编码. 由于实现合理的哈希函数具有单向性, 因此恶意方及时掌握了泄露的数据库数据也基本不可能从哈希值入手反向计算出实际的用户密码.但这一方法仍然存在风险: 由于作为哈希函数输入的密码尚未进行任何处理, 因此 &lt;strong&gt;相同的密码将会以相同的形式存储在数据库中&lt;/strong&gt;. 因此攻击者即便难以从数据库得知明文密码, 他们仍可以得知 ”不同用户使用了相同的密码“ 这一信息, 而它可以作为破译密码的入手点.&lt;/p&gt;

&lt;p&gt;因此为了确保安全, 我们需要在前端对用户的密码进行 &lt;strong&gt;哈希加盐&lt;/strong&gt;. 其实质是: 对每个用户我们存储一段与之对应的 &lt;strong&gt;盐值&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Salt&lt;/code&gt;), 而安全数据库中所存储的信息则是 &lt;strong&gt;盐值和明文密码连接后作为哈希函数的输入所计算出的哈希值&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307153739.png&quot; alt=&quot;20220307153739&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-授权&quot;&gt;2. 授权&lt;/h3&gt;

&lt;p&gt;下面讨论 &lt;strong&gt;授权&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Authorisation&lt;/code&gt;) 的安全性问题.&lt;/p&gt;

&lt;p&gt;我们将 &lt;strong&gt;授权&lt;/strong&gt; 定义为: 指定对特定资源的访问权限的过程, 它主要防护的是 &lt;strong&gt;提权攻击&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Privilege Escalation Attacks&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;我们一般使用 &lt;strong&gt;基于身份的认证&lt;/strong&gt; 来实现授权保护. 常见的用户身份及其权限等级为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307154140.png&quot; alt=&quot;20220307154140&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-注入攻击&quot;&gt;3. 注入攻击&lt;/h3&gt;

&lt;p&gt;随后我们讨论注入攻击:&lt;/p&gt;

&lt;p&gt;我们定义注入攻击为 &lt;strong&gt;攻击者通过注入不受信任的输入并使这些输入作为查询或指令执行&lt;/strong&gt; 的行为.&lt;/p&gt;

&lt;p&gt;常见的注入攻击有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CSRF&lt;/code&gt; (跨站请求伪造), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XSS&lt;/code&gt;(跨站脚本漏洞) 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 注入等. 导致注入攻击能够成功的一半原因是站点并未实现完善的用户输入验证.&lt;/p&gt;

&lt;p&gt;因此, 避免注入攻击最有效的方法是: 坚持 &lt;strong&gt;永远不要相信用户端输入&lt;/strong&gt; 的原则, 尽可能多地对用户输入进行 &lt;strong&gt;限制&lt;/strong&gt;, &lt;strong&gt;控制&lt;/strong&gt; 和 &lt;strong&gt;监测&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Restrict, Control, Monitor&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;4-在基于-spring-的网页应用程序中应用安全原则&quot;&gt;4. 在基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 的网页应用程序中应用安全原则&lt;/h3&gt;

&lt;p&gt;作为功能完善的后端框架, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 提供了对主流 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Web&lt;/code&gt; 安全实践的完整支持:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307155121.png&quot; alt=&quot;20220307155121&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在小组项目所涉及的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Web&lt;/code&gt; 应用程序中, 安全性设置受 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config&lt;/code&gt; 包中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Security&lt;/code&gt; 类所控制. 在该类被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@EnableWebSecurity&lt;/code&gt; 标注时, 其安全系统会被启用, 并且我们可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WebSecurityConfigurerAdapter&lt;/code&gt; 类中重载相关方法以微调安全设置.&lt;/p&gt;

&lt;p&gt;当前, 网页应用程序的安全设置是:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307160539.png&quot; alt=&quot;20220307160539&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以使用下列的方式新增/调整用户权限等级, 并调整哪些页面和指令不受安全系统的监视:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307160632.png&quot; alt=&quot;20220307160632&quot; /&gt;&lt;/p&gt;

&lt;p&gt;负责登录/登出的代码段:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307160842.png&quot; alt=&quot;20220307160842&quot; /&gt;&lt;/p&gt;

&lt;p&gt;负责用户信息存储的代码段:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220307160806.png&quot; alt=&quot;20220307160806&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-用户隐私问题&quot;&gt;5. 用户隐私问题&lt;/h3&gt;

&lt;p&gt;我们下面讨论用户隐私问题. 回顾安全威胁排名, 不难看出和用户隐私息息相关的 “敏感信息泄露” 问题位列第三, 因此用户隐私同样是我们需要关注的重点.&lt;/p&gt;

&lt;p&gt;“敏感信息” 包括身份信息 (如身份证号, 家庭住址, 户籍信息等), 其他隐私信息 (如健康状况), 财产信息(如银行卡号, 信用卡号, 银行账户), 身份验证信息 (如用户名, 密码等). 这些信息都需要被妥善保护避免泄漏.&lt;/p&gt;

&lt;p&gt;为了避免用户敏感信息泄露, 我们可以遵循 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hoepman's Eight Privacy Design Strategies&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;简化: 尽可能地在程序的流程中 &lt;strong&gt;减少对用户个人信息的处理&lt;/strong&gt;. 只要我们从一开始就不收集敏感信息, 就不会有敏感信息的泄露问题.&lt;/p&gt;

    &lt;p&gt;如: 不收集无需收集的数据: 视频网站无需收集用户的身份证号, 文件转换程序无需收集访问者的ip地址. 程序可以定期清除非活跃用户的数据, 而无需将它们和其他用户的数据一同存储.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;隔离: 在逻辑上和物理上隔离对用户信息的处理, 人为地制造攻击者整合个人信息的难度.&lt;/p&gt;

    &lt;p&gt;如: 将用户的个人信息和会员信息分别存储在不同的物理机上, 而非在一台服务器上同时存储.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;抽象化: 尽可能地去除受处理的用户信息的指纹特征. 我们所处理的用户信息越模糊, 隐私风险就越小.&lt;/p&gt;

    &lt;p&gt;如: 网站只需要知道用户是否大于 $18$ 岁, 而无需知道用户的生日.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;隐藏: 确保用户信息不被公开, 并确保用户信息不可被关联. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unlinkable&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;如: 将用户数据以加密形式存储.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;告知: 在合适的时间和场合主动告知用户网页程序收集和处理其个人信息所可能带来的风险.&lt;/li&gt;
  &lt;li&gt;控制: 为用户提供合理的, 控制程序对其个人信息收集的方式, 将选择权交给用户.&lt;/li&gt;
  &lt;li&gt;强制执行: 确保正确的, 处理用户信息的原则和流程被强制执行, 从管理层到开发者, 公司上下都需要具备对用户信息的保护意识.&lt;/li&gt;
  &lt;li&gt;展示: 向外界展示处理用户信息的方式, 将对用户信息的收集和处理透明化, 公开化.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;week5-实例化需求&quot;&gt;Week5: 实例化需求&lt;/h2&gt;

&lt;p&gt;实例化需求 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Specification By Example&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SBE&lt;/code&gt;) 就是从使用场景出发, 以用户的操作实例来说明和解释需求. 和常规的规格说明相比, “实例” 更加场景化, 其典型的形式是: “在什么情况下, 执行什么操作, 所期望得到的结果是什么”.&lt;/p&gt;

&lt;p&gt;因此, 使用实例化需求的方法解释产品需求时, 一般需要经历三个步骤:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用具体的例子 &lt;strong&gt;分析和说明&lt;/strong&gt; 需求.&lt;/li&gt;
  &lt;li&gt;将第一步中涉及的例子 &lt;strong&gt;转化为具体实现的测试用例&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;使用第二步中构建的测试用例验证产品实现, 检测产品是否满足了需求.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 允许我们通过 &lt;strong&gt;对实体进行检测&lt;/strong&gt; 和 &lt;strong&gt;对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 检测&lt;/strong&gt; 来判断需求是否得到了满足. 如:&lt;/p&gt;

&lt;p&gt;在对实体进行检测时, 可通过下列的标记检测实体的期望属性:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220308085550.png&quot; alt=&quot;20220308085550&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时也可以通过检测 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 来判断:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220308085643.png&quot; alt=&quot;20220308085643&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;week6-隔离化功能测试&quot;&gt;Week6: 隔离化功能测试&lt;/h2&gt;

&lt;p&gt;本节讨论如何将程序的不同功能与其他功能模块 &lt;strong&gt;隔离&lt;/strong&gt;, 从而确保它可以被 &lt;strong&gt;完全独立&lt;/strong&gt; 地测试. 下面以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 应用程序中的控制器举例说明, 如何通过构造单元测试样例实现这一点.&lt;/p&gt;

&lt;h3 id=&quot;1-软件测试的基本概念&quot;&gt;1. 软件测试的基本概念&lt;/h3&gt;
&lt;p&gt;我们首先回顾软件测试的基本概念:&lt;/p&gt;

&lt;p&gt;软件测试就是一种检验程序功能或性能是否达到要求的手段和方法, 有助于开发团队在同一个程序库中协同工作, 并确认彼此的工作进度. 其基本途径是 &lt;strong&gt;确认&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Validation&lt;/code&gt;) 和 &lt;strong&gt;验证&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Verification&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;基本上, &lt;strong&gt;确认&lt;/strong&gt; 这一步需要我们明确, 我们是否够贱了正确的软件, 以使其符合客户的需求. 而 &lt;strong&gt;验证&lt;/strong&gt; 这一步需要做的事是, 确认我们是否以正确的方式将其构建, 以及它是否不受各种 &lt;strong&gt;缺陷&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Defect&lt;/code&gt;) 和 &lt;strong&gt;故障&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Failure&lt;/code&gt;) 的影响.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;故障&lt;/strong&gt; 的发生往往意味着软件中存在亟需修正的缺陷, 但反过来即使软件在运行中并未发现故障也不能确定它就没有缺陷, 这可能只是因为恰好包含缺陷的代码段没有被执行, 或出于纯粹的运气在此次执行中没有触发故障.&lt;/p&gt;

&lt;p&gt;广义上, 软件未能达成客户需求, 软件的非功能性特性, 如可扩展性, 易用性和性能不足, 也算作软件缺陷.&lt;/p&gt;

&lt;p&gt;我们可以通过设计模拟多种情境, 注入多种不同数据的测试样例来减小 “因为运气原因未能发现软件中潜藏的缺陷” 的概率.&lt;/p&gt;

&lt;p&gt;虽然完整地测试所有对象, 考虑所有情境实际上是不可能的, 但我们可以通过将不同级别的测试组合起来, 最大化我们的测试范围, 并排除因为运气而无法发现缺陷的情况.&lt;/p&gt;

&lt;p&gt;下面讨论测试的两种类型: &lt;strong&gt;静态测试&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Static&lt;/code&gt;) 和 &lt;strong&gt;动态分析测试&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dynamic Analysis&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;在静态测试中, 我们实际上并不会运行程序. 静态测试的例子包括 &lt;strong&gt;代码审查&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code Review&lt;/code&gt;), 对代码段逻辑和语法的自行检查 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inspection&lt;/code&gt;) 等.&lt;/p&gt;

&lt;p&gt;而在动态测试中, 我们一般使用 &lt;strong&gt;测试套件&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Suite&lt;/code&gt;) 在给定数据的情况下运行程序并检查对应的运行结果. 和静态测试一样, 这一过程既可以是手动的, 也可以是基于测试框架自动执行的.&lt;/p&gt;

&lt;p&gt;测试基于 &lt;strong&gt;测试者能否看到他们所测试对象的内部结构&lt;/strong&gt; 而又被分为 &lt;strong&gt;黑盒测试&lt;/strong&gt; 与 &lt;strong&gt;白盒测试&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在白盒测试中, 我们可以对被测对象的内部方法和结构进行测试, 这一类型的测试适用于我们需要检查被测对象结构的情形.&lt;/p&gt;

&lt;p&gt;而在黑盒测试中, 我们对其内部结构一无所知, 因而只能检查 “黑盒吐出的结果”, 由此这一类型的测试适用于我们需要从方法使用者的角度检查被测对象的情形.&lt;/p&gt;

&lt;p&gt;通过将静态测试和动态分析测试相结合, 编写黑盒测试与白盒测试, 我们可以最大程度地确保被测对象不包含明显的程序错误, 缺陷和故障.&lt;/p&gt;

&lt;p&gt;下面讨论如何基于不同的 &lt;strong&gt;层级&lt;/strong&gt; 对软件进行测试.&lt;/p&gt;

&lt;p&gt;基于不同的层级, 测试可被分为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;单元测试 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit Test&lt;/code&gt;): 针对每个独立的代码块进行测试.&lt;/li&gt;
  &lt;li&gt;集成测试 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integration Test&lt;/code&gt;): 将多个模块组合起来进行测试, 确保多个组件可以正确交互.&lt;/li&gt;
  &lt;li&gt;系统测试 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System Test&lt;/code&gt;): 进一步将所有的模块整合为一个系统, 确保作为整体时软件可以正常工作.&lt;/li&gt;
  &lt;li&gt;验收测试 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Acceptance Test&lt;/code&gt;): 检查软件是否满足了用户的需求.&lt;/li&gt;
  &lt;li&gt;回归测试 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Regression Test&lt;/code&gt;): 在经过整合后重新执行单元测试, 确保对模块的整合与修复不会影响之前已经通过检测的任何单元.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423132853.png&quot; alt=&quot;20220423132853&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-基于隔离原则的功能测试&quot;&gt;2. 基于隔离原则的功能测试&lt;/h3&gt;

&lt;p&gt;下面我们介绍如何设计测试使它能够 &lt;strong&gt;完全独立地&lt;/strong&gt; 对所需项目进行测试的方法和技术, 我们将通过以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 网络程序的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller&lt;/code&gt; 为例展示如何隔离针对它的单元测试.&lt;/p&gt;

&lt;p&gt;将隔离作为功能测试的原则的原因是: 对于单元测试 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit Test&lt;/code&gt;) 而言, 一个合格的单元测试不应当基于其他任何测试之上, 而应当在 &lt;strong&gt;只测试某一个特定项目&lt;/strong&gt; 的同时 &lt;strong&gt;位于由测试任务划定的类, 进程或网络范围内&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;考虑下列的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423134253.png&quot; alt=&quot;20220423134253&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上述的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 架构中, 如果要对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VenueController&lt;/code&gt; 进行单元测试, 在不进行隔离的情况下就会不可避免执行对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Web Server&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VenueService&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View Processor&lt;/code&gt; 的调用, 破坏了单元性. 为了将程序模块和外界的其他作为依赖的模块或数据在测试时隔离开, 我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Double&lt;/code&gt; 将它们模拟出来.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test Double&lt;/code&gt; 依据复杂性被分为四种类型:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dummy&lt;/code&gt;: 不参与待测方法/类的任何数据或逻辑操作, 只是起到占位符的作用, 往往在构造类, 实例化对象或调用方法时作为不会被实际使用的参数传入.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fake&lt;/code&gt;: 一般指代 (在测试环境下能够满足调用需求, 但复杂度和安全性等重要性质被弱化或忽略, 因此不适用于实际生产环境中的数据, 数据库或方法), 如 “不安全地在内存中存储数据库的数据库管理系统”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stub&lt;/code&gt;: 一般用于提供预设且无法更改变化的数据, 如某个被设计为永远返回 $0$ 的, 回传温度传感器读数的方法.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mock&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mock&lt;/code&gt; 是具有逻辑的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stub&lt;/code&gt;, 它能依据预设的逻辑依次或在不同的状态下向被测方法/类/对象提供不同的数据.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stub&lt;/code&gt; 的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423135304.png&quot; alt=&quot;20220423135304&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可见在上图的例子中方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readTemperature()&lt;/code&gt; 就被设计为一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stub&lt;/code&gt;, 为了满足测试的需求, 它的返回值永远为 $0$.&lt;/p&gt;

&lt;p&gt;下面介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mock&lt;/code&gt; 的使用:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423135423.png&quot; alt=&quot;20220423135423&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mock&lt;/code&gt; 来构造具有逻辑的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;method stubs&lt;/code&gt;, 注意此处在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mocking&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 对象时, 所使用的注记为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Mock&lt;/code&gt;, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mocking&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service layers&lt;/code&gt; 时则需使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@MockBean&lt;/code&gt;. 通过这种方法我们即可用被模拟出来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mock&lt;/code&gt; 替代和被测类/对象/方法相关联的其他类/方法/对象或所需要的数据, 进而实现被测者和外界环境的完全隔离.&lt;/p&gt;

&lt;p&gt;默认状态下对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mock&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service layers&lt;/code&gt; 的各种方法进行调用时, 回传值均为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;, 如: 尝试调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eventService.findAll()&lt;/code&gt; 就永远会得到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;. 要让特定的服务层方法或类方法以指定的方式返回特定的值, 就需要人为定义它们的返回逻辑.&lt;/p&gt;

&lt;p&gt;首先我们可以自定义 &lt;strong&gt;在何种情况下返回什么数据&lt;/strong&gt;, 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423140018.png&quot; alt=&quot;20220423140018&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event.getName()&lt;/code&gt; 返回值的定义: 上图例子中的定义实际上定义的是该方法被先后调用两次时所需返回的不同结果, 第一次抛出异常, 而第二次返回 “Hello”.&lt;/p&gt;

&lt;p&gt;同时还可以对调用某些方法时所执行的行为进行检测(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;verification&lt;/code&gt;). 检测发生在对应方法调用之后, 验证该方法是否执行了我们所希望执行的行为.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423140223.png&quot; alt=&quot;20220423140223&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后引入一个实际的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423140659.png&quot; alt=&quot;20220423140659&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先, 要对该需求进行测试, 我们需要实例化 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venue&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venueService&lt;/code&gt;. 上图中的测试分为四个部分:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venue&lt;/code&gt; 的性质进行建模: 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stub&lt;/code&gt; 定义所模拟的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venue&lt;/code&gt; 中不含任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venueService&lt;/code&gt; 的性质进行建模: 调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venueService.findOne(1L)&lt;/code&gt; 时所回传的恰为在第一步中所定义的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venue&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行删除方法, 尝试删除所建模的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venue&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对删除方法进行行为检测: 若程序满足需求, 由于建模的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venue&lt;/code&gt; 中不含任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt;, 因此它 &lt;strong&gt;可以被删除&lt;/strong&gt;. 因此行为检测这一步中, 需要检测在第三步中的删除方法执行成功后该 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;venue&lt;/code&gt; 是否真的被删除.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;examinable-reading-flacky-tests-in-python&quot;&gt;!Examinable Reading: Flacky Tests in Python&lt;/h3&gt;

&lt;h2 id=&quot;week7-集成外部-api&quot;&gt;Week7: 集成外部 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;本周以 &lt;strong&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eventlite&lt;/code&gt; 中引入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mapbox API&lt;/code&gt;&lt;/strong&gt; 为例, 介绍如何在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 网络程序中引入, 集成和调用外部 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC&lt;/code&gt; 架构的网络应用程序中引入第三方 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 的主要原因是我们可以复用现成的问题解决方案, 从而节约开发时间和程序复杂度. 第三方 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 引入的主要问题是: 寻找到满足需求的合适 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;, 以及将它集成进应用程序的过程, 其中以第一点最为重要.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423141708.png&quot; alt=&quot;20220423141708&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 时, 除了需要考虑上图中涉及的代码/开发参考指南质量, 功能性, 社区支持度等维度外, 更要结合自己的需求而定. 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423142139.png&quot; alt=&quot;20220423142139&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423142210.png&quot; alt=&quot;20220423142210&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据我们的实际需求, 就可以确定我们需要集成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mapbox GL JS&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Geocoding API&lt;/code&gt;. 不难得出, 我们可以使用下图所示的方式集成它们:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423144203.png&quot; alt=&quot;20220423144203&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在结合外部 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 时, 我们可以基于现成的使用例以借鉴的方式将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 集成入我们的程序中:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423144430.png&quot; alt=&quot;20220423144430&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;week8-集成外部服务&quot;&gt;Week8: 集成外部服务&lt;/h2&gt;

&lt;p&gt;本周我们以 &lt;strong&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Twitter&lt;/code&gt; 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Twitter4J Library&lt;/code&gt; 集成入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eventlite&lt;/code&gt;&lt;/strong&gt; 为例介绍如何将外部服务集成入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spring&lt;/code&gt; 网页应用程序中.&lt;/p&gt;

&lt;p&gt;和集成外部 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 相同, 我们首先需要给予需求决定集成什么样的外部服务.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423144723.png&quot; alt=&quot;20220423144723&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423145448.png&quot; alt=&quot;20220423145448&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423145505.png&quot; alt=&quot;20220423145505&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423145538.png&quot; alt=&quot;20220423145538&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220423145614.png&quot; alt=&quot;20220423145614&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/01/COMP23412/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/01/COMP23412/</guid>
        
        <category>课程笔记</category>
        
        <category>软件工程概论</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： Dijkstra与A*</title>
        <description>&lt;h1 id=&quot;启发式图算法-dijkstra-和-a&quot;&gt;启发式图算法: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;本章继续讨论最短路径问题, 并引入两个用于计算图最短路径的重要启发式算法: &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法&lt;/strong&gt; 和 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;1-dijkstra-算法&quot;&gt;1. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法&lt;/h2&gt;

&lt;p&gt;在上一章中, 我们已经知道可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法以 $O(\vert V\vert \vert E \vert)$ 的时间复杂度解决有权图 $G = \langle V, E\rangle$ 上的最短路径问题.&lt;/p&gt;

&lt;p&gt;由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法的时间复杂度与图的边数和节点数均相关, 随着问题涉及的图逐渐复杂化, 再用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法解决最短路径问题会不再可行. 因此, 我们下面介绍效率更高的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法:&lt;/p&gt;

&lt;h3 id=&quot;1-原理&quot;&gt;1. 原理&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312094800.png&quot; alt=&quot;20220312094800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法利用了 “单源最短路径的子路径仍然是最短路径” 的性质, 使用贪心的思想逐步构建局部最优的最短子路径:&lt;/p&gt;

&lt;p&gt;上图伪代码中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt; 就是依据节点权重排序的 &lt;strong&gt;优先队列&lt;/strong&gt;, 确保在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 循环中总是优先检查路径权重更小的点, $F \cup D$ 中的每个点都一定是能够从起始节点 $s$ 访问到的, 因此不可达的点将不会被检查到, 算法的效率得到提高.&lt;/p&gt;

&lt;p&gt;需要注意, 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法不同的是, &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法动员不能应用在存在负权边的图中&lt;/strong&gt;, 这是因为两者都基于贪心原则选择局部最优点构造部分解, 而 &lt;strong&gt;负权边的存在会破坏局部最优性&lt;/strong&gt;, 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312181425.jpeg&quot; alt=&quot;20220312181425&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-实现&quot;&gt;2. 实现&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法需要一个优先队列用于存储已发现但待检查的点. 由于我们关心路径权重估计更小的点, 因此在此处一般使用 &lt;strong&gt;最小堆&lt;/strong&gt; 实现优先队列.&lt;/p&gt;

&lt;p&gt;而在任何优先队列操作 (如插入/弹出)以及执行了对特定节点的松弛操作后, 都需要维护堆序性质.&lt;/p&gt;

&lt;p&gt;此外, 由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 所考虑的任何节点都一定是能够通过起始节点 $s$ 访问到的, 因此该算法在执行过程中不会考虑也不会存储任何不可达点 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unreachable&lt;/code&gt;) 的信息, 进而无需在优先队列中存储任何以 $\infty$ 为预估权重的点. (定义不可达的点权重为 $\infty$)&lt;/p&gt;

&lt;h3 id=&quot;3-性质&quot;&gt;3. 性质&lt;/h3&gt;

&lt;p&gt;由于算法从初识节点出发逐步向外扩展, 因此:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每条边最多被松弛一次.&lt;/li&gt;
  &lt;li&gt;任何节点最多被插入进优先队列一次, 同样地也只会被从中删除一次, 没有多余操作.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时, 由于我们使用最小堆实现优先队列, 因此 &lt;strong&gt;插入&lt;/strong&gt;, &lt;strong&gt;提取/弹出&lt;/strong&gt;, &lt;strong&gt;对给定边的松弛&lt;/strong&gt; 操作的时间复杂度均为 $O(\log{\vert V\vert}).$&lt;/p&gt;

&lt;p&gt;最后, 结合上述的两点性质可知, 由于在整个操作中任何边最多被执行一次松弛操作, 任何节点最多被插入优先队列一次, 弹出优先队列一次, 因此算法整体的时间复杂度为&lt;/p&gt;

\[O((\vert E \vert + \vert V \vert) \cdot \log(\vert V \vert)).\]

&lt;h2 id=&quot;2-a-算法&quot;&gt;2. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法&lt;/h2&gt;

&lt;p&gt;下面考虑一个基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法基础上的改进: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法.&lt;/p&gt;

&lt;h3 id=&quot;1-原理-1&quot;&gt;1. 原理&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法仍然存在的问题是: 虽然它无需再如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法一般, 不用再去考虑任何不可达点, 但它仍然需要对所有的可达点遍历一遍才能得出结果. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法在其基础上使用启发式方法对搜索空间进一步进行剪枝, 从而获得了更高的执行效率.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312110343.png&quot; alt=&quot;20220312110343&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-差异&quot;&gt;2. 差异&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法的启发式与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 的差异在:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;后者完全基于 &lt;strong&gt;权重&lt;/strong&gt; 评价生成的部分解的优劣, 前者的评价标准综合了 &lt;strong&gt;部分解当前的尾节点到起始节点的距离&lt;/strong&gt; (也就是权重) 与 &lt;strong&gt;尾节点到目标节点的距离&lt;/strong&gt;, 从而具有指向性: 权重越小, 距离目标节点越近的部分解越有可能被选定从而构造完整解.&lt;/p&gt;

\[\text{heuristic(u) = D(u) + \text{distance}(u, \text{target\_node})}\]
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于对可选部分解排序方式的转变, 最终完整解一旦在某一步中进入我们的选择范围内, 就一定会因为启发值最小而被优先选择, 从而剩下的所有较差解都不会再被考虑, 达到了剪枝的效果 (如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lab5&lt;/code&gt; 中优化的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BNB&lt;/code&gt;).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-启发性&quot;&gt;3. 启发性&lt;/h3&gt;

&lt;p&gt;下面简单介绍 &lt;strong&gt;某个启发函数能够被用于优化算法&lt;/strong&gt; 的条件: &lt;strong&gt;可启发性&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Admissibilty&lt;/code&gt;) 和 &lt;strong&gt;启发单调性&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monotonicity&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 2.1&lt;/strong&gt; (可启发性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;启发式函数的作用是对算法生成的部分解进行估计, 判断它距离完整解还有多少差异或距离.&lt;/p&gt;

  &lt;p&gt;称启发式函数的 &lt;strong&gt;可启发性&lt;/strong&gt; 为: 在任何情况下启发函数 $h(u)$ 返回的估计都 &lt;strong&gt;不能超过从这个部分解出发达成目标所需要花费的真实代价&lt;/strong&gt; $\delta(u, t)$:&lt;/p&gt;

\[h(u) \leqslant \delta(u, t)\]
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 2.2&lt;/strong&gt; (启发单调性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;启发式函数还需具备 &lt;strong&gt;单调性&lt;/strong&gt; 才能更好地用于优化算法 (注意, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法中的启发函数即使不满足单调性仍然可用).&lt;br /&gt;
启发单调性指, 在任意给定的当前解 $a$ 的基础上扩展任一步 $b$ 后, 启发函数 $h(a)$ 均满足:&lt;/p&gt;

\[h(a) \leqslant w(a, b) + h(b).\]

  &lt;p&gt;也就是所谓的 “三角形不等关系” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Triangle Inequality&lt;/code&gt;):
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312163215.png&quot; alt=&quot;20220312163215&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-dijkstra-和-a-算法的正确性&quot;&gt;3. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法的正确性&lt;/h2&gt;

&lt;p&gt;我们在本章的最后一节讨论两种启发式算法的正确性.&lt;/p&gt;

&lt;h3 id=&quot;1-dijkstra-算法的正确性&quot;&gt;1. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法的正确性&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法的不变量是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于任何位于 ”已完成检查集合“ $F$ 中的点 $u$, 从起始节点到该点最短路径的权重估计一定都是精确的:&lt;/p&gt;

\[D(u) = \delta(u).\]
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对任何在某个位于 $F$ 中的点 $u$ 之后插入原来的路径的点 $v$, 从起始节点到 $v$ 的最短路径的权重估计 $D(v)$ 有下列的上界:&lt;/p&gt;

\[\forall v, ~ D(v) \leqslant \delta(u) + w(u, v).\]
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对起始节点到边集 $V$ 中任何点的最短路径的权重估计都是 &lt;strong&gt;过高的估计&lt;/strong&gt;:&lt;/p&gt;

\[\forall u \in V. ~ D(u) \geqslant \delta(u).\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312174618.png&quot; alt=&quot;20220312174618&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显然在第 $0$ 次循环时, 有 $F = \emptyset$, 不变量在初始状态成立.&lt;/p&gt;

&lt;p&gt;在第 $1$ 次循环时算法首先将起始节点 $s$ 松弛, 因此 $D(s) = 0$, 同样满足不变量.&lt;/p&gt;

&lt;p&gt;下面考虑一般情况:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312174844.png&quot; alt=&quot;20220312174844&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-a-算法的正确性&quot;&gt;2. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法的正确性&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220312174936.png&quot; alt=&quot;20220312174936&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Feb 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/02/25/Ch3-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/02/25/Ch3-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>基于知识组织的人工智能:一阶逻辑推理</title>
        <description>&lt;h1 id=&quot;一阶逻辑推理&quot;&gt;一阶逻辑推理&lt;/h1&gt;

&lt;h2 id=&quot;1-一阶逻辑推理的一般框架-饱和-saturation-与-子句化-clausification&quot;&gt;1. 一阶逻辑推理的一般框架: &lt;strong&gt;饱和&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Saturation&lt;/code&gt;) 与 &lt;strong&gt;子句化&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clausification&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;在本节中, 我们将把前四周内所介绍的, 关于一阶逻辑和前向/反向链式推理的思想综合为 &lt;strong&gt;用于一阶逻辑推理的一般框架&lt;/strong&gt;: 它将包括一个通过驳斥 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refutation&lt;/code&gt;) 建立蕴含关系的, 应用在子句上的 &lt;strong&gt;饱和算法&lt;/strong&gt;, 以及一个用于将一般地一阶公式转换为子句的 &lt;strong&gt;子句化方法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;需要注意, 在此我们讨论的 &lt;strong&gt;子句&lt;/strong&gt; 定义不受前一章中的限制, 不仅局限于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Horn&lt;/code&gt; 子句 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Horn Clause&lt;/code&gt;) 或明确子句 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Definite Clause&lt;/code&gt;). 我们将在子句化过程中说明: &lt;strong&gt;任何形式的一阶公式都可被表示为一系列子句组成的集合&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;下面我们首先引入 &lt;strong&gt;基于反驳的推理&lt;/strong&gt; 和 &lt;strong&gt;饱和&lt;/strong&gt; 的概念.&lt;/p&gt;

&lt;h3 id=&quot;11-基于反驳的推理&quot;&gt;1.1 基于反驳的推理&lt;/h3&gt;

&lt;p&gt;首先回顾一些基本定义和记号:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;文字&lt;/strong&gt; 指原子或原子的取反 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Negation&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;子句&lt;/strong&gt; 指一系列文字的析取, 隐式地被全称量词量化.&lt;/li&gt;
  &lt;li&gt;称两个原子 $l_1$, $l_2$ &lt;strong&gt;联合&lt;/strong&gt;, 若存在替换 $\theta$ 使 $l_1 \theta, l_2 \theta$ 在语法上相同.&lt;/li&gt;
  &lt;li&gt;若某两个原子 $l_1, l_2$ 能够联合, 则必存在一个 &lt;strong&gt;最一般的联合子&lt;/strong&gt; $mgu(l_1, l_2)$.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;归结原则 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Resolution&lt;/code&gt;) 可用于具备下列形式的子句上:&lt;/p&gt;

\[\frac{\neg I_1 \vee C ~~~ I_2 \vee D}{(C \vee D)\theta}, ~~ \theta = \text{mgu}(I_1, I_2).\]

    &lt;p&gt;且可以证明归结原则是 &lt;strong&gt;正确的&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sound&lt;/code&gt;), 因为结论对任何前件条件 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Premises&lt;/code&gt;) 的模型都成立.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般地, 为了避免命名冲突, 我们需要在对前件条件应用归结原则前将它们重命名以确保不存在名称相同的变量.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们考虑通过 &lt;strong&gt;反驳&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Refutation&lt;/code&gt;) 实现推理的推理方法. 其实质是: 通过否定我们希望证明为真地陈述的反面, 来隐式地达成对 “陈述为真” 的证明.&lt;/p&gt;

&lt;p&gt;如: 我们在证明陈述&lt;/p&gt;

\[\Gamma \vDash \phi\]

&lt;p&gt;时, 如果通过 &lt;strong&gt;证明 $\Gamma \cup {\neg \phi}$ 是不一致的&lt;/strong&gt; 来说明原陈述成立, 就是在使用 &lt;strong&gt;基于反驳的推理方法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而证明 $\Gamma \cup {\neg \phi}$ 不一致的方法是: 将其作为知识库, &lt;strong&gt;不断地从中试图推导出所蕴含的新事实&lt;/strong&gt; , 如果直到 &lt;strong&gt;无法从中再推导出任何它所蕴含的新结论&lt;/strong&gt; 为止, 我们都 &lt;strong&gt;没有&lt;/strong&gt; 推出矛盾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;, 则说明式子 $\Gamma \cup {\neg \phi}$ 是可满足的, 即&lt;/p&gt;

\[\Gamma \nvDash \phi.\]

&lt;p&gt;反之, 只要推导出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;, 就可以说明它是不一致的, 也就证明&lt;/p&gt;

\[\Gamma \vDash \phi.\]

&lt;p&gt;这种类似于前向链式推理的检测方法通过 &lt;strong&gt;不断地&lt;/strong&gt; 从给定公式形成的知识库中推导出新的蕴含关系, 除非中途推导出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; 否则会 &lt;strong&gt;一直穷尽&lt;/strong&gt; 到没有新的蕴含关系可推为止, 因此得名 “饱和推理” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Saturation&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220308201146.png&quot; alt=&quot;20220308201146&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直到目前为止, 我们介绍的任何一种推理方法都要求查询语句 &lt;strong&gt;中每个变量都被全称量词修饰&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Universal unit&lt;/code&gt;) 或 &lt;strong&gt;为合取范式&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conjunctive Queries&lt;/code&gt;). 下面考虑如何对更一般的查询语句执行推理, 这也是 &lt;strong&gt;定理证明&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Theorem Proving&lt;/code&gt;) 的需求.&lt;/p&gt;

&lt;p&gt;我们认为 &lt;strong&gt;定理证明&lt;/strong&gt; 就是 &lt;strong&gt;自动推理&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Automated Reasoning&lt;/code&gt;) 中的一个分支, 其关注点是寻找 (知识库, 或称理论) 所蕴含的 &lt;strong&gt;陈述&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Statement&lt;/code&gt;) 的证明 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Proofs&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;需要注意, &lt;strong&gt;定理证明&lt;/strong&gt; 由于起源于数理逻辑, 因此在部分概念的术语上和 &lt;strong&gt;自动推理&lt;/strong&gt; 有所不同: 自动推理领域中的 &lt;strong&gt;知识库&lt;/strong&gt; 在定理证明领域中被称为 &lt;strong&gt;理论&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Theory&lt;/code&gt;), 而任何蕴含于 &lt;strong&gt;理论&lt;/strong&gt; 中的 &lt;strong&gt;陈述&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Statement&lt;/code&gt;) 都被称为一个 &lt;strong&gt;定理&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Theorem&lt;/code&gt;), 因此自动推理过程就被视为 “基于理论寻找定理的证明”.&lt;/p&gt;

&lt;p&gt;下面简介一个简单的, 基于饱和推理的定理证明算法的流程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220308202252.png&quot; alt=&quot;20220308202252&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-饱和&quot;&gt;1.2 饱和&lt;/h3&gt;

&lt;p&gt;假设待判断可满足性的陈述为&lt;/p&gt;

\[\Gamma \vDash \phi\]

&lt;p&gt;执行饱和推理的目的是, 确认 &lt;strong&gt;理论以及所有从理论中蕴含出的陈述组成的集合 $S$ 中是否有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;下面简述饱和推理的基本流程:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将 $S$ 拆分为待蕴含的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotDone&lt;/code&gt; 和已经过蕴含处理, 不会再得出新结论的陈述组成的集合 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt; 两个部分.&lt;/p&gt;

    &lt;p&gt;在初始化时, 自然地将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotDone&lt;/code&gt; 初始化为&lt;/p&gt;

\[\Gamma \cup \{\neg \phi\}\]

    &lt;p&gt;并将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt; 初始化为 $\emptyset$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotDone&lt;/code&gt; &lt;strong&gt;经过转化和预处理&lt;/strong&gt; 变为一系列子句组成的集合.&lt;/li&gt;
  &lt;li&gt;检查经过转换后的集合, 若已经发现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; 则直接返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;valid&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;若不能直接从第三步中得出结论, 则从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotDone&lt;/code&gt; 中 &lt;strong&gt;基于某些规则&lt;/strong&gt; 选取一个子句 $C$, 将其移入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;执行 $C$ 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt; 中任何其他子句之间所能执行的所有的推导规则 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inference&lt;/code&gt;), 如归结原则, 并将生成的所有有意义的新结论放到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotDone&lt;/code&gt; 中以备后续检查.&lt;/li&gt;
  &lt;li&gt;检查 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotDone&lt;/code&gt; 集合是否为空. 若不为空的话, 返回到第三步.&lt;/li&gt;
  &lt;li&gt;最后, 如果直到所有的定理及其归纳出的衍生结论均被检查后仍未归纳出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;, 则返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not valid&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们将在下一节中详细解释如何实现第二步中的 &lt;strong&gt;转化和预处理&lt;/strong&gt; 和第四步中 &lt;strong&gt;选取新子句的规则&lt;/strong&gt;, 在后面的章节中进一步地解释和介绍第五步中 &lt;strong&gt;对子句的推导原则&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;下面给出一个更具体的饱和推理算法的伪代码:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314153646.png&quot; alt=&quot;20220314153646&quot; /&gt;&lt;/p&gt;

&lt;p&gt;饱和推理与前向链式推理和反向链式推理之间的两个关键不同点是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;饱和推理是 &lt;strong&gt;有目标的&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goal-Directed&lt;/code&gt;): 和前向链式推理 &lt;strong&gt;盲目地&lt;/strong&gt; 尽可能地推导知识库所蕴含的新结论不同, 从一开始饱和推理的目标就是 $\text{goal}(\neg \phi)$.&lt;/p&gt;

    &lt;p&gt;因此, 饱和推理在达成目标之后就会立即终止并返回结果, 并且还可以反向推理.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;饱和推理对搜索路径中的新节点的选择是 &lt;strong&gt;基于最优标准&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Best-First&lt;/code&gt;) 的.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314160253.png&quot; alt=&quot;20220314160253&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2&quot;&gt;2.&lt;/h2&gt;

&lt;p&gt;REFERENCES:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://web2.qatar.cmu.edu/cs/15317/lectures/17-forwardlp.pdf&quot;&gt;Forward Logic Programming&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/02/22/Ch2-COMP24412/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/02/22/Ch2-COMP24412/</guid>
        
        <category>课程笔记</category>
        
        <category>人工智能</category>
        
        
      </item>
    
      <item>
        <title>基于知识组织的人工智能：Prolog 速成</title>
        <description>&lt;h1 id=&quot;prolog-速成&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prolog&lt;/code&gt; 速成&lt;/h1&gt;

&lt;h2 id=&quot;1-prolog-语法和证明搜索执行规则&quot;&gt;1. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prolog&lt;/code&gt; 语法和证明搜索执行规则&lt;/h2&gt;

&lt;h2 id=&quot;2--prolog-中基于-horn-子句的反向推理法的应用&quot;&gt;2.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prolog&lt;/code&gt; 中基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Horn&lt;/code&gt; 子句的反向推理法的应用&lt;/h2&gt;

&lt;h2 id=&quot;3-基于-prolog-的定理证明&quot;&gt;3. 基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prolog&lt;/code&gt; 的定理证明&lt;/h2&gt;
</description>
        <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/02/22/Ch1-COMP24412/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/02/22/Ch1-COMP24412/</guid>
        
        <category>课程笔记</category>
        
        <category>人工智能</category>
        
        
      </item>
    
  </channel>
</rss>
