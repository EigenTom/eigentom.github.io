<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>某一般线性空间</title>
    <description>由于相关法律法规规定, 该内容无法显示.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 04 Feb 2022 21:17:09 +0000</pubDate>
    <lastBuildDate>Fri, 04 Feb 2022 21:17:09 +0000</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>Software Engineering 一日速成</title>
        <description>&lt;h1 id=&quot;comp23311-24小时速成&quot;&gt;COMP23311 24小时速成&lt;/h1&gt;

&lt;h2 id=&quot;week-1-building--testing-open-source-systems&quot;&gt;Week 1: Building &amp;amp; Testing Open Source Systems&lt;/h2&gt;

&lt;p&gt;What is software Engineering?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Building software to &lt;strong&gt;Budget&lt;/strong&gt; + &lt;strong&gt;Deadline&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Needs to &lt;strong&gt;Deliver sufficient ROI (Return on Investment)&lt;/strong&gt; + &lt;strong&gt;affordable to maintain and change&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Typical Software organisation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Local Dev&lt;/li&gt;
  &lt;li&gt;Dev&lt;/li&gt;
  &lt;li&gt;Test&lt;/li&gt;
  &lt;li&gt;Live&lt;/li&gt;
  &lt;li&gt;End Users&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Acquring Source code&lt;/li&gt;
  &lt;li&gt;Build the object code&lt;/li&gt;
  &lt;li&gt;Run tests (code review, follow coding standards/documentation procedures, pass automated tests)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;week-2-understanding-large-software-systems-through-tests&quot;&gt;Week 2: Understanding Large Software Systems Through Tests&lt;/h2&gt;

&lt;p&gt;code reading: system domain technical&lt;/p&gt;

&lt;p&gt;syntactical/conceptual error/software bugs (faults error flow in source code or system design)&lt;/p&gt;

&lt;h2 id=&quot;week-3-debugging&quot;&gt;Week 3: Debugging&lt;/h2&gt;

&lt;h3 id=&quot;debug-systematic-approach&quot;&gt;Debug systematic approach:&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;start with a problem:&lt;br /&gt;
 replicate the issue&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stablize a problem&lt;br /&gt;
 describe the problem precisely&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;isolate the problem&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;tactic: rubber ducking, find common problems, IDE debug tools, test cases, git commit logs&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;strategy: brute force+backtrack+binary search+eliminate&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fix the problem&lt;br /&gt;
 (mostly the easiest part)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;test if the fix is successful&lt;/li&gt;
  &lt;li&gt;check similar errors (very important)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JUnit测试用例基本规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;test class 以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test&lt;/code&gt; 结尾&lt;/li&gt;
  &lt;li&gt;test method 一般建议以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;should&lt;/code&gt; 开头 (别的其实也可以)&lt;/li&gt;
  &lt;li&gt;assert一个测试方法中只能有一个&lt;/li&gt;
  &lt;li&gt;test method 不要有任何传入参数&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;week-4-cost-estimation&quot;&gt;Week 4: Cost Estimation&lt;/h2&gt;

&lt;p&gt;Cost estimation: effort + resources + schedules&lt;/p&gt;

&lt;p&gt;WBS: work breakdown structures&lt;/p&gt;

&lt;p&gt;100% rule: states that the WBS includes 100% of the work defined by the project scope and captures all deliverables – internal, external, interim – in terms of the work to be completed, including project management.&lt;/p&gt;

&lt;h2 id=&quot;week5-test-first-development&quot;&gt;Week5: Test First Development&lt;/h2&gt;

&lt;h3 id=&quot;scoping-features-to-manage-risk&quot;&gt;Scoping features to manage risk&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;incremental dev: Simple ver, in a form that can be used, Minimum marketable feature&lt;/li&gt;
  &lt;li&gt;Build on existing components: reuse, adapt, expand&lt;/li&gt;
  &lt;li&gt;Control the scope: &lt;br /&gt;
    ctrl affected:
    &lt;ol&gt;
      &lt;li&gt;existing types of obj&lt;/li&gt;
      &lt;li&gt;existing functions&lt;/li&gt;
      &lt;li&gt;user groups&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;release-planning&quot;&gt;Release planning&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;release date&lt;/li&gt;
  &lt;li&gt;user type?&lt;/li&gt;
  &lt;li&gt;build on? (reused what?)&lt;/li&gt;
  &lt;li&gt;affected types?&lt;/li&gt;
  &lt;li&gt;affected functions?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;agile-method-fail-fast-corner-stone&quot;&gt;Agile Method: Fail fast (corner stone)&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;short iterations&lt;/li&gt;
  &lt;li&gt;user stories&lt;/li&gt;
  &lt;li&gt;iteration planning/release planning&lt;/li&gt;
  &lt;li&gt;evolutionary design&lt;/li&gt;
  &lt;li&gt;TFD/TDD Test-first dev (test driven dev 更强)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;test-against-3-layer-architecture-presentation-logic-business-logic-data-logic&quot;&gt;Test against 3 layer architecture (Presentation logic, Business Logic, Data Logic):&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Outside-in Approach (gui driver 模拟用户操作)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Middle-Out Approach (调用 service layer api)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;role-of-acceptance-tests&quot;&gt;Role of acceptance tests&lt;/h3&gt;
&lt;p&gt;evaluate the system’s compliance with the business requirements and verify if it is has met the required criteria for delivery to end users.&lt;/p&gt;

&lt;h3 id=&quot;test-first-process&quot;&gt;Test-first process:&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;sketch out expected behavior as acceptance tests (use existing codes, or wishful thinking)&lt;/li&gt;
  &lt;li&gt;create test stubs and compile test&lt;/li&gt;
  &lt;li&gt;run the test to get a result (red)&lt;/li&gt;
  &lt;li&gt;implement the production code stubs&lt;/li&gt;
  &lt;li&gt;run the test again (should be green)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Remember in Jenkins:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;grey == not running test&lt;/li&gt;
  &lt;li&gt;red == compile failed&lt;/li&gt;
  &lt;li&gt;yellow == compile successful, but some tests failed&lt;/li&gt;
  &lt;li&gt;green == all tests passed&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;failing-test&quot;&gt;Failing test:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;fail unit test: you are fucked&lt;/li&gt;
  &lt;li&gt;failed pre-passed acceptance test: you are fucked&lt;/li&gt;
  &lt;li&gt;failed acceptance test on future features: it’s fine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TAD -&amp;gt; TFD -&amp;gt; TDD: maximise test coverage, maximise fit of production code to test code&lt;/p&gt;

&lt;h2 id=&quot;week-6-git-workflow&quot;&gt;Week 6: Git Workflow&lt;/h2&gt;

&lt;h3 id=&quot;code-review&quot;&gt;Code review:&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;buddy review (informal)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;team-based review (informal)&lt;br /&gt;
   tool: gerrit (allow code to be held in staging area for code rev, block integration into main branch until pass quality standard)&lt;/p&gt;

    &lt;p&gt;way: walkthrough: sanity check of design (best at the beginning), or correctness of implementation (after or during implementation)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;formal review (formal, inspection, technical review, technical+management)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Code reviewer’s good practice: neutral tone, promiscuory reviewing (轮换检查)&lt;/p&gt;

&lt;h3 id=&quot;rules-on-commit-msg&quot;&gt;Rules on Commit msg:&lt;/h3&gt;

&lt;p&gt;Imperative tone, NO COMMA, first line limit to 50 chars, the rest limit to 72 chars, second line leave blank, leave blank between paragraphs, detailed description of the change, integrate bug tracking&lt;/p&gt;

&lt;h3 id=&quot;git-commit-shits&quot;&gt;Git commit shits:&lt;/h3&gt;
&lt;p&gt;group coordination+codebase synchronisation, quality assurance&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Merge&lt;/li&gt;
  &lt;li&gt;Cherry Pick&lt;/li&gt;
  &lt;li&gt;Rebase&lt;/li&gt;
  &lt;li&gt;Resolve conflict&lt;/li&gt;
  &lt;li&gt;Fast forward&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Difference between Merge and conflict:&lt;/p&gt;

&lt;p&gt;Merge == preserve feature branch, Rebase == blow up feature branch, no record, look simple and elegent&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220124002645.png&quot; alt=&quot;20220124002645&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220123205209.png&quot; alt=&quot;20220123205209&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;git-workflow&quot;&gt;Git workflow:&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;GitFlow Model&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;2 main branches: master develop&lt;/li&gt;
      &lt;li&gt;3 supporting branches: feature hotfix release&lt;/li&gt;
      &lt;li&gt;only hotfix branch can fork from master&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;NO FAST FORWARD, NEVER.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;[branch structure]:&lt;/p&gt;

        &lt;p&gt;develop &amp;lt;=&amp;gt; master &amp;lt;=&amp;gt; feature&lt;/p&gt;

        &lt;p&gt;master &amp;lt;=&amp;gt; hotfix, feature &amp;lt;=&amp;gt; develop&lt;/p&gt;

        &lt;p&gt;release &amp;lt;=&amp;gt; develop, (maybe!) hotfix =&amp;gt; develop&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220123222410.png&quot; alt=&quot;20220123222410&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitHub Flow&lt;br /&gt;
 master, feature branches. all work done on feature branch&lt;/p&gt;

    &lt;p&gt;every commit on master is deployable, test branch in production environment before merging, pull request for code review&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Trunk-Based Development (主干开发模型) &lt;br /&gt;
 everyone work in one single trunk branch&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;one can work on local branch, merge to remote branch after get passed in gerrit&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;every single commit is release ready, high quality commits but no protection against errors&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;week-8-refactoring-and-migration&quot;&gt;Week 8: Refactoring and Migration&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;fixed bugs: corrective&lt;/li&gt;
  &lt;li&gt;added feature: adaptive&lt;/li&gt;
  &lt;li&gt;refactoring/migration: preventive change (prevent cost)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;patterns-of-code-change&quot;&gt;Patterns of code change:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;rename method/class&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;covert a var into const&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;convert a local var into a field&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;move a method to another class&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;refactoring&quot;&gt;Refactoring:&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;IDE integrated&lt;/li&gt;
  &lt;li&gt;change structure but not behavior&lt;/li&gt;
  &lt;li&gt;good tests are essential&lt;/li&gt;
  &lt;li&gt;workflow: run tests -&amp;gt; refactor -&amp;gt; run test again&lt;/li&gt;
  &lt;li&gt;relatively small changes&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;software-migration&quot;&gt;Software Migration:&lt;/h3&gt;
&lt;p&gt;large scope, move some functionality from one context to another (like from MySQL to Couchbase)&lt;/p&gt;

&lt;p&gt;Typical Process:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Ensure behavior which to be migrated is well tested&lt;/li&gt;
  &lt;li&gt;Migrate test to fit target context (doesn’t care abstract layer tests)&lt;/li&gt;
  &lt;li&gt;Then migrate functionality&lt;/li&gt;
  &lt;li&gt;test+fix until all migrated tests passed&lt;/li&gt;
  &lt;li&gt;then remove old form migrated tests&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;9-design-for-testability&quot;&gt;9. Design for Testability&lt;/h2&gt;

&lt;p&gt;Code is easy to test =&amp;gt; code is easy and safe to change =&amp;gt; good software design&lt;/p&gt;

&lt;p&gt;design driven for testability, ensure the code is easy to test&lt;/p&gt;

&lt;p&gt;Bad factors:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Non-deterministic (randomness) code&lt;/li&gt;
  &lt;li&gt;Hard-coding/hiding behavior&lt;/li&gt;
  &lt;li&gt;Not allowing inheritance/overriding&lt;/li&gt;
  &lt;li&gt;Complex/Slow configuration (running excessive shit such as database even if just need to test a simple thing, take more time)&lt;/li&gt;
  &lt;li&gt;Break the LAW OF DEMETER (I don’t know, didn’t covered, don’t ask)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Test doubles: (测试替身): a ver of predictable production code object&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Dummies: placeholder, passed but never used&lt;/li&gt;
  &lt;li&gt;Stubs: fixed value, canned answers&lt;/li&gt;
  &lt;li&gt;Fakes: include simple (usually shitty) logic, (partly) working implementations&lt;/li&gt;
  &lt;li&gt;Mocks: basically stub with assertions&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;10-patterns&quot;&gt;10. Patterns&lt;/h2&gt;

&lt;p&gt;Patterns: distilled wisdom, allow to reuse solutions (experience), provide a shared vocabulary of talking about software design&lt;/p&gt;

&lt;p&gt;Group of Patterns:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Behavioural Patterns (state, strategy)&lt;/li&gt;
  &lt;li&gt;Structural Patterns (composite, adaptor)&lt;/li&gt;
  &lt;li&gt;Creational Patterns (factory method, singleton)&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Strategy Pattern: 基于不同类对应的策略封装算法&lt;/li&gt;
  &lt;li&gt;State Pattern: 封装同一对象基于不同状态的多种行为&lt;/li&gt;
  &lt;li&gt;Composite Pattern: 部分-整体组合模式&lt;/li&gt;
  &lt;li&gt;Adapter Pattern: 接口转换, wrapper class&lt;/li&gt;
  &lt;li&gt;Factory Method: 让子类自己在运行时决定实例化哪个类&lt;/li&gt;
  &lt;li&gt;Singleton Pattern: 只让某个类创建唯一的一个对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220124003321.png&quot; alt=&quot;20220124003321&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220124003239.png&quot; alt=&quot;20220124003239&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220124003938.png&quot; alt=&quot;20220124003938&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Caution:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;No overuse&lt;/li&gt;
  &lt;li&gt;No over-engineering&lt;/li&gt;
  &lt;li&gt;refactor TOWARD a pattern rather than TO a pattern (把pattern作为参考, 而不是标准)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pattern的意义:&lt;/p&gt;

&lt;p&gt;Make code easy to understand, maintain and modify&lt;/p&gt;

&lt;h2 id=&quot;11-risk-management&quot;&gt;11. Risk Management&lt;/h2&gt;

&lt;p&gt;Risk: possible negative event&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Risk exposure = likelihood + impact (potential cost)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Planning:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Mitigate planning: make it less likely happen + reduce impact&lt;/li&gt;
  &lt;li&gt;Contingency Planning: make preparation if it happen, do nothing to reduce likelihood or impact&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tools used for risk management:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Git for Risk Management: ……&lt;/li&gt;
  &lt;li&gt;CI/CD for Risk Management: reduce risk likelihood &lt;br /&gt;
  CI: Integrate, build, test, report, make testing and building reliable&lt;/li&gt;
  &lt;li&gt;Automated Test Suite for Risk Management: reduce cost of regression (reduce cost)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a, b : interval&lt;/p&gt;

&lt;p&gt;Begin(), End() shike&lt;/p&gt;

&lt;p&gt;Before(a, b) =&amp;gt; End(a) &amp;lt; Begin(b)&lt;/p&gt;

&lt;p&gt;After(a, b) =&amp;gt; Begin(a) &amp;gt; End(b)&lt;/p&gt;

&lt;p&gt;Meet(a, b) =&amp;gt; End(a) = Begin(b)&lt;/p&gt;

&lt;p&gt;During(a, b) =&amp;gt; Begin(b) &amp;lt; Begin(a) &amp;lt; End(a) &amp;lt; End(b)&lt;/p&gt;

&lt;p&gt;Finishes(a, b) =&amp;gt; Begin(b) &amp;lt; Begin(a) &amp;lt; End(a) = End(b)&lt;/p&gt;

&lt;p&gt;Starts(a, b) =&amp;gt; Begin(b) = Begin(a) &amp;lt; End(a) &amp;lt; End(b)&lt;/p&gt;

&lt;p&gt;Equals(a, b) =&amp;gt; Begin(b) = Begin(a) &amp;amp;&amp;amp; End(a) = End(b)&lt;/p&gt;

&lt;p&gt;Overlap(a, b) =&amp;gt; Begin(a) &amp;lt; Begin(b) &amp;lt; End(a) &amp;lt; End(b)&lt;/p&gt;

</description>
        <pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/01/23/COMP23311-REV/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/01/23/COMP23311-REV/</guid>
        
        <category>2021</category>
        
        <category>课程笔记</category>
        
        
      </item>
    
      <item>
        <title>数据库导论 其他数据库</title>
        <description>&lt;h1 id=&quot;comp23111-revision-ch4&quot;&gt;COMP23111 REVISION Ch4&lt;/h1&gt;

&lt;h2 id=&quot;4-其他数据库&quot;&gt;4. 其他数据库&lt;/h2&gt;

&lt;p&gt;我们将在本章中对本课程涉及的其他三种非关系数据库进行介绍. 这种介绍基于功利性质, 主要信息来源为部分 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slides&lt;/code&gt; 内容 + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lab&lt;/code&gt; 内容, 并且逻辑结构可能极其混乱.&lt;/p&gt;

&lt;h3 id=&quot;41-非关系类型数据库-couchbase&quot;&gt;4.1 非关系类型数据库: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 是一种主要用于数据存储和缓存的, 分布式 &lt;strong&gt;非关系型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOSQL&lt;/code&gt;) 数据库.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 存储数据, 因其作为一种通用的数据传输格式具备高度的灵活性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flexibility&lt;/code&gt;)且具备良好的性能.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 的查询语言为 &lt;strong&gt;完整融合了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 的, **兼容 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL92&lt;/code&gt; 标准的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N1QL&lt;/code&gt;, 它 **使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 存储数据&lt;/strong&gt;, 而使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语法执行查询.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 同时支持两种满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACID&lt;/code&gt; 性质的数据库事务: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N1QL&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Key-Val&lt;/code&gt;, 其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N1QL&lt;/code&gt; 型数据库事务和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 中的数据库事务极其相似:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115190505.png&quot; alt=&quot;20220115190505&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 可用于构建 &lt;strong&gt;数据库&lt;/strong&gt;, &lt;strong&gt;搜索引擎&lt;/strong&gt;, &lt;strong&gt;键值对存储&lt;/strong&gt; 和 &lt;strong&gt;缓存&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;421-couchbase-中的键值对存储&quot;&gt;4.2.1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 中的键值对存储&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 同样支持数据库分划 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database Sharding&lt;/code&gt;). 其基本架构被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Master/Master&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Masterless&lt;/code&gt;, 细节为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 将最高数据库分划片数限制为 $1024$.&lt;/li&gt;
  &lt;li&gt;在数据被存入数据库中时, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRC32&lt;/code&gt; 算法对数据进行哈希, 并基于计算的哈希值自动将数据分配到某个存储在某个节点 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;) 的分划中 (这样的分划被称为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vBucket&lt;/code&gt;&lt;/strong&gt;), 从而确保数据基本均衡地被分划, 结构自然地被优化, 从而确保无需再人为地对数据库进行重分划.&lt;/li&gt;
  &lt;li&gt;在连接节点集群 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;) 查询数据时, 客户端会 &lt;strong&gt;预先下载完整的节点表&lt;/strong&gt;, 从而在查询数据时可以快速地确定 &lt;strong&gt;某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vBucket&lt;/code&gt; 被存储在集群中的哪个节点 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;, 物理机) 上&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 中的信息检索流程类似于:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;给定信息, 计算出其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRC32&lt;/code&gt; 哈希值.&lt;/li&gt;
  &lt;li&gt;基于计算的哈希值确定该信息 (如果确实存在数据库中的话) 位于哪个虚拟分划 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vBucket&lt;/code&gt;) 中.&lt;/li&gt;
  &lt;li&gt;基于预先下载和维护的节点表确定这个虚拟分划被集群 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;) 中的哪个节点 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;) 所存储.&lt;/li&gt;
  &lt;li&gt;直接向对应的节点发送数据查询请求.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;和常规的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Master/Slave&lt;/code&gt; 架构不同, 由于不存在中心节点, 因此在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 中不存在某个特定节点下线后导致 “牵一发而动全身” 的情况, 意味着它具有更好的健壮性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Robustness&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 将以文档 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Document&lt;/code&gt;) 为形式存储的数据置于 存储桶 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bucket&lt;/code&gt;) 中对它们进行分类和管理. 任何一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bucket&lt;/code&gt; 都承载多个 &lt;strong&gt;名为作用域 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scope&lt;/code&gt;) 的容器 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Container&lt;/code&gt;)&lt;/strong&gt;, 而 &lt;strong&gt;作用域同时承载名为集合 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection&lt;/code&gt;) 的容器&lt;/strong&gt;, 集合中 &lt;strong&gt;存储 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 文档&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;集合 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection&lt;/code&gt;) 是在存储桶 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bucket&lt;/code&gt;) 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 服务器上定义的数据容器. 每个集群 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;) 最多可以创建 $1000$ 个集合. 而所存储的项目名称在其所属的集合中必须是唯一的.&lt;/p&gt;

&lt;p&gt;作用域 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scope&lt;/code&gt;)是用于对多个集合进行分组的机制. 每个集群最多可以创建 $1000$ 个作用域. 集合名称在其作用域内必须是唯一的.&lt;/p&gt;

&lt;p&gt;文档 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Document&lt;/code&gt;) 是存储在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 中的数据点 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Datapoints&lt;/code&gt;). 它们由用来引用数据项的键和与键关联的数据值组成: 该值必须是二进制或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 文档.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 的文档存储结构与关系型数据库之间的类比如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220118142523.png&quot; alt=&quot;20220118142523&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;422-couchbase-中的数据建模&quot;&gt;4.2.2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 中的数据建模&lt;/h4&gt;

&lt;p&gt;相比关系数据库模式, 由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 作为存储方式且不对实体间复杂的关系建模, 因此对表结构的修改可以视为对新数据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 结构的修改, 同时:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只要表结构修改方式得当, 两种结构不完全相同的数据在库中可以共存.&lt;/li&gt;
  &lt;li&gt;此外, 我们也可以选择将库中现存的旧格式数据全部转换为新格式.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;43-couchbase-的-一些潜在考点&quot;&gt;4.3 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 的 一些潜在考点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;durability + cas:&lt;/p&gt;

    &lt;p&gt;类似于checksum, 或 “版本号”, 在对象被修改时同步改变, 反映该对象 (document) 的当前状态, 相当于metadata. cas: “COMPARE AND SWAP”. 在执行mutation时couchbase会检索app提供的文件的cas和服务器端的cas是否相同, 若相同才能允许mutation操作顺利执行.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;upsert:&lt;/p&gt;

    &lt;p&gt;used if want to overwrite a document with the same key in case it already exists.&lt;/p&gt;

    &lt;p&gt;if it doesn’t exist, a new doc will be created with the specified key.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Document Expiration:&lt;/p&gt;

    &lt;p&gt;在couchbase中可设定文件在一定时间后过期 (expire), 这个时限可在创建文件时被指定.一旦在数据库的定期cleanup process执行时或查询时发现任何文件过期了, 该文件就会被删除, couchbase server会maintain一个墓碑 (tombstone) 作为记录. 墓碑就是对任何已被删除的item的记录, 维护墓碑的作用是确保节点之间和集群之间的eventual consistency.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;index (索引)&lt;/p&gt;

    &lt;p&gt;是在couchbase中执行搜索操作所必须的. 正确创建文件的索引有助于提升数据库的性能.&lt;/p&gt;

    &lt;p&gt;index的类型: 主要看covering index: covering index是一种包含该索引所指向域中数据值的索引, 由此无需通过索引再去取值, 而是将索引中包含的数据直接使用, 有助于减少查询语句的消耗时间, 提升数据库性能. indexing是异步的.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sub-document operations&lt;/p&gt;

    &lt;p&gt;sub-document operations 可用于高效访问和修改数据的一部分: 只从数据库中提取出所需要被检索和改动的部分文件而非直接获取所有文件, 降低带宽要求减少性能浪费. sub-document operation是原子化的, 若一个sub-document mutation失败, 所有的都会失败.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N1QL的惰性原则 (Queries are executed lazily):&lt;/p&gt;

    &lt;p&gt;只在查询结果被处理的时候执行查询.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Place Holder:&lt;/p&gt;

    &lt;p&gt;占位符用来在查询 (query) 中指代那些我们希望被用变量代替的常量的位置.占位符有两种:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Positional Placeholder: use an ordinal placeholder for substitution&lt;/li&gt;
      &lt;li&gt;Named Parameter: use variables&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;named parameter是用来代替 WHERE, LIMIT, OFFSET 的占位符.&lt;/p&gt;

    &lt;p&gt;注: 二者的调用方式也有所不同:&lt;/p&gt;

    &lt;p&gt;Named parameters refer to the variables specified in the query while the positional parameters are always referred to by the order in which they are specified.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scan Consistency:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QueryScanConsistency.REQUEST_PLUS&lt;/code&gt; 被选择时查询解释器会花更多的时间进行查询, 但会返回确定是最新的结果.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OFFSET&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIMIT&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;使用 OFFSET/LIMIT 过滤返回的查询结果:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;LIMIT ==&amp;gt; 前 n个&lt;/li&gt;
      &lt;li&gt;OFFSET ==&amp;gt; 跳过前n个&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;如果二者同时出现, 效果是LIMIT先于OFFSET&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Aggregate Function:&lt;/p&gt;

    &lt;p&gt;Aggregate Function: 聚合函数. 只能在 SELECT, LETTING, HAVING, ORDER BY 语句里用上.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;42-图数据库-neo4j&quot;&gt;4.2 图数据库: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neo4j&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt; 不同, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neo4j&lt;/code&gt; 名为 “非关系数据库”, 其核心却在于使用 &lt;strong&gt;图&lt;/strong&gt; (网络) 将数据间的关系抽象化表示, 且数据建模以数据间的关系网络为主:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neo4j&lt;/code&gt; 是 &lt;strong&gt;开源&lt;/strong&gt; 的, &lt;strong&gt;图数据库&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neo4j&lt;/code&gt; 是基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JVM&lt;/code&gt; 的 &lt;strong&gt;非关系数据库&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neo4j&lt;/code&gt; 是具有管理多个数据库能力的数据库管理系统 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBMS&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;421-图数据库表示基础&quot;&gt;4.2.1 图数据库表示基础&lt;/h4&gt;

&lt;p&gt;在图数据库中, 数据被表示为存储在图 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Graph&lt;/code&gt;)中的 &lt;strong&gt;节点 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vertices&lt;/code&gt;)&lt;/strong&gt; , &lt;strong&gt;边 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vertices&lt;/code&gt;)&lt;/strong&gt; (一般表示关系) 和 &lt;strong&gt;属性&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;其中, 节点 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodes&lt;/code&gt;) 一般 &lt;strong&gt;作为实体的抽象&lt;/strong&gt;, 因而 &lt;strong&gt;节点可以具有属性&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;边&lt;/strong&gt; 连接两个节点, 一般作为 &lt;strong&gt;关系的抽象&lt;/strong&gt;, 需要注意 &lt;strong&gt;边也可以具备属性&lt;/strong&gt;. 但是, 任何边都 &lt;strong&gt;具备且仅具备一种关系属性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Relationship Type&lt;/code&gt;)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;举例而言: 考虑 &lt;strong&gt;关系类型&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTED_IN&lt;/code&gt;, 则在下图中有如下结论:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115195050.png&quot; alt=&quot;20220115195050&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;节点 “Person” 具备属性 “name”, 值为 “Leonard Nimoy”, 该节点为 &lt;strong&gt;源节点&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;节点 “Movie” 具备属性 “title” 和 ”released“, 值分别为 “Star Trek” 和 “2009”, 该节点为 &lt;strong&gt;目标节点&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;“Leonard Nimoy” 节点具有一个 &lt;strong&gt;传出关系&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Outgoing Relationship&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;“Star Trek 节点具有一个 &lt;strong&gt;传入关系&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Incoming Relationship&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然, 在某个图中遍历的行为可以被视作 &lt;strong&gt;沿着各种各样的关系遍历节点的行为&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在上面的例子中, 显然我们可以从 “Leonard Nimoy” 节点开始, 沿着关系 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTED_IN&lt;/code&gt; 遍历到目标节点上, 该遍历结果是标记为 “Star Trek” 的节点, 而返回值为一个长为 $1$ 的路径.&lt;/p&gt;

&lt;p&gt;长为 $0$ 的路径显然是最短路径, 它表示在该路径中只包含一个节点, 并且不包含任何关系.&lt;/p&gt;

&lt;p&gt;一般地, 节点名 &lt;strong&gt;首字母大写&lt;/strong&gt;, 关系类型名 &lt;strong&gt;全部大写&lt;/strong&gt;, 而属性名 &lt;strong&gt;全部小写&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;422-图数据库查询语言-cypher&quot;&gt;4.2.2 图数据库查询语言 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cypher&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neo4j&lt;/code&gt; 的查询语言是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cypher&lt;/code&gt;, 它基于 &lt;strong&gt;模式&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Patterns&lt;/code&gt;). 下面介绍它的基本语法:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;节点表示&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cypher&lt;/code&gt; 使用一对括号表示一个节点. 一般括号内需要含有节点名.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系表示&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cypher&lt;/code&gt; 使用一对间隔线 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt; 表示 &lt;strong&gt;无向关系&lt;/strong&gt;. 有向关系表示为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;--&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt;, 关系的属性用一对中括号包裹, 属性需位于两个间隔线之间, 如: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-[...]-&amp;gt;&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;节点创建&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CREATE (newnode) RETURN newnode&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系创建&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CREATE (a)-[r:NEWRELATIONSHIP]-&amp;gt;(b) RETURN a, b, r&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据删除&lt;/p&gt;

    &lt;p&gt;可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MATCH&lt;/code&gt; 语句删除数据:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MATCH (n) DETACH DELETE n&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建/更新数据&lt;/p&gt;

    &lt;p&gt;可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MERGE&lt;/code&gt; 语句创建或更新数据:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MATCH (a), (b) MERGE (a)-[r:RELATIONSHIP_TYPE]-&amp;gt;(b) SET r.property = ['value'] RETURN a,r,b&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;条件匹配&lt;/p&gt;

    &lt;p&gt;可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MATCH&lt;/code&gt; 语句基于 &lt;strong&gt;复杂条件语句&lt;/strong&gt; 搜索匹配:&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;MATCH&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;some&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;criteria&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;goes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;here&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MATCH&lt;/code&gt; 语句还可以在图中搜索满足给定模式的关系取得节点或节点的属性:&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;基于模式匹配取得节点&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;可以从两个方向搜索&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;方向&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--&amp;gt; b&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;MATCH&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RELATIONSHIP_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    
 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;方向&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--&amp;gt; a&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;MATCH&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RELATIONSHIP_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;可以直接取回节点的属性值&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;MATCH&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RELATIONSHIP_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RELATIONSHIP_TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;property&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;也可以使用内建的最短路径算法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shortestPath()&lt;/code&gt; 取得从给定节点之间的最短路径:&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;调用内建算法&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shortestPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;MATCH&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shortestPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bacon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;其中节点&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;被取别名&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`bacon', `&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;' 为另一个目标节点, 返回的是 `a'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;和&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`b' 之间的最短路径
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;423-slides部分内容摘抄&quot;&gt;4.2.3 Slides部分内容摘抄&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115201449.png&quot; alt=&quot;20220115201449&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115201504.png&quot; alt=&quot;20220115201504&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115201520.png&quot; alt=&quot;20220115201520&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115201533.png&quot; alt=&quot;20220115201533&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Centrality 中心度:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Degree Centrality: “度中心”: 度最大的节点&lt;/li&gt;
  &lt;li&gt;Closeness Centrality: 离得最近 (相隔边数最少) 的节点&lt;/li&gt;
  &lt;li&gt;Betweenness Centrality&lt;/li&gt;
  &lt;li&gt;Importance Centrality (Pagerank)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;43-数据搜索和分析-elasticsearch&quot;&gt;4.3 数据搜索和分析: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Elasticsearch&lt;/code&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query string query&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;You can use the query_string query to create a complex search that includes wildcard characters, searches across multiple fields, and more&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term string query&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;You can use the term query to find documents based on a precise value such as a price, a product ID, or a username.&lt;/p&gt;

    &lt;p&gt;Avoid using the term query for text fields: use match query instead.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wildcard query&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;不能查日期, 只能查text, keyword, wildcard fild&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;语句改错: 无脑
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H 'Content-Type: application/json'&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;架构类比:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220118211519.png&quot; alt=&quot;20220118211519&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正确语法:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;# 1. A correct curl command for creating a mapping for the index movie with the property year as date
# 注意 “-H 'Content-Type: application/json'”  非常重要!
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;curl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PUT&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'localhost:9200/movies'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'{&quot;mappings&quot;: {&quot;properties&quot; : {&quot;year&quot; : {&quot;type&quot;: &quot;date&quot;}}}}'&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# 2. check if the mapping for the index movies was created correctly
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;curl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XGET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9200&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;movies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_mapping&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# 3. import one document in the index movie
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;curl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PUT&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'localhost:9200/movies/_doc/109487?pretty'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'{&quot;genre&quot; : [&quot;IMAX&quot;,&quot;Sci-Fi&quot;],&quot;title&quot; : &quot;Interstellar&quot;,&quot;year&quot; : 2014}'&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# 4. How to import many documents in the index `movies':
# i. create a JSON file with correct context (make sure there's a new empty line at the end)
# ii. get the name and the location of that JSON file, for example &quot;/home/csimage/m2.json&quot;
# iii. execute the curl command:
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;curl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XPOST&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;localhost:9200/movies/_bulk?pretty&amp;amp;refresh&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Content-Type: application/x-ndjson&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;@/home/csimage/m2.json&quot;&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# 5. delete the document with identifier `58559'
# this time no &quot;-H 'Content-Type: application/json'&quot;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;curl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XDELETE&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'http://localhost:9200/movies/_doc/58559'&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220118145339.png&quot; alt=&quot;20220118145339&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220118145421.png&quot; alt=&quot;20220118145421&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl&lt;/code&gt; 常用语法 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;1、get请求&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  curl http://xxx.xxx.xxx.xxx:port/xxxxxxxx
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、post请求&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  curl -XPOST http://xxx.xxx.xxx.xxx:port/xxxxxxxx --data '{&quot;xxxx&quot; : &quot;xxxx&quot;,  &quot;xxxx&quot; : &quot;xxxxx&quot;}' -H &quot;Content-Type: application/json&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;-H表示自定义header (一般是: -H &quot;Content-Type: application/json&quot;)

--data表示body

-X表示请求方式
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3、put请求&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  curl -XPUT http://xxx.xxx.xxx.xxx:port/xxxxxxxx --data '{&quot;xxxx&quot; : &quot;xxxx&quot;,  &quot;xxxx&quot; : &quot;xxxxx&quot;}' -H &quot;Content-Type: application/json&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4、delete请求&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  curl -XDELETE http://xxx.xxx.xxx.xxx:port/xxxxxxxx --data '{&quot;xxxx&quot; : &quot;xxxx&quot;,  &quot;xxxx&quot; : &quot;xxxxx&quot;}' -H &quot;Content-Type: application/json&quot; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;REFERENCE:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/to-here/p/12525558.html&quot;&gt;curl常用语法举例&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/01/14/COMP23111-REV-Ch4/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/01/14/COMP23111-REV-Ch4/</guid>
        
        <category>2021</category>
        
        <category>COMP23111</category>
        
        
      </item>
    
      <item>
        <title>数据库导论 关系数据库实现</title>
        <description>&lt;h1 id=&quot;comp23111-revision-ch3&quot;&gt;COMP23111 REVISION Ch3&lt;/h1&gt;

&lt;h2 id=&quot;3-数据库实现&quot;&gt;3. 数据库实现&lt;/h2&gt;

&lt;p&gt;本节讨论 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句和部分高级功能, 并介绍 &lt;strong&gt;数据库事务&lt;/strong&gt; 的概念和其处理方式.&lt;/p&gt;

&lt;h3 id=&quot;31-sql-基础&quot;&gt;3.1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 基础&lt;/h3&gt;

&lt;h4 id=&quot;311-选择运算-selection&quot;&gt;3.1.1 选择运算: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECTION&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 语句用于从一个关系中选出 &lt;strong&gt;满足选择条件&lt;/strong&gt; 的元组的一个子集, 我们可以将其视为一个 &lt;strong&gt;过滤器&lt;/strong&gt;. 如果将一个关系视为一张表, 则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 操作相当于从这张表中按照条件选出一些行, 而丢弃另外一些行.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;column1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;column2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以及&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 语句查询一个或多个属性, 并且可在语句中对属性进行数值运算:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_USER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外, 可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT-WHERE&lt;/code&gt; 执行 &lt;strong&gt;条件查询&lt;/strong&gt;, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 子句中使用下列的运算符:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113222029.png&quot; alt=&quot;20220113222029&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及使用 &lt;strong&gt;与条件&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BETWEEN&lt;/code&gt;) :&lt;/p&gt;

&lt;p&gt;(查询&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; T_USER&lt;/code&gt; 表中成绩大于等于 $60$ 分且小于等于 $80$ 分的学生)&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_USER&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_USER&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;strong&gt;或条件&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;查询分数大于&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;分或者小于&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;分的记录&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;用&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_USER&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;查询成绩为&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;98&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的学生&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;用&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_USER&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_score&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;98&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;strong&gt;非条件&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!=&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;写法&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_USER&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`Axton Yao`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;写法&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T_USER&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIKE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`Ryan Xin`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果需要的话还可以为列名称和表名称指定别名:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`ID`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`StudentID`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`Name`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`StudentName`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`Students`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在一些情况下, 我们可能希望从表中选取 &lt;strong&gt;不重复&lt;/strong&gt; 的数据. 我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DISTINCT&lt;/code&gt; 关键词:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Company&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;312-投影运算-projection&quot;&gt;3.1.2 投影运算: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PROJECTION&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 不同, 投影操作可以视为从表中 &lt;strong&gt;选出某些列&lt;/strong&gt; 而 &lt;strong&gt;丢弃某些列&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 语句从表中选出特定列作为表的 &lt;strong&gt;投影&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113223058.png&quot; alt=&quot;20220113223058&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;313-修改运算-alterupdate&quot;&gt;3.1.3 修改运算: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALTER/UPDATE&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALTER&lt;/code&gt; 语句在 &lt;strong&gt;已有的表中&lt;/strong&gt; 增/删表中属性, 修改属性的域, 修改属性名, 修改表名, 增/删主键:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在表中添加/删除列:
    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;添加&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;删除&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COLUMN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;修改属性域 (列的数据类型):
    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COLUMN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;修改属性名 (列名):
    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;CHANGE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COLUMN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;columm_name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_name&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;修改表名:
    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;RENAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_name&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;增/删主键:
    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;删主键&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;增主键&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CONSTRAINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pk_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 语句用于修改表中的数据:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;表名称&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;列名称&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;新值&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;列名称&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;某值&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;314-联合查询-union&quot;&gt;3.1.4 联合查询: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt; 子句求两个不同表中两列的重复元素, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt; 的作用是将 &lt;strong&gt;两个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 语句的查询结果&lt;/strong&gt; 作为一个 &lt;strong&gt;整体&lt;/strong&gt; 展示出来.&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt; 必须确保各个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 集合的结果的 &lt;strong&gt;列数必须相同&lt;/strong&gt;, 且每个对应列的 &lt;strong&gt;数据类型必须相同&lt;/strong&gt;, 但 &lt;strong&gt;列名可以不同&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113223855.png&quot; alt=&quot;20220113223855&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION&lt;/code&gt; 执行的是对两个结果集的 &lt;strong&gt;并集&lt;/strong&gt; 操作, &lt;strong&gt;会筛选掉重复记录&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;315-笛卡尔积运算-cartesian-product&quot;&gt;3.1.5 笛卡尔积运算: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CARTESIAN PRODUCT&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;笛卡尔积可以视为对关系的 &lt;strong&gt;乘法&lt;/strong&gt;, 它的效果是将 &lt;strong&gt;分别来自两个数据集合中的行&lt;/strong&gt; 以 &lt;strong&gt;所有可能的方式&lt;/strong&gt; 进行组合.&lt;/p&gt;

&lt;p&gt;我们可以使用下列两种方式执行笛卡尔积:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CROSS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;本质是第一种写法的语法糖&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114111921.png&quot; alt=&quot;20220114111921&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114112045.png&quot; alt=&quot;20220114112045&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;316-连接运算-join&quot;&gt;3.1.6 连接运算: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JOIN&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;连接&lt;/strong&gt; 运算可以视为 &lt;strong&gt;在水平方向上&lt;/strong&gt; 对两个表的 &lt;strong&gt;合并&lt;/strong&gt;, 其基本方法是: 将两个表中在共同数据项上相匹配的那些行合并.&lt;/p&gt;

&lt;p&gt;连接运算本质是由 &lt;strong&gt;一个笛卡尔积运算&lt;/strong&gt; 和 &lt;strong&gt;一个选取运算&lt;/strong&gt; 所构成的:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先用一个笛卡尔积完成对两个数据集合的乘法, 生成的结果集合包含两个数据集合中所有行的, 所有可能的组合.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后对生成的结果集合进行 &lt;strong&gt;选取运算&lt;/strong&gt; , 确保只把 &lt;strong&gt;分别来自两个数据集合&lt;/strong&gt; 并且 &lt;strong&gt;具有重叠部分&lt;/strong&gt; 的行所 &lt;strong&gt;合并在一起&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 提供的多种连接方式之间的区别在于: 它们&lt;strong&gt;在连接运算流程的第二步中&lt;/strong&gt; 从 &lt;strong&gt;相互交叠的不同数据集合&lt;/strong&gt; 中选取 &lt;strong&gt;用于连接的行&lt;/strong&gt; 时所采用的方法不同:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;连接类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;内连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INNER JOIN&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Theta 连接&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EQUI 连接&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自然连接&lt;/code&gt;, 只连接满足匹配条件的行, 展现出的是两表 &lt;strong&gt;共同&lt;/strong&gt; 的数据.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;左外连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LEFT JOIN&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;包含左边表中的全部行 (无论是否和右表匹配), 以及右边表中所有与左边表匹配的行.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;右外连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RIGHT JOIN&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;包含右边表中的全部行 (无论是否和左表匹配), 以及左边表中所有与右边表匹配的行.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;全外连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FULL JOIN&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;包含左右表的全部行, 不考虑匹配与否, 注意与交叉连接区分.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;交叉连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CROSS JOIN&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;生成笛卡尔积: 考虑数据集中任意行与另一数据集中任意行的两两组合.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面详细说明各种连接运算:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;内连接:&lt;/p&gt;

    &lt;p&gt;内连接展现的是两表 &lt;strong&gt;共同&lt;/strong&gt; 的数据.&lt;/p&gt;

    &lt;p&gt;内连接又因其匹配条件的不同而被区分为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Theta 连接&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EQUI 连接&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自然连接&lt;/code&gt;.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Theta 连接&lt;/code&gt; 是使用 &lt;strong&gt;等值以外的条件&lt;/strong&gt; (如大于等于, 小于等于, 不等于之类) 来匹配左右两表中行的内连接.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EQUI 连接&lt;/code&gt; 是使用 &lt;strong&gt;等值 (==) 条件&lt;/strong&gt; 来匹配左右两表中行的内连接.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自然连接&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 中一种预定义的内连接, 可以视为语法糖, 它在匹配左右两表好似 &lt;strong&gt;自动判断&lt;/strong&gt; 两表中相同名称的列, 而后形成匹配.&lt;/p&gt;

        &lt;p&gt;我们无法在自然连接中人为指定哪些列被用于匹配, 但用于指定查询结果包含哪些列.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Theta&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;连接的例子&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EQUI&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;连接的例子&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;注&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;上面的内连接相当于&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;axton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;自然连接的例子&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;NATURAL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table_2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外连接:&lt;/p&gt;

    &lt;p&gt;外连接不但返回符合连接和查询条件的数据行, 还 &lt;strong&gt;返回不符合条件的一些其他行&lt;/strong&gt;. 外连接分三类: 左连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LEFT JOIN&lt;/code&gt;, 右连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RIGHT JOIN&lt;/code&gt; 和完整外部连接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FULL JOIN&lt;/code&gt;:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;左连接除了返回两表中符合连接条件的数据行外, 还返回 &lt;strong&gt;左表中不符合连接条件但符合查询条件的数据行&lt;/strong&gt;.&lt;/p&gt;

        &lt;p&gt;如果左表的某行在右表中没有匹配行, 则将右表对应的行处返回 &lt;strong&gt;空值&lt;/strong&gt; 并与其连接.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;右连接除了返回两表中符合连接条件的数据行外, 还返回 &lt;strong&gt;右表中不符合连接条件但符合查询条件的数据行&lt;/strong&gt;.&lt;/p&gt;

        &lt;p&gt;如果右表的某行在左表中没有匹配行, 则将左表对应的行处返回 &lt;strong&gt;空值&lt;/strong&gt; 并与其连接.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;完整外部链接返回左表和右表中的所有行. 若某行在另一个表中没有匹配行, 则另一个表的对应列包含 &lt;strong&gt;空值&lt;/strong&gt;, 否则这一整行包含对应的数据值.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;左连接&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;以左表为主表&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;右表没数据则为&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Province&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShippingArea&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Province&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ShippingAreaID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;右连接&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;以右表为主表&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;左表没数据则为&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Province&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;RIGHT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShippingArea&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Province&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ShippingAreaID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;全外连接&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Province&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;FULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShippingArea&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Province&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ShippingAreaID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;32-sql-进阶&quot;&gt;3.2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 进阶&lt;/h3&gt;

&lt;h4 id=&quot;321-空值-null&quot;&gt;3.2.1 空值: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 中, 任何 &lt;strong&gt;未指定&lt;/strong&gt; 的数据值称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;, 它实际上应当被视为 &lt;strong&gt;一种状态&lt;/strong&gt; 而非属性的值:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114170013.png&quot; alt=&quot;20220114170013&quot; /&gt;&lt;/p&gt;

&lt;p&gt;属性在下列的情况下可能被视为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据值 &lt;strong&gt;未知&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;数据值 &lt;strong&gt;不可取得&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;数据值 &lt;strong&gt;被隐藏&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;数据值 &lt;strong&gt;不适用&lt;/strong&gt; (坦白说我也没搞懂不适用是什么意思)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;是独立于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; 之外的. 执行逻辑运算时需要遵循下列的 &lt;strong&gt;三值逻辑&lt;/strong&gt; 规则:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114172714.png&quot; alt=&quot;20220114172714&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意, 我们不可使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; 检测某个参数是否为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;. 要进行这样的检测, 需要使用关键字 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IS&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;返回的查询结果为空&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VIPs&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;返回的查询结果是正常的&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VIPs&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flat&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;322-排序-取极值-求和与计数&quot;&gt;3.2.2 排序, 取极值, 求和与计数&lt;/h4&gt;

&lt;p&gt;我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORDER BY&lt;/code&gt; 语句对查询的结果集进行 &lt;strong&gt;排序&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;默认按照升序对记录进行排序&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col_2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;如果需要按照降序排序记录&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;需要使用&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;关键字&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col_2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORDER BY&lt;/code&gt; 子句可 &lt;strong&gt;同时使用多个列&lt;/strong&gt; 作为排序条件, 但是必须确保 &lt;strong&gt;作为排序条件的每个列都在表中存在&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIN()&lt;/code&gt; 取表中数据列的 &lt;strong&gt;极值&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;取极大值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;取极小值&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM()&lt;/code&gt; 函数返回 &lt;strong&gt;数值列的总数&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COUNT()&lt;/code&gt; 函数返回 &lt;strong&gt;查询结果某一列项的数目&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;若考虑重复结果&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;若要求不重复结果的数目&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;323-聚合函数-group-by&quot;&gt;3.2.3 聚合函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;聚合函数/集合函数 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COUNT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVG&lt;/code&gt;) 往往需要搭配 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 语句. 它用于 &lt;strong&gt;结合合计函数&lt;/strong&gt;, 根据 &lt;strong&gt;一个或多个列&lt;/strong&gt; 对结果集进行分组:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aggregate_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对聚合函数的理解如下: 考虑表&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114182133.png&quot; alt=&quot;20220114182133&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`name`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'test'&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`name`&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;则其查询结果的生成过程可视为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先 “执行” 语句中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROM 'test'&lt;/code&gt; 得到一张和原表一模一样的新表.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后在这张表上执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 语句进行聚合分组, 在本例中需要基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 进行分组, 显然分组依据是将所有在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 属性相同的行全部 “合并”, 此时执行结果是这样的一个虚拟的表:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114182424.png&quot; alt=&quot;20220114182424&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接下来才需要对这个虚拟表执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 后面的语句 (在此处是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;).&lt;/p&gt;

    &lt;p&gt;在这个例子中, 由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 列被用于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt;, 因此该列必然不存在重复值, 所以简单执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT name&lt;/code&gt; 就不会出错.&lt;/p&gt;

    &lt;p&gt;但如果我们需要选择那些在虚拟表中有多个数据的单元格, 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;number&lt;/code&gt;, 就不能直接选择它们, 而需要使用 &lt;strong&gt;以多个数据作为输入, 输出单个数据的&lt;/strong&gt; 聚合函数, 将这些多数据的单元格作为输入.&lt;/p&gt;

    &lt;p&gt;假如我们执行了&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;则结果就是在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;虚拟表3&lt;/code&gt; 的基础上, 对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;number&lt;/code&gt; 列的每个单元格都执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUM()&lt;/code&gt; 聚合函数, 返回的表就是&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114183114.png&quot; alt=&quot;20220114183114&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注: 对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 多个字段的情况, 我们只需要将作为聚合分组依据的多个字段 &lt;strong&gt;视为整体字段&lt;/strong&gt; 即可.&lt;/p&gt;

&lt;p&gt;需要注意的是, 用于对表进行筛选的关键字 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 无法和聚合函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 一起使用. 我们需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HAVING&lt;/code&gt; 子句:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aggregate_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;HAVING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aggregate_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HAVING&lt;/code&gt; 子句的作用是 &lt;strong&gt;筛选满足条件的组&lt;/strong&gt;, 在 &lt;strong&gt;分组之后&lt;/strong&gt; 过滤数据, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 搜索条件在 &lt;strong&gt;执行分组操作前&lt;/strong&gt; 应用.&lt;/p&gt;

&lt;p&gt;注:&lt;/p&gt;

&lt;p&gt;在语句中 &lt;strong&gt;同时含有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HAVING&lt;/code&gt;子句和聚合函数&lt;/strong&gt; 时, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句的执行顺序如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 子句查找符合条件的数据.&lt;/li&gt;
  &lt;li&gt;执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 子句对数据进行分组, 并对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 子句执行形成的组运行聚集函数从而计算对应的值.&lt;/li&gt;
  &lt;li&gt;最后执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HAVING&lt;/code&gt; 子句: 基于第二步中聚集函数的运算结果, 过滤掉不符合条件的组.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HAVING&lt;/code&gt; 子句和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 子句都可以让查询结果满足一定的条件限制, 但 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 子句中限定的是 &lt;strong&gt;行&lt;/strong&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HAVING&lt;/code&gt; 子句中限定的是 &lt;strong&gt;组&lt;/strong&gt;, 由此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 子句中 &lt;strong&gt;不能使用聚集函数&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;324-嵌套查询语句&quot;&gt;3.2.4 嵌套查询语句&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;嵌套查询&lt;/strong&gt; 指某个查询语句可以 &lt;strong&gt;嵌套&lt;/strong&gt; 在另外一个查询语句的 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 子句&lt;/strong&gt; 中. 我们称外层的查询为 &lt;strong&gt;主查询&lt;/strong&gt;, 而内层的查询为 &lt;strong&gt;从查询&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在执行含嵌套查询的语句时, 其语句的方向是 &lt;strong&gt;由内向外&lt;/strong&gt; 的: 首先进行内层查询, 而外层查询 &lt;strong&gt;利用内层查询的结果集&lt;/strong&gt; 作为条件进行查询.&lt;/p&gt;

&lt;p&gt;如果子查询返回的结果是 &lt;strong&gt;单个值&lt;/strong&gt;, 则它可以在任何涉及到表达式的地方作为常量使用.&lt;/p&gt;

&lt;p&gt;若某个表只出现在子查询中而不在外查询中, 则该表的列 &lt;strong&gt;无法包含在输出中&lt;/strong&gt; (要想提取出子查询的结果集中的数据, 就只能依靠外层查询中的相关语句).&lt;/p&gt;

&lt;p&gt;嵌套查询主要分为下列三类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;简单子查询
若子查询的结果是 &lt;strong&gt;单个值&lt;/strong&gt;, 则这样的查询为 &lt;strong&gt;简单子查询&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt; 嵌套查询
若查询的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 语句内包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt; 关键字 (用于判断查询的表达式是否在多个值的列表中), 则该查询为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt; 嵌套查询&lt;/strong&gt;:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOME&lt;/code&gt; 嵌套查询
若查询的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 语句内包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOME&lt;/code&gt; 关键字 (用于判断查询的表达式是否满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOME&lt;/code&gt; 后的某一个条件), 则该查询为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOME&lt;/code&gt; 嵌套查询&lt;/strong&gt;:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; 嵌套查询
若查询的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 语句内包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; 关键字 (用于判断查询的表达式是否满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; 后的全部条件), 则该查询为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL&lt;/code&gt; 嵌套查询&lt;/strong&gt;:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXISTS&lt;/code&gt; 嵌套查询
若查询的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt; 语句内包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXISTS&lt;/code&gt; 关键字 (用于判断子查询是否返回了结果集), 则该查询为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXISTS&lt;/code&gt; 嵌套查询&lt;/strong&gt;:&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;如果不存在&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Person_Id&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的记录&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;则子查询没有结果集返回&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;主语句不执行&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; 
     &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person_Id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;114514&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;嵌套查询&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;country&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'下北沢'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;嵌套查询&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;country&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'下北沢'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;嵌套查询&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NAME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;country&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countryname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'下北沢'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;325-视图&quot;&gt;3.2.5 视图&lt;/h4&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 中, &lt;strong&gt;视图&lt;/strong&gt; 是基于 &lt;strong&gt;查询结果&lt;/strong&gt; 的, 可视化的表. 它包含行和列, 且字段实际上来自于被查询的一个或多个数据库中真实存在的表中.&lt;/p&gt;

&lt;p&gt;我们可以根据需要向视图中添加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 函数和语句, 视图中的函数和语句不会影响被查询数据库的设计和结构.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;创建&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;语法&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;在创建后我们可以像查表一样查询这个&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;中的数据&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;视图可以被更新&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REPLACE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view_name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table_name&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;也可以被撤销&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SQL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Syntax&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view_name&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;326-存储过程&quot;&gt;3.2.6 存储过程&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;存储过程&lt;/strong&gt; 本质是一段 &lt;strong&gt;预先编译好, 可供复用&lt;/strong&gt; 的声明式 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句需要 &lt;strong&gt;先编译然后执行&lt;/strong&gt;, 而存储过程(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stored Procedure&lt;/code&gt;) 是一组 &lt;strong&gt;经编译后&lt;/strong&gt; 存储在数据库中, 可完成特定功能的 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句集&lt;/strong&gt;, 可通过指定存储过程的名字并给定参数 (若它含有参数) 来调用执行.&lt;/p&gt;

&lt;p&gt;存储过程的实质是 &lt;strong&gt;函数&lt;/strong&gt;, 由 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt;语句&lt;/strong&gt; 和 &lt;strong&gt;控制结构&lt;/strong&gt; 组成. 数据库中的存储过程可以看做是对编程中面向对象方法的模拟, 它允许我们控制数据的访问方式.&lt;/p&gt;

&lt;p&gt;存储过程的优点包括:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;增强 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语言的功能和灵活性.&lt;/li&gt;
  &lt;li&gt;可增强 &lt;strong&gt;可复用性&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;由于已经预先编译, 因此存储过程具有 &lt;strong&gt;较快的执行速度&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;针对数据库对象的操作可以被简化为 &lt;strong&gt;对某个存储过程的调用语句&lt;/strong&gt;, 从而在传输 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 指令时 &lt;strong&gt;减少对网络带宽的消耗&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;可以通过 &lt;strong&gt;限制执行某个存储过程的权限&lt;/strong&gt; 实现对相应数据 &lt;strong&gt;访问权限的控制&lt;/strong&gt;, 提升 &lt;strong&gt;数据安全性&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;存储过程的创建语法形如:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;DELIMITER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PROCEDURE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;OUT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;INOUT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;BEGIN&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;DELIMITER&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其删除语法为:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PROCEDURE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQL&lt;/code&gt; 默认以 “;” 为分隔符, 若未声明分割符, 则编译器会把存储过程视为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句, &lt;strong&gt;因此编译过程会报错&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此, 要事先用 “DELIMITER //” 声明作为 &lt;strong&gt;前段分隔符&lt;/strong&gt;, 让编译器把两个 “//” 之间的内容视为 &lt;strong&gt;存储过程的代码&lt;/strong&gt;, 从而避免执行它们. 最后一行 “DELIMITER ;” 的作用是把 &lt;strong&gt;分隔符还原&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;根据需要, 存储过程可能会有 &lt;strong&gt;输入 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt;)&lt;/strong&gt;, &lt;strong&gt;输出 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OUT&lt;/code&gt;)&lt;/strong&gt; 或 &lt;strong&gt;既作为输入又作为输出 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INOUT&lt;/code&gt;)&lt;/strong&gt; 的参数:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IN&lt;/code&gt; 参数的值必须在调用存储过程时指定, 在存储过程中修改该参数的值不能被返回.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OUT&lt;/code&gt; 参数的值可在存储过程内部被改变, 并可返回.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INOUT&lt;/code&gt; 参数的值在调用时指定, 并且可被改变和返回.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们还可在存储过程中 &lt;strong&gt;定义并赋值局部变量&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114202020.png&quot; alt=&quot;20220114202020&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;DELIMITER&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PROCEDURE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetTotalOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;BEGIN&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;声明变量时需要同时指定其名称&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;数据类型&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;默认值&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;DECLARE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalOrder&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

        &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalOrder&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 可使用 INTO 将查询的结果赋值给变量&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;totalOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;DELIMITER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;CALL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetTotalOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;-- 调用所定义的存储过程&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意: 存储过程在数据库中是经过 &lt;strong&gt;预编译&lt;/strong&gt; 后被存储在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;information_schema&lt;/code&gt; &lt;strong&gt;库&lt;/strong&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;routines&lt;/code&gt; &lt;strong&gt;表&lt;/strong&gt; 中的. 我们可以使用下列命令查询数据库中的所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stored Procedure&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;在本课程中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slides&lt;/code&gt; 里出现了在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stored Procedure&lt;/code&gt; 中定义和使用 &lt;strong&gt;局部变量&lt;/strong&gt; 以及 &lt;strong&gt;直接使用用户变量&lt;/strong&gt; 的例子. 此处简单说明 &lt;strong&gt;局部变量&lt;/strong&gt; 和 &lt;strong&gt;用户变量&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户变量可以 &lt;strong&gt;直接使用&lt;/strong&gt;, 形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@var&lt;/code&gt;. 其有效生命周期在 &lt;strong&gt;单次数据库连接&lt;/strong&gt; 中, 断开连接时变量消失.&lt;/li&gt;
  &lt;li&gt;局部变量需要 &lt;strong&gt;先定义, 后使用&lt;/strong&gt;, 定义时必须 &lt;strong&gt;声明变量名和数据类型&lt;/strong&gt;, 其有效生命周期在函数或存储过程的作用域中.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`routine_name`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`information_schema`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`routines`&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`routine.type`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`PROCEDURE`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`routine_schema`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`classicmodels`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外, 我们可以在存储过程中应用 &lt;strong&gt;条件函数体&lt;/strong&gt;, &lt;strong&gt;循环函数体&lt;/strong&gt; 等控制语句:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114202514.png&quot; alt=&quot;20220114202514&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;使用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;条件语句的存储过程样例&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PROCEDURE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetCustomerLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pCustomerNumber&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;OUT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pCustomerLevel&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;BEGIN&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;DECLARE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;credit&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;DECIMAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creditLimit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;credit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customers&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customerNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pCustomerNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;credit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pCustomerLevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'PLATINUM'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;使用&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;条件语句的存储过程片段样例&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;注意对默认情形&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;的声明&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;customerCountry&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'USA'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pShipping&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2-day Shipping'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;WHEN&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Canada'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;THEN&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pShipping&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'3-day Shipping'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;ELSE&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pShipping&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'5-day Shipping'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以在存储过程中定义 &lt;strong&gt;游标&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cursor&lt;/code&gt;), 它是使我们能够在存储过程中对查询得到的表中的数据 &lt;strong&gt;逐行处理&lt;/strong&gt; 的工具.&lt;/p&gt;

&lt;p&gt;游标的一般使用方法是: 声明游标 - 打开游标 - 取出结果 - 关闭游标.&lt;/p&gt;

&lt;p&gt;我们一般用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FOR&lt;/code&gt; 循环操作游标.&lt;/p&gt;

&lt;p&gt;注意; 游标具备下列的性质:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只读: 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MySQL&lt;/code&gt; 中我们只能使用游标 &lt;strong&gt;遍历访问表的每一行&lt;/strong&gt;, 而不能对这一行的数据进行修改.&lt;/li&gt;
  &lt;li&gt;不可滚动: 游标只能 &lt;strong&gt;逐行地&lt;/strong&gt; 遍历表, 不可跳过任意一行.&lt;/li&gt;
  &lt;li&gt;数据敏感: 游标所访问的是数据表本身而非表的某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;, 若游标指向的表中的某个数据被修改, 则该修改会立刻体现在游标提出的数据上.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(实在是写不下去了, 游标剩下的部分不写了, 开摆!)&lt;/p&gt;

&lt;h4 id=&quot;327-触发器&quot;&gt;3.2.7 触发器&lt;/h4&gt;

&lt;p&gt;触发器的实质是一段预先存储的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 程序, 在监听到发生对应的数据库操作 (如插入, 表更新和表删除) 时会被唤起调用 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Invoked&lt;/code&gt;), 一般在 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 查询执行前或执行后&lt;/strong&gt; 运行.&lt;/p&gt;

&lt;p&gt;同时, 触发器也可被编程于执行 &lt;strong&gt;计划任务&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheduled Tasks&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;由于其先天具备 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Watchdog&lt;/code&gt; 的特性, 触发器常被用于检验和审核数据库中执行的操作, 维护数据库的完整性, 避免异常发生.&lt;/p&gt;

&lt;p&gt;触发器的创建语法如下:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TRIGGER&lt;/span&gt; 
    &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;标识触发器名称&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;用户自行指定&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;trigger_name&lt;/span&gt;

    &lt;span class=&quot;err&quot;&gt;标识触发时机&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;取值为&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BEFORE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;或&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AFTER&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;trigger_time&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;标识触发事件&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;取值为&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;或&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;；&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;trigger_event&lt;/span&gt; 

&lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tbl_name&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 标识建立触发器的表名, 即在哪张表上建立触发器.&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ROW&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;BEGIN&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;trigger_stmt&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;-- 触发器程序体, 可以是一句SQL语句, 或者由 BEGIN 和 END 包络的语句段.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;触发器的信息查询和删除如下:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;查询触发器信息&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRIGGERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;删除某个触发器&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TRIGGER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trigger_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;和存储过程类似, 为了避免 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 将在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BEGIN&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;END&lt;/code&gt; 间, 每一行由分号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;&lt;/code&gt; 结束的语句段错误解析导致触发器被视为不完整的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 语句, 需要使用分隔符 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELIMITER&lt;/code&gt; 标记整个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trigger&lt;/code&gt; 语句段.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触发器一般被分为三类:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;INSERT 型触发器&lt;/p&gt;

        &lt;p&gt;插入某一行时激活触发器, 可能通过 INSERT, LOAD DATA, REPLACE 语句触发.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;UPDATE 型触发器&lt;/p&gt;

        &lt;p&gt;更改某一行时激活触发器, 可能通过 UPDATE 语句触发.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DELETE 型触发器&lt;/p&gt;

        &lt;p&gt;删除某一行时激活触发器, 可能通过 DELETE, REPLACE 语句触发.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT&lt;/code&gt; 型触发器中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEW&lt;/code&gt; 用来表示将要(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BEFORE&lt;/code&gt;) 或已经 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AFTER&lt;/code&gt;) 插入的新数据.&lt;/p&gt;

    &lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt; 型触发器中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OLD&lt;/code&gt; 用来表示将要或已经被修改的原数据, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEW&lt;/code&gt; 用来表示将要或已经修改为的新数据.&lt;/p&gt;

    &lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt; 型触发器中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OLD&lt;/code&gt; 用来表示将要或已经被删除的原数据.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FOLLOWS&lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PRECEDES&lt;/code&gt; 实现触发器的 &lt;strong&gt;菊链式调用&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FOLLOWS&lt;/code&gt; 允许新触发器在旧的触发器 &lt;strong&gt;执行完成后&lt;/strong&gt; 被激活.&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PRECEDES&lt;/code&gt; 允许新触发器在旧的触发器 &lt;strong&gt;执行之前&lt;/strong&gt; 被激活.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们也可以对触发器进行编程, 令其在被激活时调用某个 &lt;strong&gt;存储过程&lt;/strong&gt;.&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TRIGGER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before_accounts_update&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;BEFORE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accounts&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EACH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ROW&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;BEGIN&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;CALL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CheckWithdrawal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; 
             &lt;span class=&quot;k&quot;&gt;OLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accountId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
             &lt;span class=&quot;k&quot;&gt;OLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NEW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; 
         &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;33-数据库事务的概念和处理&quot;&gt;3.3 数据库事务的概念和处理&lt;/h3&gt;

&lt;p&gt;数据库事务是 &lt;strong&gt;构成某个单一逻辑单元&lt;/strong&gt; 的 &lt;strong&gt;一系列操作&lt;/strong&gt; 组成的 &lt;strong&gt;集合&lt;/strong&gt;. 一个典型的数据库事务形如:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;BEGIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRANSACTION&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;某个事务的开始&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sql_clause_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sql_clause_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sql_clause_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COMMIT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ROLLBACK&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;事务执行完毕&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;提交对数据库进行的修改或回滚至原来的状态&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据库事务中包括的一条或多条数据库操作构成了一个 &lt;strong&gt;逻辑上的整体&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;由于它们在逻辑上被组织成一个整体, 这些数据库操作要么 &lt;strong&gt;全部成功&lt;/strong&gt;, 要么 &lt;strong&gt;全部不执行&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;构成数据库事务的所有操作要么 &lt;strong&gt;全部对数据库产生影响&lt;/strong&gt;, 要么 &lt;strong&gt;全都不产生影响&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;上述性质恒成立, 无论数据库是否出现故障或是否存在并发事务.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务的执行过程可以被简化为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115113609.png&quot; alt=&quot;20220115113609&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;系统为每个事务开辟一个 &lt;strong&gt;私有的缓冲区&lt;/strong&gt; .&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事务读操作&lt;/strong&gt; 将数据从主存中复制到缓冲区内.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事务写操作&lt;/strong&gt; 修改缓冲区内的数据.&lt;/li&gt;
  &lt;li&gt;若执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMMIT&lt;/code&gt; (提交), 则缓冲区内的数据 &lt;strong&gt;覆盖主存中的对应原版&lt;/strong&gt; .&lt;/li&gt;
  &lt;li&gt;若执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROLLBACK&lt;/code&gt; (回滚), 则 &lt;strong&gt;缓冲区内的数据被丢弃&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了确保关键操作的必然可靠性, 数据库事务的存在是必要的. 考虑下列的例子:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Axton&lt;/code&gt; 给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derek&lt;/code&gt; 转账 $114514$ 元, 这个操作在形式上显然是一个单一的操作, 但在银行的数据库系统中会被至少 &lt;strong&gt;拆分为两个步骤&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Axton&lt;/code&gt; 的账户余额减少 $114514$ 元.&lt;/li&gt;
  &lt;li&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derek&lt;/code&gt; 的账户余额增加 $114514$ 元.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而显然在这两个单独的过程中可能会出现下列的问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一步执行成功, 但第二步执行失败或系统在执行第二步之前突然崩溃, 由此导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derek&lt;/code&gt; 并没有成功收款.&lt;/li&gt;
  &lt;li&gt;系统在第二步刚刚执行成功时崩溃, 而重启时崩溃前的转账记录丢失.&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Axton&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derek&lt;/code&gt; 转账的同时, 还有多人也在向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derek&lt;/code&gt; 转账, 由此导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derek&lt;/code&gt; 的账户余额出现异常.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中, 我们一般称第二类 &lt;strong&gt;导致对数据库执行的修改丢失&lt;/strong&gt; 的问题为 &lt;strong&gt;暂更新问题&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Temporary Update Problem&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115111918.png&quot; alt=&quot;20220115111918&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而称第三类 &lt;strong&gt;导致对数据的更新异常的&lt;/strong&gt; 问题为 &lt;strong&gt;丢更新问题&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lost Update Problem&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115111602.png&quot; alt=&quot;20220115111602&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而若将上述的转账流程涉及的所有操作包含在同一个数据库事务中, 则会:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;若数据库操作失败或系统崩溃, 系统能够 &lt;strong&gt;以事务为单位进行数据恢复&lt;/strong&gt; , 从而避免了第一, 二类问题;&lt;/li&gt;
  &lt;li&gt;若有多个用户同时操作数据库, 数据库能够 &lt;strong&gt;以事务为单位进行并发控制&lt;/strong&gt;, 从而将多个转账操作进行隔离, 避免了第三类问题.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了实现对上述问题的预防和避免, 数据库事务需要具备所谓的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACID&lt;/code&gt; 特性:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A: Atomicity&lt;/code&gt; 原子性:&lt;/p&gt;

    &lt;p&gt;事务中的所有操作要作为一个整体, 如同原子一般不可再分: 要么全部执行成功, 要么全部执行失败.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C: Consistency&lt;/code&gt; 一致性:&lt;/p&gt;

    &lt;p&gt;事务的执行结果必须使数据库 &lt;strong&gt;从某个一致性状态&lt;/strong&gt; 转化到 &lt;strong&gt;另一个一致性状态&lt;/strong&gt;. 而一致性状态指:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;满足 &lt;strong&gt;数据库的完整性约束&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;正常反映数据库所描述的现实世界的真实状态, 如转账前后两个账户的金额总和需保持不变.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I: Isolation&lt;/code&gt; 隔离性:&lt;/p&gt;

    &lt;p&gt;并发执行的事务被彼此隔离, 不会相互影响: 它们对数据库的影响和它们一个接一个地串行执行时相同.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D: Durability&lt;/code&gt; 持久性:&lt;/p&gt;

    &lt;p&gt;事务一旦提交, 它对数据库的更新就是 &lt;strong&gt;持久的&lt;/strong&gt;, 任何故障和意外事件都不会导致数据丢失.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACID&lt;/code&gt; 特性中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt;, 数据库一致性, 是 &lt;strong&gt;事务的根本追求&lt;/strong&gt;. 一般地, 对一致性的破坏主要来源于事务的并发执行或事务/系统故障. 在本课程中, 我们只关心防止并发执行破坏数据库一致性的基本原理和方法:&lt;/p&gt;

&lt;p&gt;在并发执行数据库事务时, 必须通过 &lt;strong&gt;调度&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scheduling&lt;/code&gt;) 解除不同并发执行的事务之间可能造成的冲突, 否则就会出现各种异常, 破坏事务间的隔离性, 影响数据库的一致性.&lt;/p&gt;

&lt;p&gt;一般来说, 异常被分为下列四种:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lost Update&lt;/code&gt; 丢更新异常&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Temporary Update&lt;/code&gt; 暂更新异常&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dirty Write&lt;/code&gt; 脏写异常&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在本课程中, 我们介绍了前两种异常:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lost Update&lt;/code&gt; 丢更新异常的成因是: 在某个调度中, 事务 $T_1$, $T_2$ 读入相同的数据值 $X$, 进行不同的计算, 并先后修改并提交对 $X$ 的改动. 则此时后提交的事务会将先提交的事务对 $X$ 进行的修改覆盖掉.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220118113543.png&quot; alt=&quot;20220118113543&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Temporary Update&lt;/code&gt; 暂更新异常的成因是: 在某个调度中两个数据库事务共享一片 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database Buffer&lt;/code&gt;, 对同一个数据进行读写操作.&lt;/p&gt;

&lt;p&gt;若第一个事务 $T_1$ 对 数据 $X$ 的修改 &lt;strong&gt;被第二个事务 $T_2$ 读取, 进一步修改并提交&lt;/strong&gt;, 而 $T_1$ 所做更改在 $T_2$ 读取了 $X$ 后回滚, 则会出现 “$T_2$ 读取了本不该出现的, 被 $T_1$ 修改过的数据” 的情况.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220118113325.png&quot; alt=&quot;20220118113325&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt; (调度, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Schedule&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;调度&lt;/strong&gt; 定义为对数据库不同事务中语句的 &lt;strong&gt;交错穿插安排&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面考虑 &lt;strong&gt;包含 $n$ 个事务 $T_1, \cdots, T_n$ 的调度&lt;/strong&gt; $S$.&lt;/p&gt;

&lt;p&gt;$S$ 可以进一步地表示为调度指令执行的简写序列, 其中:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;begin&lt;/code&gt;, 开始一系列事务的调度&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;, 读操作.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;, 写操作.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;, 表示事务调度的终止.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt;, 表示提交对缓存中数据的修改到主存.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abort&lt;/code&gt;, 终止调度序列.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt; 操作涉及对数据库项的操作, 在实际表示时常常使用下标表明该操作是属于哪个事务的.&lt;/p&gt;

&lt;p&gt;举例, 调度序列&lt;/p&gt;

\[S_a: r_1(X);~ w_1(X);~r_2(X);~w_2(X);~r_1(Y);~a_1;\]

&lt;p&gt;表示如下表所示的调度:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115115807.png&quot; alt=&quot;20220115115807&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt; (冲突, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conflict&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称调度序列中的某两个操作是 &lt;strong&gt;冲突&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conflict&lt;/code&gt;) 的, 若它们满足下列特征:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;这两个操作分属 &lt;strong&gt;不同的事务&lt;/strong&gt;.&lt;/li&gt;
    &lt;li&gt;这两个操作访问了 &lt;strong&gt;同样的数据&lt;/strong&gt;.&lt;/li&gt;
    &lt;li&gt;这两个操作中至少有一个是 &lt;strong&gt;写操作.&lt;/strong&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于调度中的冲突操作会导致 &lt;strong&gt;数据不一致&lt;/strong&gt;, 我们需要构造 &lt;strong&gt;完备调度&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt; (完备调度, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Complete Schedule&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称满足下列条件的调度为 &lt;strong&gt;完备调度&lt;/strong&gt;:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;调度 $S$ 中的指令恰好是 $n$ 个事务 $T_1, \cdots, T_n$ 中的.&lt;/li&gt;
    &lt;li&gt;$T_1, \cdots, T_n$ 里任何事务中的任意一对指令的 &lt;strong&gt;相对顺序&lt;/strong&gt; 在 $S$ 中均 &lt;strong&gt;保持&lt;/strong&gt;.&lt;/li&gt;
    &lt;li&gt;调度中任意两个冲突操作都 &lt;strong&gt;不能同时被执行&lt;/strong&gt;.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;构造完备调度最简单的方法是不考虑穿插, 让所有事务 &lt;strong&gt;串行执行&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115121048.png&quot; alt=&quot;20220115121048&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但为了避免过大的性能损失, 在实际情况下我们必须穿插事务指令, 构造并行调度 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Allow Interleaving&lt;/code&gt;). 由此, 我们需要明确: 如何确定某个并行调度不会导致异常:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt; (可序列化调度, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable Schedule&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称某个包含 $n$ 个事务的调度 $S$ 为 &lt;strong&gt;可序列化的&lt;/strong&gt;, 若它 &lt;strong&gt;等价于&lt;/strong&gt; (一般认为是冲突等价) 某个包含同样 $n$ 个事务的串行调度.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了确保我们将要构造的并行调度是可序列化的, 我们还要引入 &lt;strong&gt;冲突等价&lt;/strong&gt; 的概念: (显然, 如果只考虑输出值等价的话很容易出现问题)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt; (冲突等价, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conflict Equivalence&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称两个不同顺序, 包含相同的 $n$ 个事务的调度是 &lt;strong&gt;冲突等价&lt;/strong&gt; 的, 若对任意一对冲突操作, 这对冲突操作在两个不同调度中的 &lt;strong&gt;相对顺序&lt;/strong&gt; 相同, 反之则称其为 &lt;strong&gt;冲突不等价&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Not Conflicting Equivalence&lt;/code&gt;) 的.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此, 我们现在可以给出 &lt;strong&gt;真正可用的&lt;/strong&gt;
 &lt;strong&gt;可序列化调度&lt;/strong&gt; 的定义: 若某个调度 $S$ 和某个串行调度 &lt;strong&gt;冲突等价&lt;/strong&gt;, 则称 $S$ 是 &lt;strong&gt;可序列化&lt;/strong&gt; 的.&lt;/p&gt;

&lt;p&gt;本课程中教授了如下的, 快速判断调度是否为可序列化的:&lt;/p&gt;

&lt;p&gt;使用有向图判断: &lt;strong&gt;只考虑读写操作&lt;/strong&gt;, 依次检查调度中涉及的每个事务 $T_i$.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将每个事务用一个节点表示,&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对调度中涉及的每一对冲突操作 $o_1, o_2$, 画一条从 &lt;strong&gt;更早发生的操作所属事务节点&lt;/strong&gt; 到 &lt;strong&gt;更晚发生的操作所属的事务节点&lt;/strong&gt; 的 &lt;strong&gt;有向边&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后检查构造的图. 若图是 &lt;strong&gt;无圈的&lt;/strong&gt;, 则该调度为 &lt;strong&gt;可序列化的&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220115124358.png&quot; alt=&quot;20220115124358&quot; /&gt;&lt;/p&gt;

&lt;p&gt;REFERENCE:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013634252/article/details/80569386&quot;&gt;SQL中SELECT语句详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.w3school.com.cn/sql/sql_WHERE.asp&quot;&gt;SQL WHERE 子句&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yank/p/3672478.html&quot;&gt;SQL总结（一）基本查询&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.w3school.com.cn/sql/sql_alter.asp&quot;&gt;SQL ALTER TABLE 语句&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41820897/article/details/100179834&quot;&gt;SQL的alter用法总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiangxinhouse/p/6053134.html&quot;&gt;sql中union和union all的用法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaolinyouni/article/details/6943337&quot;&gt;SQL查询cross JOIN的用法(笛卡尔积)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cy163/archive/2008/10/16/1312920.html&quot;&gt;left join 和 left outer join 的区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/webwangjie/p/11425632.html&quot;&gt;SQL的四种连接-左外连接, 右外连接, 内连接, 全连接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/fnlingnzb-learner/p/6343828.html&quot;&gt;sql 内连接, 外连接, 自然连接等各种连接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/30955338/understanding-cartesian-product-in-sql&quot;&gt;Understanding cartesian product in SQL&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.w3school.com.cn/sql/sql_view.asp&quot;&gt;SQL VIEW（视图）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lihaozy/archive/2013/06/03/3115110.html&quot;&gt;SQL中MAX()和MIN()函数的使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.w3school.com.cn/sql/sql_func_count_distinct.asp&quot;&gt;SQL COUNT DISTINCT 函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/shaofei63/article/details/42800793&quot;&gt;可以这样去理解group by和聚合函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/glassysky/p/11559082.html&quot;&gt;超实用的SQL语句之嵌套查询&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u014401141/article/details/53010608&quot;&gt;SQL Having的用法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/advantages-and-disadvantages-of-using-stored-procedures-sql/&quot;&gt;Advantages and Disadvantages of Using Stored Procedures – SQL&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mark-chan/p/5384139.html&quot;&gt;MySQL存储过程:存储过程简介&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a745233700/article/details/84587045&quot;&gt;MySQL数据库：触发器Trigger&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45062043&quot;&gt;MYSQL之触发器（Trigger）操作&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/takumicx/p/9998844.html#14-事务的acid特性以及实现原理概述&quot;&gt;数据库事务的概念及其实现原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010900754/article/details/72832997&quot;&gt;数据库】序列化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Serializability&quot;&gt;Wikipedia: Serializability&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liujiacai/p/15417598.html&quot;&gt;MySQL中全局变量、会话变量、用户变量和局部变量的区别&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/01/13/COMP23111-REV-Ch3/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/01/13/COMP23111-REV-Ch3/</guid>
        
        <category>2022</category>
        
        <category>COMP23111</category>
        
        
      </item>
    
      <item>
        <title>数据库导论 关系数据库建模</title>
        <description>&lt;h1 id=&quot;comp23111-revision-ch2&quot;&gt;COMP23111 REVISION Ch2&lt;/h1&gt;

&lt;h2 id=&quot;2-数据库建模&quot;&gt;2. 数据库建模&lt;/h2&gt;

&lt;p&gt;一般地, 我们在对某个现实需求建模时, 需要执行的流程是: 首先从现实问题中总结出现实需求 (&lt;strong&gt;需求的汇集和分析&lt;/strong&gt;), 将需求提炼成某种更抽象和精确的模型, 使用高级数据模型创建数据库的 &lt;strong&gt;概念模式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conceptual Schema&lt;/code&gt;)&lt;/strong&gt;, (&lt;strong&gt;概念设计, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conceptual Design&lt;/code&gt;&lt;/strong&gt;) 并最终从这个模型得到可直接在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBMS&lt;/code&gt; 上运行的数据库实现. (这一步也称为 &lt;strong&gt;逻辑设计&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logical Design&lt;/code&gt;) 基于这个特定的数据库实现, 再在此基础上进行其他的优化和功能补足 (&lt;strong&gt;物理设计&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Physical Design&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113093435.png&quot; alt=&quot;20220113093435&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-需求分析和逻辑建模&quot;&gt;2.1 需求分析和逻辑建模&lt;/h3&gt;

&lt;p&gt;本课程所教授的建模方法以 &lt;strong&gt;对象-实体模型&lt;/strong&gt; 为概念模式, 以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 为逻辑模式, 建模流程可以基本简化为: 提取需求 - 基于对象-实体模型构造 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 表并规范化 - 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 实现数据库设计.&lt;/p&gt;

&lt;p&gt;在上一节中我们已经知道, 对象-实体模型的核心思想是将现实世界的事物抽象为具备 &lt;strong&gt;属性&lt;/strong&gt; 的不同 &lt;strong&gt;对象&lt;/strong&gt;, 并且不同 &lt;strong&gt;对象&lt;/strong&gt; 之间通过 &lt;strong&gt;关系&lt;/strong&gt; 相联.&lt;/p&gt;

&lt;p&gt;举例来说, &lt;strong&gt;对象&lt;/strong&gt; 就如同句子中的名词/主语/谓语, 而修饰它的形容词就等价于 &lt;strong&gt;属性&lt;/strong&gt;. 最后, &lt;strong&gt;关系&lt;/strong&gt; 又可以视为 &lt;strong&gt;动词&lt;/strong&gt;, 描述对象之间的行为或交互.&lt;/p&gt;

&lt;p&gt;下面我们举例说明如何使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型建模:&lt;/p&gt;

&lt;p&gt;考虑对一个零售公司的销售业务进行建模. 我们已知的事实是:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113203610.png&quot; alt=&quot;20220113203610&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;211-对实体建模&quot;&gt;2.1.1 对实体建模&lt;/h4&gt;

&lt;p&gt;从中我们首先可以直接看出, 我们需要对 $4$ 种实体进行建模: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Product&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Order&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Employee&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;212-对属性建模&quot;&gt;2.1.2 对属性建模&lt;/h4&gt;

&lt;p&gt;对现实问题进行建模通常需要我们结合实际情况做出主观的假设. 进一步地, 我们可以基于假设和对给定信息的推断得出不同实体所应当被建模的属性:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113204125.png&quot; alt=&quot;20220113204125&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型要求每个实体类型都要有一个可用来唯一确定实体实例的 &lt;strong&gt;码&lt;/strong&gt;. 因此, 在构建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型时, 我们就用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; 表示不同实体类型的 &lt;strong&gt;码&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;213-对关系建模&quot;&gt;2.1.3 对关系建模&lt;/h4&gt;

&lt;p&gt;在完成对实体类型的建模后, 我们就需要考虑实体之间的关系. 一般而言, 从给定的信息中提取或推断实体类型之间的关系是很自然的事. 在本例中, 我们就可以直观地看出, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Order&lt;/code&gt; 之间必存在一个关系 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Places&lt;/code&gt;, 也就是 “下订单”.&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 表中, 我们通过 &lt;strong&gt;将表示不同实体类型的表用实线相连&lt;/strong&gt; 来标记这些实体之间存在 &lt;strong&gt;关系&lt;/strong&gt;. 我们一般还会把关系名写在实线上方, 从而便于理解.&lt;/p&gt;

&lt;p&gt;需要注意的是, 在对关系建模时, 除了标明 &lt;strong&gt;关系影响或包含的对象&lt;/strong&gt;, &lt;strong&gt;关系名&lt;/strong&gt; 以外, 我们还需要明确标示关系的 &lt;strong&gt;基数约束&lt;/strong&gt;, 也就是标明 &lt;strong&gt;某关系一侧可以出现的最大和最小实体数&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在本课程中, 我们使用 &lt;strong&gt;鸦脚标记法&lt;/strong&gt; 标记 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 表中每个关系的基数约束. 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113205045.png&quot; alt=&quot;20220113205045&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其语法规则如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113205111.png&quot; alt=&quot;20220113205111&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面讨论一些在构造 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt;图时可能会遇到的问题和一些特殊记法.&lt;/p&gt;

&lt;p&gt;首先, 双向的一对一关系可能会造成死锁问题, 这样的关系在对关系进行建模时要注意避免:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113211023.png&quot; alt=&quot;20220113211023&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, 我们可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 图中表示两个实体类型之间的多个不同关系:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113211116.png&quot; alt=&quot;20220113211116&quot; /&gt;&lt;/p&gt;

&lt;p&gt;形式上, 我们还可以在构造 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 图时就提前指定每个实体类型表中的 &lt;strong&gt;主键&lt;/strong&gt; 和 &lt;strong&gt;外键&lt;/strong&gt;, 但在该步骤中由于我们 &lt;strong&gt;仍然处在概念建模阶段&lt;/strong&gt;, 尚未开始数据库的具体实现, 因此 &lt;strong&gt;不能提前添加属性域和对属性的约束&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113205421.png&quot; alt=&quot;20220113205421&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可能会需要对 &lt;strong&gt;本身不具备码&lt;/strong&gt; 的 &lt;strong&gt;弱实体类型&lt;/strong&gt; (见本文 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;定义 1.2.4&lt;/code&gt;) 建模. 由于 &lt;strong&gt;弱实体类型的存在依赖于某个正常的实体类型&lt;/strong&gt; (因为只有通过某个由正常实体类型的主键和弱实体类型的属性组成的复合键才能对它的实例进行唯一确定), 因此任何弱实体类型必然与某个正常实体类型存在某种关系. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ER&lt;/code&gt; 表中, 弱实体类型的标记语法如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113210700.png&quot; alt=&quot;20220113210700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样地, 在对某些实体类型建模时, 我们可能需要对它的一些属性的表示方式进行取舍. 具体选择什么表示方式取决于实际问题的需要.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113210835.png&quot; alt=&quot;20220113210835&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-e-r-模型到数据库模式-schema-间的转换&quot;&gt;2.2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型到数据库模式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Schema&lt;/code&gt;) 间的转换&lt;/h3&gt;

&lt;p&gt;在得到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 图后, 我们需要将其转换为数据库模式 (本质上还是关系模式中定义的规则):&lt;/p&gt;

&lt;p&gt;在转换过程中一般地有以下的一一对应关系:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 图中的每个 &lt;strong&gt;实体类型&lt;/strong&gt; 被转换为数据库模式中的一个用表格 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table&lt;/code&gt;) 表示的关系, 其原因是我们的数据库基于关系模型, 而在关系模型中, 原来的 “实体” 也需要被建模成关系.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个实体类型中的 &lt;strong&gt;属性&lt;/strong&gt; 被相应地转化为对应关系 (数据库模式中被建模成关系的实体类型) 中的属性.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一般地, 用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; 表示的 &lt;strong&gt;码&lt;/strong&gt; 被转换为对应关系的主键.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 图中用实线表示的, 实体类型之间的关系现在用外键或联表表示.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;221-对象类型转换&quot;&gt;2.2.1 对象类型转换&lt;/h4&gt;

&lt;p&gt;具有码的强对象类型会被直接转换为关系. 需要注意的是, 在从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 图转换到数据库模式时, 我们需要补足每个关系中每个属性的 &lt;strong&gt;约束&lt;/strong&gt;, &lt;strong&gt;默认值&lt;/strong&gt; 和 &lt;strong&gt;主键/外键标示&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113212432.png&quot; alt=&quot;20220113212432&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于弱类型本身没有码, 在转换时弱类型对应的关系中会新增一个身为外键的属性, 该属性就是它的设计中复合主键的一部分: 其父关系类型的主键.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113212610.png&quot; alt=&quot;20220113212610&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;222-关系转换&quot;&gt;2.2.2 关系转换&lt;/h4&gt;

&lt;p&gt;下面考虑对 &lt;strong&gt;关系&lt;/strong&gt; 的转换:&lt;/p&gt;

&lt;p&gt;若某两个实体类型之间存在 &lt;strong&gt;一对一关系&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1-to-1 relationship&lt;/code&gt;), &lt;strong&gt;则在转换时要在父类型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parent Node&lt;/code&gt;) 对应的关系中新增一个属性, 该属性作为这个关系的 &lt;strong&gt;非空外键&lt;/strong&gt;, 指向子类型的主键.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113212748.png&quot; alt=&quot;20220113212748&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 是一一对应关系, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt; 是父类型, 则在表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt; 时就需要添加指向 子类型 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 表主键的非空外键 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;userID&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;若某两个实体类型之间存在 &lt;strong&gt;一对多关系&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;one-to many relationship&lt;/code&gt;), &lt;strong&gt;则在转换时要在子类型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'many' side&lt;/code&gt;) 对应的关系中新增一个属性, 该属性作为这个关系的 &lt;strong&gt;可空外键&lt;/strong&gt;, 指向父类型的主键.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113214137.png&quot; alt=&quot;20220113214137&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比如, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Order&lt;/code&gt; 是一对多关系, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Order&lt;/code&gt; 是子类型, 则在表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Order&lt;/code&gt; 时就需要添加指向 父类型 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Customer&lt;/code&gt; 表主键的外键 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;custID&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;多对多关系不能被直接转换, 需要构造联合类型(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Joining Entity&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113214425.png&quot; alt=&quot;20220113214425&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113214400.png&quot; alt=&quot;20220113214400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113214415.png&quot; alt=&quot;20220113214415&quot; /&gt;&lt;/p&gt;

&lt;p&gt;REFERENCE:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dekevin/archive/2012/07/18/2596745.html&quot;&gt;Powerdesigner数据库建模–概念模型–ER图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010429286/article/details/79022484&quot;&gt;数据库中的Schema是什么?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://beginnersbook.com/2015/04/super-key-in-dbms/&quot;&gt;Super key in DBMS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.techopedia.com/definition/21/candidate-key&quot;&gt;Candidate key&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/suguoliang/article/details/82844328&quot;&gt;SQL–超键、候选键、主键、外键的认识和区分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Armstrong%27s_axioms&quot;&gt;Wikipedia: Armstrong’s axioms&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20028672&quot;&gt;数据库第一二三范式到底在说什么？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Swocky/article/details/105059674&quot;&gt;【数据库系统】第十一讲 数据建模之思想与方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/maxle/article/details/122006538&quot;&gt;数据库概念（基数、关系模式的概念）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.techopedia.com/definition/25122/one-to-many-relationship&quot;&gt;One-to-Many Relationship&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/01/12/COMP23111-REV-Ch2/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/01/12/COMP23111-REV-Ch2/</guid>
        
        <category>2021</category>
        
        <category>COMP23111</category>
        
        
      </item>
    
      <item>
        <title>数据库导论 关系数据库理论</title>
        <description>&lt;h1 id=&quot;comp23111-revision-ch1&quot;&gt;COMP23111 REVISION Ch1&lt;/h1&gt;

&lt;p&gt;本复习笔记对本学期所教授的课程内容进行了基于笔者自己理解下的重排.&lt;/p&gt;

&lt;p&gt;笔者将前八周内对关系数据库从建模到通过网络编程实现, 穿插部分数据库理论的松散体系拆分为三个部分: 数据库理论, 数据库建模和数据库实现, 而最后三周内对各种非关系数据库的介绍仅作为补充内容 , 放在 “其他数据库” 中.&lt;/p&gt;

&lt;h2 id=&quot;1-数据库理论&quot;&gt;1. 数据库理论&lt;/h2&gt;

&lt;p&gt;数据库是 &lt;strong&gt;一系列有价值的信息组成的结构化的集合&lt;/strong&gt; (A &lt;strong&gt;structured&lt;/strong&gt; &lt;strong&gt;collection&lt;/strong&gt; of &lt;strong&gt;meaningful&lt;/strong&gt; data).&lt;/p&gt;

&lt;p&gt;我们称任何有价值的信息为 &lt;strong&gt;数据&lt;/strong&gt;, (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data&lt;/code&gt;) 用于构建和维护数据库的软件为 &lt;strong&gt;数据库管理系统&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBMS&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database Management System&lt;/code&gt;), 而 &lt;strong&gt;数据库管理系统&lt;/strong&gt; 和 &lt;strong&gt;数据&lt;/strong&gt; 共同组成 &lt;strong&gt;数据库系统&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database System&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;我们还称 &lt;strong&gt;标准化的&lt;/strong&gt;, 用于 &lt;strong&gt;管理关系数据库&lt;/strong&gt; 和 &lt;strong&gt;操作关系数据库数据&lt;/strong&gt; 的计算机语言为 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt;&lt;/strong&gt;, 而不完全遵循关系模型的数据库 (如以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MongoDB&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Couchbase&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Redis&lt;/code&gt; 为例的文件型数据库, 以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Neo4j&lt;/code&gt; 为例的图数据库).&lt;/p&gt;

&lt;p&gt;称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CREATE, ALTER, DROP, RENAME&lt;/code&gt; 等建表相关的語句為 &lt;strong&gt;数据定义语言&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DDL&lt;/code&gt;, 也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data Definition Language&lt;/code&gt;; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT, UPDATE, DELETE&lt;/code&gt; 等直接对 &lt;strong&gt;数据&lt;/strong&gt; 进行操作的语句为 &lt;strong&gt;数据操作语言&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DML&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database Manipulation Language&lt;/code&gt;), 以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; 语句为例的, 用于执行信息查询的语句为 &lt;strong&gt;数据库查询语言&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DQL&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data Query Language&lt;/code&gt;). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQL&lt;/code&gt; 是由上述三种语句组合而成的.&lt;/p&gt;

&lt;h3 id=&quot;11-概念和逻辑模型&quot;&gt;1.1 概念和逻辑模型&lt;/h3&gt;

&lt;p&gt;在本课程中, 我们着重介绍的数据库类型是 &lt;strong&gt;关系数据库&lt;/strong&gt;. 因此, 我们需要先将需求提炼为一种称为 &lt;strong&gt;实体-关系模型&lt;/strong&gt; 的概念模型 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conceptual Schema&lt;/code&gt;), 并将概念模型具体实现为关系数据库.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.1.1&lt;/strong&gt; (概念模式)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;概念模式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conceptual Schema&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conceptual Schema&lt;/code&gt;) 是对用户数据需求的 &lt;strong&gt;精确描述&lt;/strong&gt;, 包括 &lt;strong&gt;实体类型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Entity Type&lt;/code&gt;), &lt;strong&gt;实体之间关系的类型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Relation Type&lt;/code&gt;) 和 &lt;strong&gt;对关系的约束&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Constraints&lt;/code&gt;). 用户数据需求使用不涉及具体实现细节的概念表示, 本质上是对现实的抽象和简化, 便于理解.&lt;/p&gt;

  &lt;p&gt;数据库设计人员可使用概念模式作为和甲方的交流手段, 并可通过检查所构造的概念模式确保甲方的所有数据需求是否得到满足.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.1.2&lt;/strong&gt; (逻辑模式)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;逻辑模式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logic Schema&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logic Schema&lt;/code&gt;) 是指可被商用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBMS&lt;/code&gt; 直接运行的数据库实现.&lt;/p&gt;

  &lt;p&gt;将概念模式这种 &lt;strong&gt;抽象化的高级数据模型&lt;/strong&gt; 转换为逻辑模式这种 &lt;strong&gt;具体的实现化数据模型&lt;/strong&gt; 的步骤称为 &lt;strong&gt;逻辑设计 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logical Design&lt;/code&gt;)&lt;/strong&gt;, 该步骤得到的结果就是数据库的 &lt;strong&gt;逻辑模式&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们下面简介本课程中介绍的唯一一种概念模型: &lt;strong&gt;实体-关系模型&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;12-实体-关系-e-r-模型&quot;&gt;1.2 实体-关系 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt;) 模型&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.1&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;实体-关系模型 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Entitiy-Relationship Model&lt;/code&gt;) 是通过从现实世界中抽象出 &lt;strong&gt;实体类型&lt;/strong&gt;, &lt;strong&gt;实体的属性&lt;/strong&gt; 和 &lt;strong&gt;实体间的关系&lt;/strong&gt;, 从而对现实世界建模的概念模式.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.2&lt;/strong&gt; (实体)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;实体&lt;/strong&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型所表示的最基本对象, 它是现实世界中 &lt;strong&gt;独立存在的事物&lt;/strong&gt;, 可以是物理存在, 也可以是概念存在.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.3&lt;/strong&gt; (实体类型)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;实体类型&lt;/strong&gt; 定义为一个 &lt;strong&gt;具有相同属性的实体组成的集合&lt;/strong&gt;. 每个实体都具有一种 &lt;strong&gt;类型&lt;/strong&gt;, 某个实体类型可以具有多个实例.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.4&lt;/strong&gt; (码)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;码&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Key&lt;/code&gt;) 定义为 在实体-关系模型中可用于唯一确定 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Uniquely Identify&lt;/code&gt;) 某个实体的属性, 也就是说每个不同实体的这个属性值都不相同.&lt;/p&gt;

  &lt;p&gt;对任何实体类型而言, 其中的每个实体实例都必须能通过某个码唯一确定. 对实体类型而言, 码 &lt;strong&gt;可以不唯一&lt;/strong&gt;.&lt;/p&gt;

  &lt;p&gt;若某个实体类型 &lt;strong&gt;本身既没有可作为码的属性&lt;/strong&gt;, &lt;strong&gt;又没有被赋予的码 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Assigned Key&lt;/code&gt;)&lt;/strong&gt;, 则称该类型为 &lt;strong&gt;弱类型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Weak&lt;/code&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要注意: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型中 &lt;strong&gt;码&lt;/strong&gt; 的概念和关系数据库中的 &lt;strong&gt;主键/外键&lt;/strong&gt; 定义有 &lt;strong&gt;明显区别&lt;/strong&gt;, 不可混淆, 但是可以适当地将 &lt;strong&gt;码&lt;/strong&gt; 和 &lt;strong&gt;备选键&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Candidate Key&lt;/code&gt;) 类比.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.5&lt;/strong&gt; (属性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt; 是用来描述 &lt;strong&gt;实体&lt;/strong&gt; 的某些 &lt;strong&gt;具体性质&lt;/strong&gt; 的数据. 对特定的实体而言, 其每个属性都具有特定的值.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型通常使用的属性类型有: &lt;strong&gt;简单/复合属性&lt;/strong&gt;, &lt;strong&gt;单值/多值属性&lt;/strong&gt;, &lt;strong&gt;存储/派生属性&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.6&lt;/strong&gt; (简单/复合属性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;不可被继续划分的属性&lt;/strong&gt; 为 &lt;strong&gt;简单属性&lt;/strong&gt; 或 &lt;strong&gt;原子属性&lt;/strong&gt;, &lt;strong&gt;复合属性&lt;/strong&gt; 由组成它的简单属性的值组合而成.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.7&lt;/strong&gt; (单值属性/多值属性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;某个特定实体&lt;/strong&gt; 的 &lt;strong&gt;只具有一个值&lt;/strong&gt; 的属性为 &lt;strong&gt;单值属性&lt;/strong&gt;, 而该实体的 &lt;strong&gt;具有多个值的属性&lt;/strong&gt; 为 &lt;strong&gt;多值属性&lt;/strong&gt;, 如 &lt;strong&gt;某个人&lt;/strong&gt; 的 &lt;strong&gt;学位&lt;/strong&gt; (这个人可以没有学位, 也可以拿了双学位).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.8&lt;/strong&gt; (存储属性/派生属性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;在某些情况下多个属性的值是相关的, 如我们可以从某人的生日计算出此人的年龄.&lt;/p&gt;

  &lt;p&gt;称如 “年龄” 这样的, 可以由某个其他属性计算得出的属性为 &lt;strong&gt;派生属性&lt;/strong&gt;, 而称 “生日” 这样作为派生依据的属性为 &lt;strong&gt;存储属性&lt;/strong&gt;.&lt;/p&gt;

  &lt;p&gt;在某些情况下, 某些属性值还可由 &lt;strong&gt;相关实体&lt;/strong&gt; 派生得到.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.9&lt;/strong&gt; (空值)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;空值 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;&lt;/strong&gt; 在 &lt;strong&gt;对某个实体而言没有适用的值&lt;/strong&gt; 或 &lt;strong&gt;该实体的这个属性值缺失&lt;/strong&gt; 时应用, 其语义依具体情况差异而有不同.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.10&lt;/strong&gt; (复杂属性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;由复合属性和多值属性嵌套得到的组合称为 &lt;strong&gt;复杂属性&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2.11&lt;/strong&gt; (关系)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;关系&lt;/strong&gt; 描述 &lt;strong&gt;不同实体类型&lt;/strong&gt; 之间的联系, 将两个或更多实体类型使用某种含义 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Meaning&lt;/code&gt;) 相连接, 如考虑实体: &lt;strong&gt;Axton&lt;/strong&gt; 和 &lt;strong&gt;COMP23111&lt;/strong&gt;, 在 “&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Axton&lt;/code&gt; &lt;strong&gt;通过了&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMP23111&lt;/code&gt;” 中, &lt;strong&gt;通过&lt;/strong&gt; 就是一个 &lt;strong&gt;二元关系&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型中的关系受 &lt;strong&gt;基数约束&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cardinality Constraint&lt;/code&gt;), 它由所被建模的关系而决定 (回顾一下一对多, 一对一, 多对一等基数约束类型). 我们将在数据库建模一节中详细描述如何在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 表 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Entity-Relationship Diagram&lt;/code&gt;) 中表示实体类型之间的关系所受的基数约束.&lt;/p&gt;

&lt;h3 id=&quot;13-数据库的关系模型&quot;&gt;1.3 数据库的关系模型&lt;/h3&gt;

&lt;p&gt;数据库的三种基本模型是 &lt;strong&gt;层次模型&lt;/strong&gt;, &lt;strong&gt;网状模型&lt;/strong&gt;, &lt;strong&gt;关系模型&lt;/strong&gt;, 其中以 &lt;strong&gt;数据库的关系模型&lt;/strong&gt; 应用最为广泛.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.1&lt;/strong&gt; (数据库的关系模型)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;关系模型&lt;/strong&gt; 将数据库表示为 &lt;strong&gt;由关系组成的集合&lt;/strong&gt;.&lt;/p&gt;

  &lt;p&gt;若我们将每个关系视为一个 &lt;strong&gt;表格&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Table&lt;/code&gt;)时, 每个表都表示一个相关数据集的集合 (某个实体集), 每一行表示一个实体, 其内容的实质是抽象而来的 &lt;strong&gt;事实&lt;/strong&gt;, 一般对应现实世界中的某个实体或者某个联系.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113113232.png&quot; alt=&quot;20220113113232&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示, 对某个关系而言, 其表名和列名分别用来解释每一行/列的值所代表的含义.&lt;/p&gt;

&lt;p&gt;需要注意, 关系模型本身只是对某种关系的建模, 并不包含实际的数据本身.&lt;/p&gt;

&lt;p&gt;在正式的关系模型术语中, 行称为 &lt;strong&gt;元组&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tuple&lt;/code&gt;), 列标题称为 &lt;strong&gt;属性&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Attribute&lt;/code&gt;), 表称为 &lt;strong&gt;关系&lt;/strong&gt;, 数据类型称为 &lt;strong&gt;域&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Domain&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113114155.png&quot; alt=&quot;20220113114155&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面我们对这些术语进行定义:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.2&lt;/strong&gt; (域)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;域&lt;/strong&gt; 是 &lt;strong&gt;不可再分的原子值&lt;/strong&gt; 组成的集合.&lt;/p&gt;

  &lt;p&gt;一般而言, 指定一个域的通常方法是 &lt;strong&gt;指定某个数据类型&lt;/strong&gt; , 从而确保 构成这个域的数据值都来自这个数据类型.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在本课程中, 我们可以近似地认为域就是数据类型.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.3&lt;/strong&gt; (关系模式, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Relational Schema&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;关系模式 $R$ 表示为&lt;/p&gt;

\[R(A_1, A_2, \cdots, A_n),\]

  &lt;p&gt;由关系名 $R$ 和属性列表 $A_1, A_2, \cdots, A_n$ 共同构成. 每个属性 $A_i$ 都是一个变量名, 它可取的值在某个域 $D := \text{dom}(A_i)$ 中.&lt;/p&gt;

  &lt;p&gt;关系的 &lt;strong&gt;度/元&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Degree&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Arity&lt;/code&gt;) 是该关系模式中 &lt;strong&gt;属性的个数 $n$&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在上面的例子中, 我们描述了一个名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Student&lt;/code&gt;, 度为 $4$ 的关系, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-R&lt;/code&gt; 模型中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Student&lt;/code&gt; 被解释为 &lt;strong&gt;实体类型&lt;/strong&gt;. 在关系模型中, 原先的 “实体类型” 被解释为 “关系”, 也就是说实体的本质被视为是将某种和一系列不同 &lt;strong&gt;属性&lt;/strong&gt; 聚合的关系, 而原先实体类型之间的关系被用主键和外键表示.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.4&lt;/strong&gt; (键/超键)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称在某个关系表中的, 能够用于唯一标识元组 (也就是实体集中的某个特定实体)的属性集 为 &lt;strong&gt;键&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.5&lt;/strong&gt; (主键)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称在候选键组成的集合中被 &lt;strong&gt;选定&lt;/strong&gt; 用来唯一标识某个元组的键为 &lt;strong&gt;主键&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Primary Key&lt;/code&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.6&lt;/strong&gt; (超键, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super Key&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;能唯一标识元组&lt;/strong&gt; 的属性集为 &lt;strong&gt;超键&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.7&lt;/strong&gt; (候选键, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Candidate Key&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;能唯一标示元组&lt;/strong&gt; 且 &lt;strong&gt;不含多余属性&lt;/strong&gt; 的属性集 为 &lt;strong&gt;候选键&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注: Gareth把 &lt;strong&gt;超键&lt;/strong&gt; 和 &lt;strong&gt;候选键&lt;/strong&gt; 的定义搞反了. 正常的候选键就是如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;定义 3.7&lt;/code&gt; 这样定义的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113125232.png&quot; alt=&quot;20220113125232&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于Stewart在讨论函数依赖和范式时仍然沿用了正常的候选键和超键的定义, 本人姑且认为Gareth的Slide里出现的Candidate Key定义是错的, 一切以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wikipedia&lt;/code&gt; 和其他经典数据库教材为准.&lt;/p&gt;

&lt;p&gt;参考 &lt;a href=&quot;https://en.wikipedia.org/wiki/Candidate_key&quot;&gt;这里&lt;/a&gt; 和 &lt;a href=&quot;https://beginnersbook.com/2015/04/super-key-in-dbms/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.8&lt;/strong&gt; (外键)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称某个元组中, 出现在其他元组里且作为其他元组的主键的属性为 &lt;strong&gt;外键&lt;/strong&gt;. 外键具备连接元组与元组的职能.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113125750.png&quot; alt=&quot;20220113125750&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3.9&lt;/strong&gt; (数据库模式)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;数据库模式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Database Schema&lt;/code&gt;) 定义了数据库中各表的结构和他们之间的关系, 本质上是对关系模式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Relational Schema&lt;/code&gt;) 的提炼: 它只包含对各个关系所定义的规则, 而不包含实际的数据.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113130917.png&quot; alt=&quot;20220113130917&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面讨论关系模型中的数据完整性约束:&lt;/p&gt;

&lt;p&gt;关系模式中涉及的操作包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRUD&lt;/code&gt;: 插入 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create&lt;/code&gt;), 查找 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Retrieval&lt;/code&gt;),修改 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Update&lt;/code&gt;), 删除 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Delete&lt;/code&gt;). 而数据库在执行这些操作前都会检查操作是否满足数据库的 &lt;strong&gt;完整性约束&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integrity Constraint&lt;/code&gt;), 从而防止用户在修改数据库时不会破坏 &lt;strong&gt;数据库的一致性&lt;/strong&gt;. 完整性约束包含下面的几种类型:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;主键约束 (Primay Key Constraint): 确保数据字段的 &lt;strong&gt;唯一性&lt;/strong&gt; 和 &lt;strong&gt;非空性&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唯一约束 (Unique Constraint): 确保数据字段的 &lt;strong&gt;唯一性&lt;/strong&gt;. (但是可为空)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检查约束 (Check Constraint): 限制该数据字段的范围和格式.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;默认约束 (Default Constraint) 赋予该数据字段规定好的默认值.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外键约束 (Foreign Key Constraint): 需要建立两表间的关系并引用主表的列.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后简单总结:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113130605.png&quot; alt=&quot;20220113130605&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;14-函数依赖-functional-dependencies-和范式-normal-form&quot;&gt;1.4 函数依赖 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Functional Dependencies&lt;/code&gt;) 和范式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Normal Form&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;我们先讨论 &lt;strong&gt;函数依赖&lt;/strong&gt;, 它是关系模式设计理论中的重要概念:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.1&lt;/strong&gt; (函数依赖)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;若在某张表中, 在 &lt;strong&gt;属性集&lt;/strong&gt; $X$ 的值确定的情况下, 必能 &lt;strong&gt;唯一确定&lt;/strong&gt; 属性 $Y$ 的值, 则称 属性 $Y$ 是 &lt;strong&gt;函数依赖于&lt;/strong&gt; 属性 $X$ 的, 记为&lt;/p&gt;

\[X \rightarrow Y.\]

  &lt;p&gt;或称属性 $X$ &lt;strong&gt;函数决定了&lt;/strong&gt; 属性 $Y$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113171957.png&quot; alt=&quot;20220113171957&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.2&lt;/strong&gt; (完全函数依赖)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;若某张表满足函数依赖关系 $X \rightarrow Y$, 则若对于属性组 $X$ 的任何一个 &lt;strong&gt;真子集&lt;/strong&gt; $X’$, 满足&lt;/p&gt;

\[X' \nrightarrow Y\]

  &lt;p&gt;则称 $Y$ 对于 $X$ &lt;strong&gt;完全函数依赖&lt;/strong&gt;, 记作&lt;/p&gt;

\[X \overset{F}{\rightarrow} Y.\]

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.3&lt;/strong&gt; (部分函数依赖)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;和 &lt;strong&gt;完全函数依赖&lt;/strong&gt; 相对地, 若属性 $Y$ 是 &lt;strong&gt;函数依赖于&lt;/strong&gt; 属性 $X$, 但并不 &lt;strong&gt;完全函数依赖于&lt;/strong&gt; 它, 则称 $Y$ &lt;strong&gt;部分函数依赖于&lt;/strong&gt; $X$, 记为&lt;/p&gt;

\[X \overset{P}{\rightarrow} Y.\]

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.4&lt;/strong&gt; (传递函数依赖)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;若:&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;$Y$ 函数依赖于 $X$;&lt;/li&gt;
    &lt;li&gt;$Z$ 函数依赖于 $Y$,&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;则称 $Z$ &lt;strong&gt;传递函数依赖于&lt;/strong&gt; $X$, 记为&lt;/p&gt;

\[X \overset{T}{\rightarrow} Z.\]

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.5&lt;/strong&gt; (主属性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;包含在任意一个候选键 (属性集) 中的属性&lt;/strong&gt; 为 &lt;strong&gt;主属性&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.6&lt;/strong&gt; (非主属性)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;不包含在任意候选键中的属性&lt;/strong&gt; 为 &lt;strong&gt;非主属性&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以通过一系列推理规则, 从已知的一些函数依赖推导出另外一些函数依赖, 而这些规则就被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Armstrong&lt;/code&gt; 公理:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113173309.png&quot; alt=&quot;20220113173309&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其推论:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113173334.png&quot; alt=&quot;20220113173334&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113173346.png&quot; alt=&quot;20220113173346&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113173357.png&quot; alt=&quot;20220113173357&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在此基础上, 对任何由一系列函数依赖规则组成的集合 $U$ , 对于该集合中的任意一个真子集 $F$ 而言, 我们都可以 &lt;strong&gt;使用上面提到的规则&lt;/strong&gt; 计算出 &lt;strong&gt;基于全体规则 $U$, 从 $F$ 出发可被逻辑推导出的全部函数依赖规则&lt;/strong&gt;. 在解决一些题目时, 可以用这种方式快速确定超键.如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113174051.png&quot; alt=&quot;20220113174051&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们下面给出不同级别范式的定义与它们的转换原则:&lt;/p&gt;

&lt;p&gt;为了确保我们设计得到的关系模式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Relational Schema&lt;/code&gt;) 具备最小的数据冗余且存在最少的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRUD&lt;/code&gt; 异常, 需要通过对给定的关系模式进行一系列的检验, 以 “验证” 我们的关系模式是否符合某些特定的标准, 也就是所谓的 “范式”.&lt;/p&gt;

&lt;p&gt;随后, 我们可以基于不同范式的相应标准对我们的关系模式进行验证和评估, 并根据实际需要对我们的关系模式中不满足标准的某些关系进行进一步分解, 从而将其规范化.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.7&lt;/strong&gt; 范式&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;范式&lt;/strong&gt; 是 &lt;strong&gt;符合某种级别的关系模式的集合&lt;/strong&gt;, 表示了某个关系内部各个属性之间的联系的合理化程度, 换做人话来说就是 &lt;strong&gt;关系模式的表结构所符合的设计标准的级别&lt;/strong&gt;.&lt;/p&gt;

  &lt;p&gt;而 &lt;strong&gt;关系的范式&lt;/strong&gt; 则是该关系所能满足的最高的范式条件, 表现了这个关系规范化的程度.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在本课程中, 我们关心的范式分为 &lt;strong&gt;第一范式&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt;) , &lt;strong&gt;第二范式&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt;) 和 &lt;strong&gt;第三范式&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3NF&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.8&lt;/strong&gt; (第一范式)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;第一范式基于 &lt;strong&gt;原子化&lt;/strong&gt; 的概念: 它规定属性域只能包含不可再分的 (原子化的) 值, 且元组中任一属性的值必须是一个来自于该属性域的, 单个的值.&lt;/p&gt;

  &lt;p&gt;换言之, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt; 不允许 “关系中嵌套关系” 或 “元组中任何一个属性值是关系”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如, 考虑下图所示的关系模式 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Department&lt;/code&gt;, 假设属性 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dlocations&lt;/code&gt; 值不唯一, 则该关系模式不满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113175935.png&quot; alt=&quot;20220113175935&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在本课程中, 我们介绍了下述的, 将这样的关系模式转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt; 的方式:&lt;/p&gt;

&lt;p&gt;从这个关系模式中移除导致违背 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt; 要求的属性 (在我们的例子中是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dlocations&lt;/code&gt;), 并将它和原模式 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEPARTMENT&lt;/code&gt; 的主码 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dnumber&lt;/code&gt; 放在单独的一个新关系中, 这个新关系的主码依据实际情况决定, 在本例中则为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{Dnumber, Dlocations}&lt;/code&gt;. 这一方法的实质是: &lt;strong&gt;将某个非 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt; 的关系分解为多个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt; 关系&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.9&lt;/strong&gt; (第二范式)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;第二范式基于 &lt;strong&gt;完全函数依赖&lt;/strong&gt; 的概念:&lt;/p&gt;

  &lt;p&gt;若关系模式 $R$ 中的每个非主属性 $A$ 都 &lt;strong&gt;完全依赖于&lt;/strong&gt; $R$ 的主键, 则该关系模式属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换言之, 如果给定的关系模式的主键的任何一个真子集能够唯一确定某个不在主键内的属性, 则这个关系模式就不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;如果主键只由单个属性组成, 则无需进行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt; 检验, 这个关系模式一定是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;本课程中所介绍的, 将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1NF&lt;/code&gt; 转化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt; 的流程是: (注意: 不要跨级转化范式!)&lt;/p&gt;

&lt;p&gt;考虑某个不属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt; 的关系模式, 我们需要:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;找到那些部分依赖主键的属性.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确定它们分别 &lt;strong&gt;完全依赖于主键的哪个组成部分&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将原来的关系进行拆分, 每个部分依赖主键的属性都要被从原关系中拆分出来, 和它所完全依赖的那一部分主键组合在一起形成一个满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt; 的, 更小的关系.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113182028.png&quot; alt=&quot;20220113182028&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4.10&lt;/strong&gt; (第三范式)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;第三范式基于 &lt;strong&gt;传递依赖&lt;/strong&gt; 的概念:
若某个关系模式 $R$ 满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2NF&lt;/code&gt; 范式, 且 $R$ 中不存在 &lt;strong&gt;非主属性传递依赖于主码&lt;/strong&gt; 的情况, 则 $R$ 属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3NF&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;换言之, 关系模式中所有的非主属性都应该直接依赖于主键. 若存在某两个非主属性 $Y, Z$, 对于主键 $X$, 有&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$X \rightarrow Y$&lt;/li&gt;
  &lt;li&gt;$Y \rightarrow Z$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;则这个关系模式就不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3NF&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;本课程中介绍了下述的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3NF&lt;/code&gt; 转换方法:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;找到间接依赖主键的属性链条.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拆分关系, 打散链条.对于间接依赖链条上除了主键以外的每个节点, 都要单独分解为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3NF&lt;/code&gt; 模式进行规范化.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113182914.png&quot; alt=&quot;20220113182914&quot; /&gt;&lt;/p&gt;

&lt;p&gt;综上所述, 我们可以将基于主码的范式和相应的规范化的检验条件和规范化方法总结如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113183006.png&quot; alt=&quot;20220113183006&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;REFERENCE&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QpdhBUYk7Kk&quot;&gt;Entity Relationship Diagram (ERD) Tutorial - Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=-CuY5ADwn24&quot;&gt;Entity Relationship Diagram (ERD) Tutorial - Part 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conceptual_schema&quot;&gt;Wikipedia: Conceptual schema&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/01/11/COMP23111-REV-Ch1/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/01/11/COMP23111-REV-Ch1/</guid>
        
        <category>2021</category>
        
        <category>COMP23111</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法 复习</title>
        <description>&lt;h1 id=&quot;comp26120-revision&quot;&gt;COMP26120 REVISION&lt;/h1&gt;

&lt;h2 id=&quot;1-算法设计与复杂度分析&quot;&gt;1. 算法设计与复杂度分析&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;定义 1.1&lt;/strong&gt; (算法)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称一系列精确定义地, 用于解决特定计算问题的步骤和流程为 &lt;strong&gt;算法&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.2&lt;/strong&gt; (抽象数据类型, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abstract Data Type&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADT&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称一个对 &lt;strong&gt;抽象化的数据对象本身&lt;/strong&gt; , &lt;strong&gt;数据对象之间的关系&lt;/strong&gt; 和 &lt;strong&gt;可对数据对象进行的基本操作&lt;/strong&gt; 的需求 (定义) 为 &lt;strong&gt;抽象数据类型&lt;/strong&gt;, 本质上描述了一个数据模型与定义在这个模型上的一组运算.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.3&lt;/strong&gt; (数据结构)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;数据结构是对 &lt;strong&gt;某种抽象数据类型&lt;/strong&gt; 的具体实现.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举例来说, &lt;strong&gt;字典&lt;/strong&gt;, &lt;strong&gt;数组&lt;/strong&gt;, &lt;strong&gt;栈&lt;/strong&gt;, &lt;strong&gt;队列&lt;/strong&gt; 都是抽象数据类型, 而动态表 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dynamic Array&lt;/code&gt;), 链表, 二叉树, 哈希表, 堆等都属于数据结构.&lt;/p&gt;

&lt;h3 id=&quot;11-算法时间复杂度分析的基本方法和基本定义&quot;&gt;1.1 算法时间复杂度分析的基本方法和基本定义&lt;/h3&gt;

&lt;h4 id=&quot;1-算法时间复杂度的粗略分析-以冒泡排序为例&quot;&gt;1. 算法时间复杂度的粗略分析: 以冒泡排序为例&lt;/h4&gt;

&lt;p&gt;冒泡排序核心部分的伪代码如下:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们的任务是对这段代码片段进行粗略的复杂度分析. 可见在上述代码片段中, 共有 $2$ 个嵌套的循环, 每个循环执行 $n-1$ 次. 由此可以直接判断, 该代码片段的空间复杂度为 $O(n^2)$,&lt;/p&gt;

&lt;p&gt;同时注意冒泡排序的核心逻辑: 内层循环的作用是将数组中的 &lt;strong&gt;最大&lt;/strong&gt; (或第二大, 第三大,…) 元素从原始位置挨个和后面的元素比较, 将其对换 (“冒泡”) 到数组末尾, 而为了确保数组所有位置上的元素都能被这样检查一遍, 需要将内层循环执行 $n-1$ 次.&lt;/p&gt;

&lt;h4 id=&quot;2-算法的渐进性能-以线性查找和二分查找为例&quot;&gt;2. 算法的渐进性能: 以线性查找和二分查找为例&lt;/h4&gt;

&lt;p&gt;下面以 &lt;strong&gt;线性查找&lt;/strong&gt; 与 &lt;strong&gt;二分查找&lt;/strong&gt; 为例分析并对比两种查找算法的渐进性能:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.4&lt;/strong&gt; (渐进性能)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;算法的 &lt;strong&gt;渐进性能&lt;/strong&gt; 指在给定输入的大小无限逼近于无穷大时, 算法的 &lt;strong&gt;运行时间&lt;/strong&gt;, &lt;strong&gt;存储和内存占用&lt;/strong&gt; 等系统资源消耗情况等指示算法性能指标的变化情况.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先以 &lt;strong&gt;线性查找&lt;/strong&gt; 为例:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然在最坏情况下, 循环需要执行 $n$ 次才能找到需要的元素, 在最好情况下只需要执行 $1$ 次, 而在一般情况下需要执行 $\frac{n}{2}$ 次. 考虑最坏情况, 线性查找的时间复杂度为 $O(n)$.&lt;/p&gt;

&lt;p&gt;然后以 &lt;strong&gt;二分查找&lt;/strong&gt; 为例:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意二分查找的前提是: 假设待查找的数组已经是经过排序的. 在这一情况下, 二分查找每次都会将数组内的搜索范围 &lt;strong&gt;折半&lt;/strong&gt; , 结合一些简单的数学知识可知二分查找的时间复杂度为 $O(\log(n))$.&lt;/p&gt;

&lt;p&gt;下面说明我们进行复杂度分析所依赖的计算机简化模型: 在该模型中我们认为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对 &lt;strong&gt;任何内存地址的访问&lt;/strong&gt; 消耗的时间和其他资源 &lt;strong&gt;相同&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;不考虑指令并行执行的情况.&lt;/li&gt;
  &lt;li&gt;除了对函数的调用以外, 所有的指令执行时间 &lt;strong&gt;相同&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;除非特殊指定, 否则规定字长 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word size&lt;/code&gt;) 为某个常数.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;换言之, 在计算运行时间时, 我们本质上进行的是对 &lt;strong&gt;基础指令条数&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Number of primitive steps&lt;/code&gt;) 的计数.&lt;/p&gt;

&lt;p&gt;而我们所得出的, 表示 &lt;strong&gt;最坏情形&lt;/strong&gt; 的结果提供了一个清晰明确的, 对算法运行可能消耗的时间的 &lt;strong&gt;上界&lt;/strong&gt;, 它相当于某种 &lt;strong&gt;绝对保证&lt;/strong&gt;: 不存在任何情况, 使得算法的运行时间超过它.&lt;/p&gt;

&lt;p&gt;而表示 &lt;strong&gt;一般情形&lt;/strong&gt; 的结果所提供的是 &lt;strong&gt;算法运行时间的数学期望&lt;/strong&gt;, 但需要注意, 随着我们对 “一般” 概念定义的变化, 所得到的结果也会有所不同, 它并不一定能满足真实的情况.&lt;/p&gt;

&lt;h4 id=&quot;3-研究算法的时间复杂度-以插入排序为例&quot;&gt;3. 研究算法的时间复杂度: 以插入排序为例&lt;/h4&gt;

&lt;p&gt;我们首先给出插入排序的伪代码:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;InsertionSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;插入排序的循环不变量是: 始终认为数组片段 $A[0:i-1]$ 是 &lt;strong&gt;顺序排列&lt;/strong&gt; 的, 而每次循环都是一次将新元素 $A[i]$ 插入到这个子数组中同时维护子数组顺序的过程.&lt;/p&gt;

&lt;p&gt;我们对插入排序资源消耗的分析如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106173409.png&quot; alt=&quot;20220106173409&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 $t_i$ 就是在第 $i$ 次循环中, 内层 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 的执行次数, 本质上就是 $A[j]$ 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt; 的比较次数.&lt;/p&gt;

&lt;p&gt;在最好情况下, 内层循环无需执行; 而在最坏情况下, 所有的内层循环都需要执行. 此时可知:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106173705.png&quot; alt=&quot;20220106173705&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是说, 插入排序的时间复杂度为 $O(n^2)$.&lt;/p&gt;

&lt;h4 id=&quot;4-对基本记号和概念的定义&quot;&gt;4. 对基本记号和概念的定义&lt;/h4&gt;

&lt;p&gt;最后给出复杂度分析中基本记号和概念的定义:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 1.5&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Big-O&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;记 $O$ 表示函数具有 &lt;strong&gt;渐进上界&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Asymptotic upper-bound&lt;/code&gt;):&lt;/p&gt;

\[O(g(n)) = \{f(n) ~:~ \exists c &amp;gt; 0, n_0 &amp;gt; 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant f(n) \leqslant c \cdot g(n)\}.\]
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.6&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Big-Omega&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;记 $\Omega$ 表示函数具有 &lt;strong&gt;渐进下界&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Asymptotic lower-bound&lt;/code&gt;):&lt;/p&gt;

\[\Omega(g(n)) = \{f(n) ~:~ \exists c &amp;gt; 0, n_0 &amp;gt; 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant c \cdot g(n) \leqslant f(n)\}.\]
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 1.7&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Big-Theta&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;记 $\Theta$ 表示函数具有 &lt;strong&gt;渐进紧确界&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Asymptotic tight-bound&lt;/code&gt;):&lt;/p&gt;

\[\Theta(g(n)) = \{f(n) ~:~ \exists c_1, c_2 &amp;gt; 0, n_0 &amp;gt; 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant c_1 \cdot g(n) \leqslant f(n) \leqslant c_2 \cdot g(n)\}.\]
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106174441.png&quot; alt=&quot;20220106174441&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若 $f(n)$ 以 $g(n)$ 为 &lt;strong&gt;渐进紧确界&lt;/strong&gt;, 当且仅当 $f(n)$ 同时以 $g(n)$ 为 &lt;strong&gt;渐进上界&lt;/strong&gt; 和 &lt;strong&gt;渐进下界&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;我们再给出其他的一些不常用的渐进符号定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106174603.png&quot; alt=&quot;20220106174603&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意, 在遇到类似于 “求证某个函数具有渐进上/下界或具有渐进紧确界” 的问题时, 解决问题的基本流程是基于求证假设构建不等式, 通过代数变型求得常数 $c$ (或 $c_1, c_2$) 的取值范围. 若的确可以找到这样的常数, 则说明假设得证. 比如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116111702.png&quot; alt=&quot;20220116111702&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116111911.png&quot; alt=&quot;20220116111911&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-分治&quot;&gt;1.2 分治&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;定义 1.8&lt;/strong&gt; (分治法)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;分治法是一种通过将给定问题递归地分划为规模更小的子问题, 并逐一解决这些子问题从而解决给定问题的算法设计思想. 使用分治法思想设计的算法包含三个部分:&lt;br /&gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;分划 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Divide&lt;/code&gt;): 将原问题拆分成规模更小的子问题.&lt;/li&gt;
    &lt;li&gt;解决 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conquer&lt;/code&gt;): 递归地解决这些拆分出来的小问题.&lt;/li&gt;
    &lt;li&gt;联合 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Combine&lt;/code&gt;): 将解决的小问题联合从而形成对原问题的一个解.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;分治问题的复杂度表达式一般形如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106175014.png&quot; alt=&quot;20220106175014&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D(n)&lt;/code&gt; 为 &lt;strong&gt;问题分划消耗的时间&lt;/strong&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aT(b/b)&lt;/code&gt; 为 &lt;strong&gt;划分的 $a$ 个子问题&lt;/strong&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C(n)&lt;/code&gt; 为 &lt;strong&gt;将解决的子问题重新组合消耗的时间&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;我们下面以 &lt;strong&gt;归并排序&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Merge Sort&lt;/code&gt;) 为例探讨分治法的运作过程. 归并排序的伪代码如下:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// take 2 sorted subarrays of A and merge them into 1 single sorted array&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;infty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可见归并排序的原理是递归地将给定的数组拆分成大小相同的左右两个子数组, 然后对这两个子数组递归地调用自身 (实际上就是对子数组再次进行拆分), 直到将数组拆成只由一个元素组成, 无法再拆为止. 然后再使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Merge()&lt;/code&gt; 方法, 将这些被拆分的数组两两结合成较大的, 保持顺序的数组, 同样递归地最终合成为原数组的已排序形式.&lt;/p&gt;

&lt;p&gt;对归并排序资源消耗的分析如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106175936.png&quot; alt=&quot;20220106175936&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显然有:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106180024.png&quot; alt=&quot;20220106180024&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一个 &lt;strong&gt;递归表达式&lt;/strong&gt;. 我们再举一个例子: &lt;strong&gt;二分查找算法&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;BinarySearch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BinarySearch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BinarySearch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然二分查找的递归表达式可以记为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106180412.png&quot; alt=&quot;20220106180412&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们将在下一节中介绍求解递归表达式的一般方法: &lt;strong&gt;替代法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Substitution Method&lt;/code&gt;), &lt;strong&gt;递归法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Iteration Method&lt;/code&gt;) 和 &lt;strong&gt;主方法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Master Method&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;13-求解递归表达式&quot;&gt;1.3 求解递归表达式&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;替代法 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Substitution Method&lt;/code&gt;):
 基本原理是 &lt;strong&gt;猜测正确答案的形式 (猜测给定递归表达式的时间复杂度)&lt;/strong&gt;, 然后使用 &lt;strong&gt;数学归纳法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Induction&lt;/code&gt;) 证明这个猜测成立.&lt;/p&gt;

    &lt;p&gt;值得注意的是, 在替换法中, 有时我们可以使用适当的技巧简化问题. 如:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106185458.png&quot; alt=&quot;20220106185458&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;在上面的例子中, 我们 &lt;strong&gt;通过将递归表达式右侧式子中的函数项和加号右侧的代数项替换为正常形式, 成功地将问题转换为我们可以解决的形式.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;而在考虑 “将什么变量替换成什么形式” 的问题时, 可以优先考虑将等号右侧加号右边的项替换为一个 &lt;strong&gt;一次项&lt;/strong&gt;, 如将 $\log(n)$ 替换为 $m$. 在此基础上, 再检查经过这样替换后的递归公式是不是被简化成了我们已知的一些常见形式. 如果是的话, 就可以使用替代法求解.&lt;/p&gt;

    &lt;p&gt;我们再附上一些指数, 对数, 阶乘和级数的常用性质:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222251.png&quot; alt=&quot;20220106222251&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222324.png&quot; alt=&quot;20220106222324&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116122943.png&quot; alt=&quot;20220116122943&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222414.png&quot; alt=&quot;20220106222414&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;此外, 我们还可使用定积分近似某个求和表达式:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116123240.png&quot; alt=&quot;20220116123240&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归法 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Iteration Method&lt;/code&gt;)
递归法的基本原理是: 给定某个算法的递归表达式, 利用表达式自身循环定义的特性, 不断地将等式右侧的表达式使用递归定义 “解压缩”, 直到展现出某个明显的规律为止.&lt;/p&gt;

    &lt;p&gt;然后, 尝试将等号右侧已经表现出一定规律的式子中左边函数定义的那部分中的变量进行替换或变形, 从而使该变量等于函数递归表达式定义中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base Case&lt;/code&gt; 对应的变量值. 这样, 我们就可以将函数定义的那部分直接替换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base Case&lt;/code&gt; 对应的式子 (但一般都是个数值), 从而可以直接看出表达式的时间复杂度.&lt;/p&gt;

    &lt;p&gt;举例:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223637.png&quot; alt=&quot;20220106223637&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223647.png&quot; alt=&quot;20220106223647&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用主定理 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Master Theorem&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116123655.png&quot; alt=&quot;20220116123655&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223856.png&quot; alt=&quot;20220106223856&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;下面给出一些常用结论:&lt;/p&gt;

\[\begin{aligned} T(n) &amp;amp;= T(n-1) + O(1) ~~~ \rightarrow \Theta(n) \\ 

 T(n) &amp;amp;= 2T(\frac{n}{2}) + O(1) ~~~~~~~\rightarrow \Theta(n)  \\
 T(n) &amp;amp;= T(\frac{n}{2}) + O(1) ~~~~~~~~~\rightarrow \Theta(\log(n)) \\ 
 T(n) &amp;amp;= T(\frac{n}{2}) + O(n) ~~~~~~~~~\rightarrow \Theta(n\log(n))
 \end{aligned}\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;14-算法性能的均摊分析&quot;&gt;1.4 算法性能的均摊分析&lt;/h3&gt;

&lt;p&gt;考虑算法在 &lt;strong&gt;最坏情况下的时间复杂度&lt;/strong&gt; 可以给我们算法运行耗时的 &lt;strong&gt;上限&lt;/strong&gt;, 但在实际情况下这样的分析往往会 &lt;strong&gt;低谷算法在平均状态下的性能&lt;/strong&gt;. 为了从另一个角度对算法的时间复杂度进行评估, 我们引入了 &lt;strong&gt;均摊分析&lt;/strong&gt; 的概念.&lt;/p&gt;

&lt;p&gt;在 &lt;strong&gt;均摊分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Amortised Analysis&lt;/code&gt;) 中, 我们根据具体要求 &lt;strong&gt;构造出一个由一系列操作组成的指令序列&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sequence&lt;/code&gt;), 然后通过计算和讨论这个序列执行耗时的方式研究给定算法在这种情况下的性能.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116125032.png&quot; alt=&quot;20220116125032&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常用的均摊分析方法有三种:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Aggregate Method&lt;/code&gt; 聚合法.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accounting Method&lt;/code&gt; 审计法.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Potential Method&lt;/code&gt; 势能法.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在本课程中, 我们只介绍第一种方法. 聚合法单纯计算序列中每个操作消耗的平均时间, 忽视操作之间可能存在的区别.&lt;/p&gt;

&lt;p&gt;(后面提到的, 关于动态增删数组, 栈操作和二进制加减法的例子建议直接看 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slides&lt;/code&gt;, 此处省略)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116125609.png&quot; alt=&quot;20220116125609&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-基本数据结构&quot;&gt;2. 基本数据结构&lt;/h2&gt;

&lt;p&gt;从本节开始我们将讨论一系列的基本数据结构. 首先回顾 &lt;strong&gt;抽象数据类型&lt;/strong&gt; 的基本概念:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155651.png&quot; alt=&quot;20220107155651&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;数据结构&lt;/strong&gt; 是对 &lt;strong&gt;抽象数据类型&lt;/strong&gt; 的 &lt;strong&gt;具体实现&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155739.png&quot; alt=&quot;20220107155739&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于这个定义, 动态数组 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dynamic Array&lt;/code&gt;) 可被定义为由以下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 组成的抽象数据类型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155919.png&quot; alt=&quot;20220107155919&quot; /&gt;&lt;/p&gt;

&lt;p&gt;链表 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linked List&lt;/code&gt;) 可被定义为由以下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 组成的抽象数据类型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155948.png&quot; alt=&quot;20220107155948&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-哈希表&quot;&gt;2.1 哈希表&lt;/h3&gt;

&lt;p&gt;哈希表本质上是称为 &lt;strong&gt;字典&lt;/strong&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADT&lt;/code&gt; 的一种实现, 是 &lt;strong&gt;数据结构&lt;/strong&gt;. 我们首先阐述哈希表数据结构需要满足的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107160749.png&quot; alt=&quot;20220107160749&quot; /&gt;&lt;/p&gt;

&lt;p&gt;哈希表的基本工作原理是:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;在将数据插入表中时, 使用经过精心设计的 &lt;strong&gt;哈希函数&lt;/strong&gt;, 基于被插入数据本身的特性得到一个索引, 然后将数据存到实际负责数据存储的数组的索引位置上.&lt;/li&gt;
  &lt;li&gt;如果数组的索引位置上已经有数据存储, 也就是发生了 “数据碰撞” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collision&lt;/code&gt;), 则需要再基于某些规则重新生成一个新的索引, 把数据存到别的位置上去从而避免碰撞.&lt;/li&gt;
  &lt;li&gt;在从表中提取数据时, 同样需要使用哈希函数算出索引, 然后按图索骥从数组中找到所需要的数据.&lt;/li&gt;
  &lt;li&gt;在实际负责数据存储的数组剩余空间不足时, 需要将其扩容并将原数组中存放的所有元素全部重哈希到更大的新表中.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;哈希表在理想状态下的读/写性能均为 $O(1)$, 这样的性能优化得益于哈希函数. 在最好情况下, 数据碰撞不会发生, 因而只要计算一次哈希函数就可得到索引.&lt;/p&gt;

&lt;p&gt;下面讨论几个哈希表实现中的问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是合理的哈希函数?&lt;/p&gt;

    &lt;p&gt;合理的哈希函数应当具有以下性质:&lt;/p&gt;

    &lt;p&gt;给定一个映射范围 $n$ 和被映射元素集合 $U$, 哈希函数 $f$ 应该能将 $U$ 中的每个元素 &lt;strong&gt;均匀地&lt;/strong&gt; 映射到 $[0, n)$ 的范围上.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107164137.png&quot; alt=&quot;20220107164137&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;能够正确区分性质相似的数据, 如包含相同元素而排列顺序不同的字符串.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;我们无法避免数据碰撞的发生. 一旦发生数据碰撞, 有哪些可行的方法解除数据碰撞?
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Separate Chaining&lt;/code&gt;: 若多个数据被哈希函数映射到数组的同一个位置上, 则在数组的该位置上存储一个链表, 将这些数据按照插入的先后顺序挂到链表上.&lt;/p&gt;

        &lt;p&gt;在实际应用中, 只要哈希函数的选取和重哈希策略得当, 在数组中即使存在数据碰撞, 该位置上的链表也不会很长.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open Addressing&lt;/code&gt;: 开放寻址, 在确定出现数据碰撞后使用预定义的规则再生成新的位置, 直到生成的新位置上不存在数据碰撞为止.&lt;/p&gt;

        &lt;p&gt;在实际应用中, 如果规则定义不当, 就容易在哈希表中出现数据堆积的情况.&lt;/p&gt;

        &lt;p&gt;开放寻址的实现方式一般又有三种:&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107172951.png&quot; alt=&quot;20220107172951&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重哈希的策略是什么? 何时需要重哈希?&lt;/p&gt;

    &lt;p&gt;重哈希的策略是: 首先调整在哈希函数中涉及到的变量: &lt;strong&gt;存储数组的预期大小&lt;/strong&gt;, 然后新建一个大小为预期尺寸的, 比原数组更大的空数组.&lt;/p&gt;

    &lt;p&gt;然后, 基于这个 &lt;strong&gt;修改过的哈希函数&lt;/strong&gt; (哈希函数中取模时依赖的, 存储数组的预期大小变大了) 将原数组中的所有元素全部重哈希到新数组中.&lt;/p&gt;

    &lt;p&gt;丢掉原数组, 将更大的新数组视为哈希表的存储数组.&lt;/p&gt;

    &lt;p&gt;我们使用反映哈希表的存储数组的利用率的变量 &lt;strong&gt;负载常数&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Load Factor&lt;/code&gt;) 检测哈希表的使用率, 从而控制何时执行重哈希.&lt;/p&gt;

    &lt;p&gt;一般而言, 我们会选定重哈希阈值为 $0.75$.&lt;/p&gt;

    &lt;p&gt;如果阈值选定不当, 会导致哈希表的存储数组中可用的剩余空间过少, 以至于在查询和插入数据时哈希函数的数据碰撞次数显著增大, 在最坏情况下对哈希表的搜索操作会退化为线性搜索, 而在一般情况下搜索的时间复杂度仅为 $O(1)$.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-搜索树&quot;&gt;2.2 搜索树&lt;/h3&gt;

&lt;p&gt;我们称形如现实生活中的树木的, 由某一个单一的 (根) 结点向下扩展的, 具有树状拓扑结构的数据结构为 &lt;strong&gt;树&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;一棵 (抽象的) 树由一个 &lt;strong&gt;根结点&lt;/strong&gt; , 数个 &lt;strong&gt;叶子结点&lt;/strong&gt; 和在此之间的 &lt;strong&gt;内部节点&lt;/strong&gt; 构成, 除了根结点外, 每个节点都有一个与之对应的 &lt;strong&gt;父节点&lt;/strong&gt;; 而除了叶子结点外, 每个节点都有至少一个 &lt;strong&gt;子节点&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;常见的树有:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107203637.png&quot; alt=&quot;20220107203637&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Proper Binary Tree&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Full Binary Tree&lt;/code&gt; (满二叉树) $\Rightarrow$ 每个节点的度或为 $0$ 或为 $2$.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Complete Binary Tree&lt;/code&gt; (完全二叉树) $\Rightarrow$ 叶子结点只出现在 &lt;strong&gt;最下层或次下层&lt;/strong&gt;, 且 &lt;strong&gt;最下层的叶子结点集中出现在树的左部&lt;/strong&gt; (除了最后一层外, 其他各层节点数都达到最大, 且最后一层的节点都连续集中在最左边).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Perfect Binary Tree&lt;/code&gt; (完美二叉树) $\Rightarrow$ 在满二叉树的基础上, 所有叶子结点深度均相同.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而 &lt;strong&gt;二叉树&lt;/strong&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 表示如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107203725.png&quot; alt=&quot;20220107203725&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以使用数组和链表来表示二叉树:&lt;/p&gt;

&lt;p&gt;若用数组的形式来构建二叉树, 则节点存在数组中, 节点在数组中的位置对应它在树中的位置, 下标为 $0$ 的节点为根节点, 下标为 $1$ 是根的左节点, $2$ 为根节点的右节点, 依次类推, 从左到右的顺序存储树的每一层, &lt;strong&gt;包括空节点&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;给定某个 &lt;strong&gt;节点&lt;/strong&gt; 的索引值为 $x$, 则其左子节点和右子节点的索引值分别为 $2 \cdot x + 1$ 和 $2 \cdot x + 2$, 而其父节点的索引为 $(x-1)/2$.&lt;/p&gt;

&lt;p&gt;这种表示方法只有在存储 &lt;strong&gt;完全二叉树&lt;/strong&gt; 时效率才会达到最高, 如果用于存储普通二叉树, 由于数组中会包含大量空节点, 因此实际上浪费了存储空间.&lt;/p&gt;

&lt;p&gt;若用链表的形式来构建二叉树, 则树的每个节点都是一个链表节点, 依据树中的连接关系而相互链接. 链表法确保不存在任何空节点, 同时在执行插入和删除操作时也有很高的效率, 但是在树中检索的困难度相比数组法高了很多.&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;二叉树的 &lt;strong&gt;外部节点&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exterior Node&lt;/code&gt;) 指他的叶子结点.&lt;/li&gt;
  &lt;li&gt;二叉树中结点所拥有的子树个数称为结点的 &lt;strong&gt;度&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Degree&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;二叉树的 &lt;strong&gt;高度&lt;/strong&gt; 为树中所有节点深度的最大值, 也就是从叶子结点到根节点所需要经过的边的 &lt;strong&gt;最大值&lt;/strong&gt;, 从 $0$ 起算.&lt;/li&gt;
  &lt;li&gt;二叉树中节点的深度为从该节点到树的根节点所需经过边的数量, 也是从 $0$ 起算.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再来看二叉树的插入和删除规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;二叉树节点的插入: 只需基于给定的被插入值大小沿着树遍历, 直到在保持不变量基础上, 左子节点 (或对应的, 右子节点) 为空的节点, 然后将新节点作为该节点的左子节点/右子节点插入即可.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二叉树节点的删除:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;case 1: 若要被删除的结点为叶子结点或左右子节点均为空, 则直接删除节点的父节点中, 对应指向该节点的指针.&lt;/li&gt;
      &lt;li&gt;case 2: 若要被删除的节点有一个子节点 (左子节点或右子节点), 则将该节点的父节点中, 对应的指针指向它的子节点即可.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;case 3: 若要被删除的节点有两个子节点, 就需要从这个被删除节点开始执行 &lt;strong&gt;中序遍历&lt;/strong&gt; 来找到它的 &lt;strong&gt;后继节点 $p$&lt;/strong&gt; (一般是左子树中的最大值所在的节点或右子树的最小值所在的节点).&lt;/p&gt;

        &lt;p&gt;然后将被删除节点和 $p$ 的值调换, 递归地执行对节点 $p$ 的删除操作, &lt;strong&gt;这也是删除根节点所对应的状况&lt;/strong&gt;:&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            
       &lt;span class=&quot;c1&quot;&gt;// 先遍历到目标节点位置上, 若找不到目标节点则直接返回当前所在节点不改动树&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
            
       &lt;span class=&quot;c1&quot;&gt;// 定位到节点后开始删除&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;// case 1, 2: 直接删除, 子树提升一级&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;// case 3: 找到右子树中被删除节点的后继, 交换值后递归删除后继&lt;/span&gt;
               &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;c1&quot;&gt;// 中序遍历找后继&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
               &lt;span class=&quot;c1&quot;&gt;// 交换节点值&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;c1&quot;&gt;// (递归) 删除后继, 或者后继的后继, ....&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般对二叉树的检索 (遍历) 方法有三种: 前序, 中序与后序遍历:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204458.png&quot; alt=&quot;20220107204458&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204519.png&quot; alt=&quot;20220107204519&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204530.png&quot; alt=&quot;20220107204530&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而对树的搜索方式也有两种: &lt;strong&gt;优先沿着子节点检索每一条路径的深度优先搜索&lt;/strong&gt; 和 &lt;strong&gt;优先检索同深度下的其他节点, 然后再检索更高深度下子节点的广度优先搜索&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204700.png&quot; alt=&quot;20220107204700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204717.png&quot; alt=&quot;20220107204717&quot; /&gt;&lt;/p&gt;

&lt;p&gt;二叉搜索树相比二叉树, 限定了每个节点和其子节点之间, 节点值大小的相对关系, 使其可以用于表示经过排序的数组, 在二叉搜索树中搜索任意数据在一般情况下可以获得 $O(\log(n))$ 的时间复杂度.&lt;/p&gt;

&lt;p&gt;二叉搜索树中的不变量为: 对任何节点, &lt;strong&gt;左子节点的值小于等于父节点的值小于右子节点的值&lt;/strong&gt;. 在二叉搜索树中检索某个变量的值, 实际上等价于在一个经过排序的数组中执行二分查找.&lt;/p&gt;

&lt;p&gt;但是二叉搜索树的性能受其结构的影响很大. 在一般情况下, 其插入, 检索和删除操作的时间复杂度均为 $O(\log(n))$, 若树是 &lt;strong&gt;不平衡的&lt;/strong&gt;, 如: 每个节点的左子树大小远大于右子树, 则在遍历每个节点时都无法有效地剪枝, 因而搜索次数增加, 搜索操作消耗的时间也相应增加. 在最坏情况下, 二叉搜索树的性能可能退化到和线性搜索相当的地步, 三种操作的时间复杂度全部退化为 $O(n)$.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树 (自平衡二叉树) 是为了解决这一问题而设计出的数据结构. 其主要特征 (也是解决二叉树不平衡导致的性能衰减问题的手段) 是, 它维护了另一个不变量: &lt;strong&gt;节点的平衡度&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树中, 节点的平衡度 被定义为: &lt;strong&gt;该节点左右子树高度差的绝对值&lt;/strong&gt;, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树相比二叉搜索树, 所维护的第二个不变量就是, 对树中的任何节点而言, 它的平衡度必须 &lt;strong&gt;小于等于 $1$&lt;/strong&gt;, 该属性也被称为 &lt;strong&gt;高度平衡属性&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Height-Balance Property&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;对平衡度的维护确保在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树中, 每个节点的所有子树都基本平衡, 而维护平衡度的方式为: 在对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树执行每一次插入和删除操作时, 都需要执行 &lt;strong&gt;旋转操作&lt;/strong&gt; 以维护该节点的平衡度.&lt;/p&gt;

&lt;p&gt;下面考虑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树中对节点的旋转操作:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树的旋转分为 &lt;strong&gt;单旋转&lt;/strong&gt; 和 &lt;strong&gt;双旋转&lt;/strong&gt;, 任何旋转操作都有两个属性: &lt;strong&gt;旋转轴&lt;/strong&gt; 和 &lt;strong&gt;旋转方向&lt;/strong&gt;. 旋转轴本质就是 &lt;strong&gt;旋转之后的子树的节点&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在单旋转中, 旋转轴为 &lt;strong&gt;不满足高度平衡属性的最小树&lt;/strong&gt; 的 &lt;strong&gt;根节点对应的子节点&lt;/strong&gt; (儿子节点).&lt;/p&gt;

&lt;p&gt;在双旋转中, 旋转轴为 &lt;strong&gt;不满足高度平衡属性的最小树&lt;/strong&gt; 的 &lt;strong&gt;根节点对应的子节点的子节点&lt;/strong&gt; (孙子节点).&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;左旋&lt;/p&gt;

    &lt;p&gt;如果观察到某个节点 &lt;strong&gt;不满足高度平衡属性&lt;/strong&gt; 且它的 &lt;strong&gt;右子树&lt;/strong&gt; 高于左子树, 则需要对该节点执行 &lt;strong&gt;左旋操作&lt;/strong&gt;:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;将指向该节点的指针改为指向它的右子树.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将该节点右子树改为它的 &lt;strong&gt;右子树的左子树&lt;/strong&gt;:&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108113003.png&quot; alt=&quot;20220108113003&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;在完成旋转操作后:&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;根节点从原节点变为它的右子节点.&lt;/li&gt;
      &lt;li&gt;原节点从根节点变为根节点的左子节点.&lt;/li&gt;
      &lt;li&gt;根节点的右子节点的左子节点变为根节点的左子节点的右子节点.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右旋&lt;/p&gt;

    &lt;p&gt;如果观察到某个节点 &lt;strong&gt;不满足高度平衡属性&lt;/strong&gt; 且它的 &lt;strong&gt;左子树&lt;/strong&gt;高于右子树, 则需要对该节点执行 &lt;strong&gt;右旋操作&lt;/strong&gt;:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;将指向该节点的指针改为指向它的左子树.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将该节点左子树改为它的 &lt;strong&gt;左子树的右子树&lt;/strong&gt;:&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108112733.png&quot; alt=&quot;20220108112733&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;在完成旋转操作后:&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;根节点从原节点变为它的左子节点.&lt;/li&gt;
      &lt;li&gt;原节点从根节点变为根节点的右子节点.&lt;/li&gt;
      &lt;li&gt;根节点的左子节点的右子节点变为根节点的右子节点的左子节点.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左-右旋&lt;/p&gt;

    &lt;p&gt;如果观察到某个节点 &lt;strong&gt;不满足高度平衡属性&lt;/strong&gt; 且它的右子节点呈现出 “左重右轻” 的特点, 也就是该节点有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Left-heavy Right subtree&lt;/code&gt;, 则需要执行左-右旋: 先以右子节点为轴执行一次右旋让右子结点从 “左重右轻” 变成 “左轻右重”, 然后以原节点为轴执行一次左旋.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108113803.png&quot; alt=&quot;20220108113803&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220112094950.png&quot; alt=&quot;20220112094950&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右-左旋&lt;/p&gt;

    &lt;p&gt;如果观察到某个节点 &lt;strong&gt;不满足高度平衡属性&lt;/strong&gt; 且它的左子节点呈现出 “右重左轻” 的特点, 也就是该节点有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Right-heavy Left subtree&lt;/code&gt;, 则需要执行右-左旋: 先以左子节点为轴执行一次左旋让左子结点从 “右重左轻” 变成 “左重右轻”, 然后以原节点为轴执行一次右旋.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108113929.png&quot; alt=&quot;20220108113929&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220112095236.png&quot; alt=&quot;20220112095236&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是, 具有 $n$ 个节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树高度为 $O(\log(n))$.&lt;/p&gt;

&lt;h3 id=&quot;23-二叉堆-优先序列-跳跃表和并查集&quot;&gt;2.3 二叉堆, 优先序列, 跳跃表和并查集&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;二叉堆&lt;/strong&gt; 是一种特殊的完全二叉树 (注意它不是二叉搜索树), 它在 &lt;strong&gt;作为完全二叉树&lt;/strong&gt; 的基础上保持了另一个不变量: &lt;strong&gt;堆序性质&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108132915.png&quot; alt=&quot;20220108132915&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在构造二叉堆时, 由于二叉堆本身是完全二叉树, 因此可以使用数组实现它而 &lt;strong&gt;基本忽略空间浪费&lt;/strong&gt;, 因为完全二叉树的定义决定它除了最后一层以外, 其余的所有节点度或为 $0$ 或为 $2$, 不构成空间浪费. 二叉堆的构造的时间复杂度最坏情况下为 $O(n\log(n))$.&lt;/p&gt;

&lt;p&gt;下面考虑最大堆的 &lt;strong&gt;插入&lt;/strong&gt;, &lt;strong&gt;删除&lt;/strong&gt; 和 &lt;strong&gt;创建&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;向堆中插入元素 (本质是新节点的上浮)&lt;/p&gt;

    &lt;p&gt;在向现存的二叉堆插入元素时, 我们需要 &lt;strong&gt;将元素添加到表示堆的数组的末尾&lt;/strong&gt;, 形式上就是: 将新节点 &lt;strong&gt;作为倒数第二层中, 从左往右数第一个度不为 $2$ 的节点的子节点&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;在将元素插入后, 我们需要对 &lt;strong&gt;整个堆&lt;/strong&gt; 都重新维护它的 &lt;strong&gt;堆序性质&lt;/strong&gt;:我们需要 &lt;strong&gt;自底向上&lt;/strong&gt; 地依次检查子树的堆序, 直到检查指针上浮到根节点为止.&lt;/p&gt;

    &lt;p&gt;记堆包含 $n$ 个元素, 则它是一棵高为 $\log(n)$ 的二叉树, 因此插入函数的时间复杂度为 $O(\log(n))$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从堆中删除元素 (本质是最大堆的最后一个节点的下沉)&lt;/p&gt;

    &lt;p&gt;我们只能 &lt;strong&gt;从最大堆中移除最大值&lt;/strong&gt;. 在删除根节点后, 堆被拆分成了两棵树. 此时我们需要取 &lt;strong&gt;子树的最后一个节点&lt;/strong&gt; 充当树的根节点. 在此之后, &lt;strong&gt;自顶向下&lt;/strong&gt; 地递归维护树的 &lt;strong&gt;堆序性质&lt;/strong&gt;, 不难看出删除函数的时间复杂度也为 $O(\log(n))$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建最大堆的本质就是 &lt;strong&gt;自底向上&lt;/strong&gt; 地维护某棵二叉树.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;优先序列&lt;/strong&gt; 可以表示为某个最大堆, 我们人为规定 &lt;strong&gt;堆中值最大的元素即为优先级最高的元素&lt;/strong&gt;. 而 &lt;strong&gt;向优先序列中插入数据&lt;/strong&gt; 或 &lt;strong&gt;从优先序列中删除数据&lt;/strong&gt; 的方法与 &lt;strong&gt;最大堆中对数据的插入和删除&lt;/strong&gt; 是一致的.&lt;/p&gt;

&lt;p&gt;优先序列 / 最大堆是基于完全二叉树基础上改进而来的数据结构, 而跳跃表则基于链表 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linked List&lt;/code&gt;) 基础上改进而来的, 其本质是可以快速查找的 &lt;strong&gt;有序链表&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;对于普通的链表而言, 我们只能从表头开始一个个地遍历查找. 而 &lt;strong&gt;有序链表&lt;/strong&gt; 在 &lt;strong&gt;链表&lt;/strong&gt; 基础上做的改进就是给链表加上了不同层级的 &lt;strong&gt;索引&lt;/strong&gt;, 使我们可以沿着不同层级的索引基于要搜索的值和当前索引节点的值, 快速地跳过中间节点从而接近目标节点. 在存储的数据够多的情况下, 还可以继续构造第二层, 第三层, 甚至更高层的节点, 确保 &lt;strong&gt;每一层节点数是上一层节点数的一半&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108192116.png&quot; alt=&quot;20220108192116&quot; /&gt;&lt;/p&gt;

&lt;p&gt;向跳跃表中插入节点的流程有以下几步:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将新节点插入到原链表中.&lt;/li&gt;
  &lt;li&gt;对这个新节点, 使用 &lt;strong&gt;抛硬币&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Coin Flipping&lt;/code&gt;) 的方式决定它将被提升为哪一级的索引:连续 “抛硬币” (模拟抛硬币), 直到抛出 $0$ 为止, 在此之前抛出了多少个 $1$ 就将这个节点提升为哪一级的索引.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而从跳跃表中删除节点的流程就相对简单: 从最高级别的索引开始, 依次查找要被删除的目标节点, 并 &lt;strong&gt;逐层找到每一层对应的节点&lt;/strong&gt;, 删除每一层中查找到的目标节点. 若该层没有目标节点则在下一层寻找, 若该层只剩下这一个节点则删除这一整层 (除非这一层已经是链表层了).&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;跳跃表的索引是在 &lt;strong&gt;每一次插入新数据和删除旧数据时&lt;/strong&gt; 都被维护的.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一般情况下, 跳跃表的插入与删除的时间复杂度均为 $O(\log(n))$, 而跳跃表的空间复杂度 (所占空间) 为 $O(N)$ (实际上由于每个元素的期望高度为 $2$, 其实际占用空间应该是2N).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;并查集是一种 &lt;strong&gt;树状&lt;/strong&gt; 的数据结构, 用于处理一系列 &lt;strong&gt;不相交集合&lt;/strong&gt; 的查询与合并问题.&lt;/p&gt;

&lt;p&gt;并查集可以用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AVL&lt;/code&gt; 树与哈希表实现, 但唯一切合实际的实现方式是构造两个大小相同的数组: 第一个数组存储实际的数据, 而第二个数组存储每个索引对应的父节点, 拥有相同父节点的所有索引被视为属于同一个集合中, 这个集合用父节点表示. 这样可以在执行 &lt;strong&gt;查询操作&lt;/strong&gt; 和 &lt;strong&gt;插入操作&lt;/strong&gt; 时提供最高的效率.&lt;/p&gt;

&lt;p&gt;并查集的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 表 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADT&lt;/code&gt; 定义) 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109190712.png&quot; alt=&quot;20220109190712&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于并查集本质是是 &lt;strong&gt;树状结构&lt;/strong&gt; 的, 因此若在结构中出现某棵子树过高的情况时, 就有可能明显增加查询时间从而降低数据结构的性能. 这一问题有两种常见的解决方案:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Splitting&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;对某并查集的某个元素执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Splitting&lt;/code&gt; 时, 我们将无差别地将 &lt;strong&gt;从该元素到根节点的路径上每个节点的父节点都替换为它的祖父节点&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109191754.png&quot; alt=&quot;20220109191754&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Halving&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;对某并查集的某个元素执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Halving&lt;/code&gt; 时, 我们只考虑 &lt;strong&gt;从该元素到根节点的路径上&lt;/strong&gt; 以该元素起算的第 $1, 3, 5, …$ 个节点 (也就是该元素, 该元素的祖父节点, 该元素祖父节点的祖父节点, …), 只将它们的父节点都替换为它们的祖父节点.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109191811.png&quot; alt=&quot;20220109191811&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Compression&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;对某并查集的某个元素执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Compression&lt;/code&gt; 时, 我们将 &lt;strong&gt;从该元素到根节点的路径上经过的每个节点&lt;/strong&gt; 的父节点都替换为根节点.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109191716.png&quot; alt=&quot;20220109191716&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-算法设计技术&quot;&gt;3. 算法设计技术&lt;/h2&gt;

&lt;p&gt;算法的存在意义是用于解决各种现实问题. 一般而言, 我们需要解决的问题可以被划分为下列五类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;决策性问题: 给定输入, 算法需要给出非黑即白的答案.&lt;/li&gt;
  &lt;li&gt;功能性问题: 给定输入, 算法需要给出一个解, 但解的结构按照具体问题不同而变化.&lt;/li&gt;
  &lt;li&gt;搜索问题: 给定输入或条件, 算法需要从某个解空间中找出适合的答案.&lt;/li&gt;
  &lt;li&gt;计数问题: 算法需要统计解空间中有多少个可行解.&lt;/li&gt;
  &lt;li&gt;优化问题: 算法需要从解空间中找出相对最好的解.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-问题分解-动态规划与分治&quot;&gt;1. 问题分解: 动态规划与分治&lt;/h3&gt;

&lt;p&gt;分治法的定义已经在前文中描述过, 其典例即为二分查找问题.&lt;/p&gt;

&lt;p&gt;动态规划和分治算法类似, 也是通过将原问题拆分为多个子问题来将其解决的, 但区别在于, 分治算法的子问题 &lt;strong&gt;彼此无关&lt;/strong&gt;, 而动态规划拆分的子问题之间彼此又有共同部分. 其核心即为: 通过将子问题之间共通部分的计算结果存储起来, 在下一次需要的时候直接调用而无需重复计算, 由此 “用空间换时间”.&lt;/p&gt;

&lt;p&gt;分治和动态规划都可通过 (或者就是通过) 存储已被解决的子问题实现性能优化的. 而二者的最大差异在于, 分治对子问题的划分是 &lt;strong&gt;自顶向下&lt;/strong&gt; 的, 而动规是 &lt;strong&gt;自底向上&lt;/strong&gt; 的.&lt;/p&gt;

&lt;p&gt;一般而言, 能够使用动态规划求解的问题具有下列的三个性质:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;若问题的最优解包含的子问题的解也是最优的, 也就是说该问题具有 &lt;strong&gt;最优子结构&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;在问题中, 任何状态下的决策都不会影响之前的状态.&lt;/li&gt;
  &lt;li&gt;子问题之间相互重叠, 一个子问题在下一阶段的决策中也可能被用到.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-解空间搜索-深度优先-分支定界-贪心搜索和启发式搜索&quot;&gt;2. 解空间搜索: 深度优先, 分支定界, 贪心搜索和启发式搜索&lt;/h3&gt;

&lt;p&gt;称 &lt;strong&gt;需要在问题的解空间内对问题的解进行搜索&lt;/strong&gt; 的问题为 &lt;strong&gt;解空间搜索问题&lt;/strong&gt;, 例如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 问题: 找出某个形为一系列子句的合取的谓词公式的一个解释.&lt;/p&gt;

&lt;p&gt;若问题的解是可以通过某种逻辑或顺序依次生成 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generate&lt;/code&gt;) 的, 则也称这样的问题为列举 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enumeration&lt;/code&gt;). 一般地, 在解空间中对问题可行解的列举流程/路径会自然地形成树状结构, 每个叶子结点代表一个可行解, 而不同的路径对应不同解的生成过程. 因此, 对问题的求解就可被理解为在这个搜索树/决策树上的搜索问题.&lt;/p&gt;

&lt;p&gt;需要注意: 若给定问题总共有 $n$ 个可能解, 则求解这个问题的列举操作的时间复杂度为 $O(n)$, 因为在最坏情况下使用列举法可能需要将它们全部遍历一遍才能最后找到唯一的可行解.&lt;/p&gt;

&lt;p&gt;此外, 单纯的列举操作不需要对部分解进行判断 (这是回溯法的优化方向), 也不存在 “无需考虑全部解” 的情况 (这是分支定界的优化方向).&lt;/p&gt;

&lt;p&gt;我们可以使用下列的任一种方式优化求解算法的性能:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;回溯算法: 从根节点开始按照某种顺序一步步地构造可行解, 若使用某种组合构造出的解不可行则回退到上一步尝试其他方案, 并继续检查生成的新解. 重复这一过程, 最终只要原问题有解, 就必然可以得到一个可行解.&lt;/li&gt;
  &lt;li&gt;分支定界算法: 在回溯算法的基础上, 维护一个 “当前最优解” 并在作出分支选择 (构造解) 时不断比较, 舍弃那些确定无法得到更优解的决策分支 (也就是剪枝 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pruning&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述的两种算法都具备相同的特征:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220110014159.png&quot; alt=&quot;20220110014159&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;贪心算法&lt;/strong&gt; 的显著特征是, 它在构造可行解时永远会选择 &lt;strong&gt;当前最优&lt;/strong&gt; 的决策路径. 在一般情况下, 显然这样的策略不能保证算法一定可以找到 &lt;strong&gt;全局最优解&lt;/strong&gt;, 但若我们需要解决的问题具有下列的属性, 则贪心算法是一个很好的选择:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;该问题的全局最优解可以表示为多个局部最优解的组合.&lt;/li&gt;
  &lt;li&gt;或者该问题解的前部分不能被后部分所影响. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;We can make a series of choices such that we never need to go back and change the choice later&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;REFERENCE:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cherryljr/p/6669489.html&quot;&gt;AVL树的旋转操作详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/21bef3fc3030&quot;&gt;最大堆（创建、删除、插入和堆排序）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cs.cornell.edu/courses/cs3110/2012sp/lectures/lec21-amortized/lec21.html&quot;&gt;Lecture 21: Amortized Analysis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://algocoding.wordpress.com/2015/05/13/simple-union-find-techniques/&quot;&gt;Simple union-find techniques&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Jan 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/01/05/COMP26120-REV/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/01/05/COMP26120-REV/</guid>
        
        <category>2021</category>
        
        <category>数据结构和算法</category>
        
        <category>COMP26120</category>
        
        
      </item>
    
      <item>
        <title>人工智能导论 用于通讯的自然语言</title>
        <description>&lt;h1 id=&quot;用于通讯的自然语言&quot;&gt;用于通讯的自然语言&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;通讯&lt;/strong&gt; 是一种通过 &lt;strong&gt;产生和感知信号&lt;/strong&gt; 而形成的, &lt;strong&gt;有目的的信息交换&lt;/strong&gt;. 在一个 &lt;strong&gt;部分可观察&lt;/strong&gt; 的世界中, 通讯有助于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 达成它的目的, 因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 能够通过通讯获得 &lt;strong&gt;由其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 观察到或推断出的信息&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;如果我们希望我们构造的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 能够对人类有所帮助的话, 它们就需要具备学习和使用语言的能力. 本章我们考虑用于通讯的语言模型.&lt;/p&gt;

&lt;h2 id=&quot;1-短语结构语法&quot;&gt;1. 短语结构语法&lt;/h2&gt;

&lt;p&gt;我们在上一章中提到过 &lt;strong&gt;$n$ 元语言模型&lt;/strong&gt;, 它基于单词序列, 但其最大的问题在于 &lt;strong&gt;数据稀疏&lt;/strong&gt;, 即使语料库中由上万亿个单词, 也无法提供可靠的评估.&lt;/p&gt;

&lt;p&gt;我们下面介绍一个 &lt;strong&gt;基于短语结构思想&lt;/strong&gt; 的语言模型: &lt;strong&gt;概率上下文无关语法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Probabilistic Context-Free Grammar&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PCFG&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Grammar&lt;/code&gt;) 是 &lt;strong&gt;一系列规则组成的集合&lt;/strong&gt;, 它将语言定义为一个被允许的词串集合, 而 &lt;strong&gt;概率&lt;/strong&gt; 意味着这个语法给每个字符串都分配了一个概率. 下面是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PCFG&lt;/code&gt; 规则:&lt;/p&gt;

\[\begin{aligned} VP \rightarrow &amp;amp; ~~ \text{Verb}[0.70] \\ \vert &amp;amp; ~~\text{VP} ~ \text{NP} [0.30]\end{aligned}\]

&lt;p&gt;其中, $\text{VP}$ (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Verb Phrase&lt;/code&gt;, 动词短语) 和 $\text{NP}$ (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Noun Phrase&lt;/code&gt;, 名词短语) 是 &lt;strong&gt;非终结符&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Non-terminal Symbols&lt;/code&gt;), 语法也会用到真正的单词, 也就是 &lt;strong&gt;终结符&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Terminal Symbols&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;这条规则表示: 动词短语 &lt;strong&gt;单独由动词组成&lt;/strong&gt; 的概率为 $0.70$, 而由一个 $\text{VP}$ 再连上一个 $\text{NP}$ 组成的概率为 $0.30$.&lt;/p&gt;

&lt;p&gt;下面我们针对一小部分英文定义语法, 我们称其为 $\epsilon_0$ 语言:&lt;/p&gt;

&lt;h3 id=&quot;epsilon_0-的词典&quot;&gt;$\epsilon_0$ 的词典&lt;/h3&gt;

&lt;p&gt;首先定义一个 &lt;strong&gt;词典&lt;/strong&gt; 或 &lt;strong&gt;合法的词语列表&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexicon&lt;/code&gt;): 这些词语按照一种字典使用者熟悉的 &lt;strong&gt;词法范畴&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexical Categories&lt;/code&gt;)进行分类:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220105143135.png&quot; alt=&quot;20220105143135&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个以 $\cdots$ 结尾的范畴说明在该范畴内还有其他词语. 对 &lt;strong&gt;名词&lt;/strong&gt;, &lt;strong&gt;动词&lt;/strong&gt;, &lt;strong&gt;形容词&lt;/strong&gt;, &lt;strong&gt;副词&lt;/strong&gt; 和 &lt;strong&gt;名字&lt;/strong&gt; 而言, 由于我们不可能将它们全部列出, 因此称这五个范畴为 &lt;strong&gt;开放类&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open Class&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;而对于 &lt;strong&gt;代词&lt;/strong&gt;, &lt;strong&gt;关系代词&lt;/strong&gt;, &lt;strong&gt;介词&lt;/strong&gt;, &lt;strong&gt;冠词&lt;/strong&gt; 和 &lt;strong&gt;连词&lt;/strong&gt;, 它们是可以被全部列举出的, 因此称这些范畴为 &lt;strong&gt;封闭类&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Closed Class&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;epsilon_0-的语法&quot;&gt;$\epsilon_0$ 的语法&lt;/h3&gt;

&lt;p&gt;在定义了 $\epsilon_0$ 的词典后, 下一步就需要给出该语言的, 用来描述如何合法地将单词组合成短语/句子的 &lt;strong&gt;语法&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220105143625.png&quot; alt=&quot;20220105143625&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是, 这一给定的语法是可能 &lt;strong&gt;生成不符合语法的语句&lt;/strong&gt; (即 “过生成”) 的, 也可能 &lt;strong&gt;欠生成&lt;/strong&gt; (认为很多实际上在英语中合法的语句为不合法的).&lt;/p&gt;

&lt;p&gt;我们先考虑, 运用现有语法我们可以做些什么.&lt;/p&gt;

&lt;h2 id=&quot;2-句法分析&quot;&gt;2. 句法分析&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;句法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parsing&lt;/code&gt;) 是 &lt;strong&gt;按照语法规则分析单词串 (句子)&lt;/strong&gt; 从而 &lt;strong&gt;得到它的短语结构&lt;/strong&gt; 的过程.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220105143922.png&quot; alt=&quot;20220105143922&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可见, 我们既可以从符号 $S$ 出发, &lt;strong&gt;自顶向下&lt;/strong&gt; 地搜索并构造 &lt;strong&gt;以单词作为叶子结点&lt;/strong&gt; 的树, 也可从单词出发, &lt;strong&gt;自底向上地&lt;/strong&gt; 搜索并构造树, 直到顶端 $S$.&lt;/p&gt;

&lt;p&gt;(后面的部分你校的Slides里就没怎么介绍了, 鸽掉)&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2021/12/31/COMP24011-Ch8/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/31/COMP24011-Ch8/</guid>
        
        <category>2021</category>
        
        <category>课程笔记</category>
        
        <category>COMP24011</category>
        
        
      </item>
    
      <item>
        <title>人工智能导论 自然语言处理</title>
        <description>&lt;h1 id=&quot;自然语言处理&quot;&gt;自然语言处理&lt;/h1&gt;

&lt;p&gt;本章将研究如何利用以自然语言描述的知识, 并介绍对自然语言进行信息检索和信息提取的一般方法.&lt;/p&gt;

&lt;h2 id=&quot;1-语言模型&quot;&gt;1. 语言模型&lt;/h2&gt;

&lt;p&gt;形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Haskell&lt;/code&gt; 的程序设计语言都有 &lt;strong&gt;精确定义的语言模型&lt;/strong&gt;, 这种语言可以被定义为 &lt;strong&gt;字符串的集合&lt;/strong&gt;, 并且可以 &lt;strong&gt;通过一组称为 “语法” 的规则描述&lt;/strong&gt;. 形式语言也可通过规则来定义 &lt;strong&gt;程序的意义或语义&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而自然语言, 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;English&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;中文&lt;/code&gt;, 则无法被描述为一个 &lt;strong&gt;确定的语句集合&lt;/strong&gt;, 因此我们一般需要通过 &lt;strong&gt;句子的概率分布&lt;/strong&gt; 而非 &lt;strong&gt;集合&lt;/strong&gt; 定义自然语言模型.&lt;/p&gt;

&lt;p&gt;换言之, 给定某个字符串 “Axton is so strong!!!111”, 我们关注的是一个随机的句子恰为这个字符串的概率是多少, 而非考虑这个字符串是否属于定义语言的句子集合.&lt;/p&gt;

&lt;p&gt;同时, 自然语言具有歧义: 一个句子在不同的语境下可以解释为多个含义. 我们往往难以只用一个意义来解释某个句子, 而需要使用多个意义上的概率分布.&lt;/p&gt;

&lt;p&gt;最后, 需要说明的是, 自然语言的规模极其庞大, 并且时刻处于变化和演化之中. 因此, 我们的语言模型只能是 &lt;strong&gt;对自然语言的模拟&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;2-n-元字符模型&quot;&gt;2. $n$ 元字符模型&lt;/h2&gt;

&lt;p&gt;本质上说, 自然语言的 &lt;strong&gt;文本&lt;/strong&gt; 是由 &lt;strong&gt;字符&lt;/strong&gt; 组成的, 如英语中的 &lt;strong&gt;字母, 数字, 标点, 空格&lt;/strong&gt; 等. 因此, 最简单的语言模型就是 &lt;strong&gt;字符序列的概率分布&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;记 &lt;strong&gt;从 $c_1$ 到 $c_N$ 共 $N$ 个字符构成一个文本序列&lt;/strong&gt; 的概率为&lt;/p&gt;

\[P(c_{1 : N}).\]

&lt;p&gt;&lt;strong&gt;定义 2.1&lt;/strong&gt; ($n$ 元组)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;长度为 $n$ 的书写符号序列&lt;/strong&gt; 为 &lt;strong&gt;$n$ 元组&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n-gram&lt;/code&gt;) 的.&lt;/p&gt;

  &lt;p&gt;注意, 我们分别用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unigram&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bigram&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trigram&lt;/code&gt; 表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一元组&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;二元组&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;三元组&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 2.2&lt;/strong&gt; ($n$ 元模型)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;$n$ 个字符序列上的概率分布&lt;/strong&gt; 为 $n$ 元模型.其中, 构成自负序列的元素不仅可以是字符, 也可以是 &lt;strong&gt;单词&lt;/strong&gt;, &lt;strong&gt;音节&lt;/strong&gt; 或其他单元.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 2.3&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 链)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们可以简单地认为某一时刻状态的确定 &lt;strong&gt;只依赖于在此之前的 $n$ 个状态&lt;/strong&gt; 的状态链为 $n$ 阶 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 链.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;$n$ 元模型 (不只局限于 $n$ 元字符模型) 可以定义为 $n-1$ 阶 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 链. 显然, 在一个 &lt;strong&gt;三元模型&lt;/strong&gt; (也就是 $2$ 阶 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 链) 中, 我们有:&lt;/p&gt;

\[P(c_i \vert c_{1 : i-1}) = P(c_i \vert c_{i-2: i-1}).\]

&lt;p&gt;也就是说在三元模型中任何位置上的字符 $c_i$ 为某个字符的概率只由于它前面的两个位置上的字符决定.&lt;/p&gt;

&lt;p&gt;在三元模型中, 我们结合 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;链式规则&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov 假设&lt;/code&gt; 定义长为 $N$ 的字符序列的概率:&lt;/p&gt;

\[P(c_{1:N}) = \prod_{i=1}^{N}P(c_i \vert c_{1:i-1}) = \prod_{i=1}^{N}P(c_i \vert c_{i-2:i-1}).\]

&lt;p&gt;对于某个包含 $n$ 个字符的语言的三元字符模型, $P(c_i \vert c_{i-2:i-1})$ 有 $n^3$ 项参数. 我们可以通过对包含大量字符的文本集合进行精确的计数统计而得到, 我们称文本的集合为 &lt;strong&gt;语料库&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Corpus&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;我们可以使用字符模型完成 &lt;strong&gt;文本题材分类, 拼写纠错, 语言识别&lt;/strong&gt; 等任务.&lt;/p&gt;

&lt;h2 id=&quot;3-n-元模型的平滑&quot;&gt;3. $n$ 元模型的平滑&lt;/h2&gt;

&lt;p&gt;$n$ 元模型的问题在于 &lt;strong&gt;训练语料只提供了真实概率分布的估计值&lt;/strong&gt;, 而无法提供所有的边界情况. 因此, 我们需要采取措施使我们的语言模型能够有效地 &lt;strong&gt;扩展到在语料库中从未见到过的文本上&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;要实现这一点, 我们要通过改进语言模型使在训练文本库中出现概率为 $0$ 的字符序列仍能够被赋予一个 &lt;strong&gt;很小的非零概率值&lt;/strong&gt;, 并将其他的数值同样小幅度下降使得概率的完备性仍然成立, 这一过程也被称为 &lt;strong&gt;平滑&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 3.1&lt;/strong&gt; (平滑)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称通过赋予给定训练数据集中出现频率极低或未出现的数据一个较小的频率值, 从而使频率模型能够被扩展到一般情形的, 调整低频计数的过程为 &lt;strong&gt;平滑&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们下面给出两种常用的简单平滑方法:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Laplace&lt;/code&gt; 平滑:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Laplace&lt;/code&gt; 平滑指定, 若某个随机布尔变量 $X$ 在目前已有的 $n$ 个观察值中恒为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;, 则&lt;/p&gt;

\[P(X = \text{true}) = \frac{1}{n+2}.\]

    &lt;p&gt;换言之, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Laplace&lt;/code&gt; 平滑假定 &lt;strong&gt;多进行两次试验&lt;/strong&gt;, 可能 &lt;strong&gt;一个值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;, 另一个为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;回退模型和线性插值平滑&lt;/p&gt;

    &lt;p&gt;回退模型的基本思想是: 首先进行 $n$ 元计数统计, 若某些序列的统计值 &lt;strong&gt;很低或者为零&lt;/strong&gt;, 则回退到 $n-1$ 元.&lt;/p&gt;

    &lt;p&gt;线性插值平滑是一种通过线性插值将 &lt;strong&gt;三元, 二元和一元模型&lt;/strong&gt; 组合起来的后退模型. 线性平滑插值定义概率估计值如下:&lt;/p&gt;

\[\hat{P}(c_i ~\vert~ c_{i-2 : i-1}) = \lambda_{3} \cdot P(c_i ~\vert~ c_{i-2 : i-1}) + \lambda_{2} \cdot P(c_i ~\vert~ c_{i-1}) + \lambda_{1} \cdot P(c_i).\]

    &lt;p&gt;此处系数满足&lt;/p&gt;

\[\lambda_{3} + \lambda_{2} + \lambda_{1} = 1.\]

    &lt;p&gt;参数值可以是固定的, 也可以通过某些算法进行计算. 关于参数值计算的讨论超出本文讨论的范围, 在此按下不表.&lt;/p&gt;

    &lt;p&gt;在 $i=1$ 时, 表达式&lt;/p&gt;

\[P(c_i ~\vert~ c_{i-2 : i-1})\]

    &lt;p&gt;就退化为&lt;/p&gt;

\[P(c_1 ~\vert~ c_{-1 : 0}),\]

    &lt;p&gt;而在 $c_1$ 前并没有字符. 因此, 我们需要引入 &lt;strong&gt;人工字符&lt;/strong&gt; 解决这一问题:&lt;/p&gt;

    &lt;p&gt;我们可以定义 $c_0$ 为空字符, 也可以回退到 &lt;strong&gt;低价 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 模型&lt;/strong&gt;, 定义 $c_{-1 : 0}$ 为 &lt;strong&gt;空序列&lt;/strong&gt;, 从而&lt;/p&gt;

\[P(c_1 ~\vert~ c_{-1:0}) = P(c_1).\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$n$ 元字符模型可以被进一步扩展为 $n$ 元单词模型, 它检验的最小元素从 &lt;strong&gt;字符&lt;/strong&gt; 变为了 &lt;strong&gt;单词&lt;/strong&gt;. $n$ 元单词模型的平滑方法如下:&lt;/p&gt;

&lt;p&gt;引入人工单词:&lt;/p&gt;

&lt;p&gt;人为定义训练数据集中 &lt;strong&gt;每个首次出现的, 与之前遇到的所有单词都不同的单词&lt;/strong&gt; 为 &lt;strong&gt;人工单词&lt;/strong&gt;, 指定在训练数据集中未出现的单词具有的概率为 &lt;strong&gt;人工单词在训练数据集中出现的频率&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;注意被定义为人工单词的单词不会发生改变, 如果 $a$ 在训练数据集中总共出现了 $x$ 次, 则它的第一个出现 $t$ 被指定为人工单词 $o$ &lt;strong&gt;并不会使得它在训练数据集中出现的次数 $-1$&lt;/strong&gt;, 它的出现频率 $n$ 和不将其第一个出现指定为人工单词时的频率相同.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220104161240.png&quot; alt=&quot;20220104161240&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-文本分类-text-classification&quot;&gt;4. 文本分类 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text Classification&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;我们下面讨论 &lt;strong&gt;文本分类&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text Classification&lt;/code&gt;) 问题, 其本质是 &lt;strong&gt;给定一段文本, 判断它属于预定义的一系列类别中的哪一类&lt;/strong&gt;, 其实例包括 &lt;strong&gt;情感分析&lt;/strong&gt; 和 &lt;strong&gt;垃圾邮件检测&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;归类的基本方法有两种: &lt;strong&gt;语言模型方法&lt;/strong&gt; 和 &lt;strong&gt;机器学习方法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;以垃圾邮件检测为例. 我们可以对垃圾邮件进行训练从而得到一个计算&lt;/p&gt;

\[P(\text{Message} ~\vert~ \text{spam})\]

&lt;p&gt;的 $n$ 元语言模型, 并对正常邮件进行同样的训练, 得到计算&lt;/p&gt;

\[P(\text{Message} ~\vert~ \text{ham})\]

&lt;p&gt;的模型. 随后, 我们可以应用 &lt;strong&gt;贝叶斯规则&lt;/strong&gt; 对接收到的新消息进行分类:&lt;/p&gt;

\[\text{argmax}_{c \in \{\text{spam , ham}\}} P(c ~\vert~ \text{Message}) = \text{argmax}_{c \in \{\text{spam , ham}\}} P(\text{Message} ~\vert~ c) \cdot P(c).\]

&lt;p&gt;注意此处 $P(c)$ 代表 &lt;strong&gt;垃圾邮件或正常邮件在训练数据集中的频率&lt;/strong&gt;, 可以通过 &lt;strong&gt;统计垃圾邮件和正常邮件的数目&lt;/strong&gt; 得到.&lt;/p&gt;

&lt;p&gt;我们还可以使用机器学习方法: 将邮件信息视为一组 &lt;strong&gt;特征-值&lt;/strong&gt; 对, 使用分类算法 $a$ 和特征向量 $X$ 进行判断.&lt;/p&gt;

&lt;p&gt;我们可以将 $t$ 元组作为特征: 比如 $t=1$ 时, 我们考虑一元模型, 此时 &lt;strong&gt;在词汇表中的单词&lt;/strong&gt; 就是 &lt;strong&gt;特征&lt;/strong&gt;, 而特征的 &lt;strong&gt;值&lt;/strong&gt; 就是每个单词在这条邮件信息中出现的次数.&lt;/p&gt;

&lt;p&gt;我们称这样的 &lt;strong&gt;一元表示形式&lt;/strong&gt; 为 &lt;strong&gt;词袋模型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bag of words&lt;/code&gt;): 它就如同把训练语料的单词放进一个袋子中, 每次从袋子里抽取一个单词从而构成邮件信息, 而需要注意的是, 该过程 &lt;strong&gt;不保留词语之间的相互顺序&lt;/strong&gt;, 因此有 &lt;strong&gt;信息丢失&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在二元, 三元甚至更高元的模型中, 特征的数量成指数级别增长. 此外, 我们还可以加入邮件的一些 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;metadata&lt;/code&gt; 作为非 $n$ 元特征.&lt;/p&gt;

&lt;p&gt;在选定了特征集后, 我们就可以使用常见的监督学习技术训练文本分类模型.&lt;/p&gt;

&lt;h2 id=&quot;5-信息检索-information-retrieval&quot;&gt;5. 信息检索 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Information Retrieval&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;信息检索的本质是 &lt;strong&gt;检索和用户提供的信息需求相关的信息&lt;/strong&gt;, 任何与信息搜索相关的工具都是信息检索系统的一个实例.&lt;/p&gt;

&lt;p&gt;一个标准的 &lt;strong&gt;信息检索系统&lt;/strong&gt; ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Information Retrieval System&lt;/code&gt;) 都应具有下列四个特征:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;文档集合:&lt;/p&gt;

    &lt;p&gt;每个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt; 都应确定它需要处理的文档的类型和范围, 如 “一页文本”, “一个段落文本” 还是 “多页文本”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个使用某种 &lt;strong&gt;查询语言&lt;/strong&gt; 构造和描述的 &lt;strong&gt;查询请求&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;查询请求&lt;/strong&gt; 明确地描述了用户的需求. 组成它的查询语言可以由单词列表, 由多个单词组成的句子, 布尔运算符和非布尔运算符组成.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果集合:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt; 应该能够基于特定的查询请求给出对应的查询结果, 它是 &lt;strong&gt;文档集合的子集&lt;/strong&gt;, 包含了与查询请求相关的文档.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果集合的展示:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt; 同时应具备向用户展示其检索结果的能力.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;检索模型&quot;&gt;检索模型&lt;/h3&gt;

&lt;p&gt;早期的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt; 使用 &lt;strong&gt;布尔关键字模型&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;文档集合中的每个词都被视为一个布尔特征: 若这个词出现在某篇文档中, 则该文档的这个特征值为真, 反之为假, 而查询语言就是 &lt;strong&gt;基于这些特征的布尔表达式语言&lt;/strong&gt;: 只有当表达式的解释为真时, 文档才与查询相关.&lt;/p&gt;

&lt;p&gt;布尔关键字模型的优点在于原理简单, 容易解释和实现, 而其最明显的缺点在于无法基于文章的贴合度生成相关性排序, 并且给出适当的表达式需要极高的知识门槛.&lt;/p&gt;

&lt;p&gt;大部分 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt; 选择了 &lt;strong&gt;基于单词计数统计&lt;/strong&gt; 的模型: 我们将在本节中介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BM25评分函数&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;评分函数根据给定的某篇文档和查询语句, 基于内建规则执行计算并返回一个 &lt;strong&gt;数值&lt;/strong&gt; 作为对这篇文档在给定查询语句下的相关度评分.&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BM25&lt;/code&gt; 中, 得分是 &lt;strong&gt;由构成查询的每个单词的得分&lt;/strong&gt; 进行 &lt;strong&gt;线性加权&lt;/strong&gt; 组合而成. 查询项的权重受三个因素的影响:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查询项在文档中出现的频率 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TF&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TF&lt;/code&gt; 表示 &lt;strong&gt;词项频率&lt;/strong&gt;, 如对于查询 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[Long live Axton]&lt;/code&gt;, 频繁提到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Axton&lt;/code&gt; 的文档得分较高.&lt;/p&gt;

    &lt;p&gt;注意 &lt;strong&gt;词项频率&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Term Frequency&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TF&lt;/code&gt;) 的定义是: &lt;strong&gt;给定的某个单词&lt;/strong&gt; 在 &lt;strong&gt;给定的某篇文章&lt;/strong&gt; 中 &lt;strong&gt;出现的频率&lt;/strong&gt;:&lt;/p&gt;

\[\text{TF}(t, d) = \frac{\text{raw count of term `t' in document `d'}}{\text{document `d's word count}}.\]

    &lt;p&gt;&lt;strong&gt;但是在你校的课程中, 词项频率应该被定义为给定的某个单词在某篇文章中出现的次数!&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;词项的文档频率的倒数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDF&lt;/code&gt;:&lt;/p&gt;

    &lt;p&gt;如假设单词 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 几乎出现在每个文档中, 则这个词项的 &lt;strong&gt;文档频率较高&lt;/strong&gt;, 进而知其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDF&lt;/code&gt; 较低, 因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 没有查询中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;axton&lt;/code&gt; 重要.&lt;/p&gt;

    &lt;p&gt;注意 &lt;strong&gt;文档频率&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Document Frequency&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DF&lt;/code&gt;) 的定义是: 在 &lt;strong&gt;全体文章&lt;/strong&gt; 中 &lt;strong&gt;包含给定单词的文档&lt;/strong&gt; 的 &lt;strong&gt;篇数&lt;/strong&gt;. 它和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TF&lt;/code&gt; 是截然不同的两个东西:&lt;/p&gt;

\[\text{DF}(t, D) = \frac{\text{total number of documents `D' which contains term `t'}}{\text{total number of documents in corpus `D'}}.\]

    &lt;p&gt;&lt;strong&gt;但是在你校的课程中, 文档频率应该被定义为给定的某个单词在全体文章中出现的次数!&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;同时注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDF&lt;/code&gt; 并不单纯是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DF&lt;/code&gt; 的倒数:&lt;/p&gt;

\[\text{IDF} = \log_{10}\frac{N - DF + 0.5}{\text{DF + 0.5}}\]

    &lt;p&gt;注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDF&lt;/code&gt; 中的平滑 ($+0.5$) 和为了控制数值范围而进行的取对数操作.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文档的长度:&lt;/p&gt;

    &lt;p&gt;文档的长度越长, 其包含单词的数量越大, 越可能提到所有查询中的单词, 但同时也越可能 &lt;strong&gt;携带更多与查询项无关的内容&lt;/strong&gt;. 因此, 这类文档不一定真正与查询相关. 如果两篇文章都提到了查询中所有的查询项 (查询单词), 则更短的那篇应该作为更佳的相关文档候选.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们将要讨论的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BM25&lt;/code&gt; 函数将上述的三个因素全部考虑在内:&lt;/p&gt;

&lt;p&gt;不妨假设:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;语料库中的 $N$ 个文档都已经 &lt;strong&gt;索引完毕&lt;/strong&gt; , 因此对某个单词 $q_i$, 它在文档 $d_j$ 中的 &lt;strong&gt;词项频率&lt;/strong&gt; $\text{TF}(q_i, d_j)$ 可以被直接从索引中被查找到.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;已经构建好了一个 &lt;strong&gt;文档频率统计表&lt;/strong&gt;, 因此对某个单词 $q_i$, 我们可以通过查表得到它在 &lt;strong&gt;整个语料库&lt;/strong&gt; 中的 &lt;strong&gt;文档频率&lt;/strong&gt; $\text{DF}(q_i)$.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 给定文档 $d_j$ 和由 &lt;strong&gt;词语 $q_{1:N} := q_1q_2\cdots q_{N}$&lt;/strong&gt; 组成的查询, 就有:&lt;/p&gt;

\[\text{BM25} (d_j, q_{1:n}) = \sum_{i=1}^{n} \text{IDF}(q_i) \cdot \frac{\text{TF}(q_i, d_j) \cdot (k+1)}{\text{TF}(q_i, d_j) + k \cdot (1-b + b \cdot \frac{\vert d_j \vert}{L})}.\]

&lt;p&gt;我们下面对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BM25&lt;/code&gt; 计算公式中的变量进行解释:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$\vert d_j \vert$ 表示 &lt;strong&gt;文档 $d_j$&lt;/strong&gt; 以 &lt;strong&gt;单词计数&lt;/strong&gt; 的长度 (包含了多少个单词).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$L$ 为 &lt;strong&gt;语料库中文档&lt;/strong&gt; 的 &lt;strong&gt;平均长度&lt;/strong&gt;:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

\[L= \frac{\sum_{k=1}^{N} \vert d_k \vert}{N}.\]

&lt;ol&gt;
  &lt;li&gt;$k$ 和 $b$ 均为需要结合具体语料库通过交叉验证进行调整的参数. &lt;strong&gt;若未特殊指定, 认为 $k=2, b=0.75$!&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对语料库中的每个文档都计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BM25&lt;/code&gt; 评分往往是不现实的. 在给定某个查询时, 我们一般 &lt;strong&gt;对查询中的各个查询单词从索引中找出它们的命中列表并取交集&lt;/strong&gt;, 再对这个交集里的文档依次计算评分.&lt;/p&gt;

&lt;h3 id=&quot;对检索模型的评价&quot;&gt;对检索模型的评价&lt;/h3&gt;

&lt;p&gt;在评价某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt; 性能时我们有两个可供参考的度量指标: &lt;strong&gt;召回率&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Recall&lt;/code&gt;) 和 &lt;strong&gt;准确率&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Precision&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;假设对某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IRS&lt;/code&gt; 进行一次用来检验其性能的查询, 系统返回了一个结果集合. 对查询结果结合语料库进行统计, 可以分别得到四个值:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;在结果集合中&lt;/strong&gt; 的, 和查询 &lt;strong&gt;相关&lt;/strong&gt; 的文档数.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在结果集合中&lt;/strong&gt; 的, 和查询 &lt;strong&gt;不相关&lt;/strong&gt; 的文档数.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不在结果集合中&lt;/strong&gt; 的, 和查询 &lt;strong&gt;相关&lt;/strong&gt; 的文档数.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不在结果集合中&lt;/strong&gt; 的, 和查询 &lt;strong&gt;不相关&lt;/strong&gt; 的文档数.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;准确率&lt;/strong&gt; 所度量的是 &lt;strong&gt;结果集合&lt;/strong&gt; 中 &lt;strong&gt;实际相关&lt;/strong&gt; 的文档所占的比例.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;误判率&lt;/strong&gt; 所度量的是 &lt;strong&gt;结果集合&lt;/strong&gt; 中 &lt;strong&gt;不相关&lt;/strong&gt; 的文档所占的比例, 数值上和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1-准确率&lt;/code&gt; 相等.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;召回率&lt;/strong&gt; 所度量的是 &lt;strong&gt;结果集合&lt;/strong&gt; 中 &lt;strong&gt;相关文档在整个语料库中&lt;/strong&gt; 的 &lt;strong&gt;所有相关文档&lt;/strong&gt; 中所占的比例.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;漏报率&lt;/strong&gt; 所度量的是 &lt;strong&gt;结果集合&lt;/strong&gt; 中 &lt;strong&gt;实际相关&lt;/strong&gt; 的文档在 &lt;strong&gt;所有相关文档&lt;/strong&gt; 中所占的比例, 数值上和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1-漏报率&lt;/code&gt; 相等.&lt;/p&gt;

&lt;p&gt;$F_1$ 值  是 &lt;strong&gt;综合准确率和召回率&lt;/strong&gt; 这两个指标的度量: 它是 &lt;strong&gt;准确率和召回率两者&lt;/strong&gt; 的 &lt;strong&gt;几何平均值&lt;/strong&gt;:&lt;/p&gt;

\[\text{F}_{1} = \frac{2 \cdot \text{Precision} \cdot \text{RecallRate}}{\text{Precision} + \text{RecallRate}}\]

&lt;h3 id=&quot;pagerank-算法&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PageRank&lt;/code&gt; 算法&lt;/h3&gt;

&lt;p&gt;页面 $p$ 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PageRank&lt;/code&gt; 定义为:&lt;/p&gt;

\[\text{PR}(p) = \frac{1-d}{N} + d \cdot \sum_{i}\frac{\text{PR}(\text{in}_i)}{C(\text{in}_i)}.\]

&lt;p&gt;其中, $\text{PR}(p)$ 为 &lt;strong&gt;页面 $p$ 的网页排名&lt;/strong&gt;, $N$ 为 &lt;strong&gt;语料库中总的网页数量&lt;/strong&gt;, $\text{in}_i$ 为 &lt;strong&gt;链接到 $p$ 的页面&lt;/strong&gt;, 而 $C(\text{in}_i)$ 为 &lt;strong&gt;从页面 $\text{in}_i$ 链接出去的网页链接数&lt;/strong&gt;, $d$ 为一个称为 &lt;strong&gt;阻尼因子的常量&lt;/strong&gt;, 可以理解为用户点击页面上任意一个链接的概率.&lt;/p&gt;

&lt;p&gt;显然, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PageRank&lt;/code&gt; 是 &lt;strong&gt;递归定义&lt;/strong&gt; 的. 我们可以通过迭代计算出网页排名: 开始时, 所有页面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PageRank&lt;/code&gt; 值均设为 $1$, 然后迭代运行算法, 更新排名, 直到收敛.&lt;/p&gt;

&lt;h2 id=&quot;6-信息提取-information-extraction&quot;&gt;6. 信息提取 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Information Extraction&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;定义 6.1&lt;/strong&gt; (信息提取)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称 &lt;strong&gt;信息提取&lt;/strong&gt; 为通过 &lt;strong&gt;浏览文本&lt;/strong&gt; 获取 &lt;strong&gt;特定类别的对象&lt;/strong&gt; 和 &lt;strong&gt;对象间的关系&lt;/strong&gt; 的过程.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;信息提取的典型实例包括: 网络爬虫从网页中抽取实例信息, 从天气预报中抽取所报道的天气信息等数据库字段的内容.&lt;/p&gt;

&lt;p&gt;在一些特定的领域内, 信息提取可以达到很高的准确率, 而在一般的领域内, 就需要 &lt;strong&gt;复杂的语言模型&lt;/strong&gt; 和 &lt;strong&gt;复杂的学习技术&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;基于有限状态自动机的信息提取&quot;&gt;基于有限状态自动机的信息提取&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;基于属性的抽取系统&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Attribute-based Extraction&lt;/code&gt;) 是最简单的信息提取系统, 它假设 &lt;strong&gt;整个文本都是关于单一对象&lt;/strong&gt; 的, 而系统的任务是 &lt;strong&gt;从文本中抽取该对象的属性&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;对于这类问题, 我们可以针对 &lt;strong&gt;每个需要抽取的属性&lt;/strong&gt; 基于 &lt;strong&gt;有限状态自动机&lt;/strong&gt; 定义模版. 模版的一个最典型的例子就是 &lt;strong&gt;正则表达式&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;一般而言, 模版由 &lt;strong&gt;前缀正则表达式&lt;/strong&gt;, &lt;strong&gt;目标正则表达式&lt;/strong&gt; 和 &lt;strong&gt;后缀正则表达式&lt;/strong&gt; 组成. 这样的设计思想是: &lt;strong&gt;某些属性的特征信息来源于属性值本身, 或者来源于属性值的上下文&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;一旦某条属性的正则表达式和文本完全匹配, 就可以从文本中 &lt;strong&gt;抽取出表示属性值那部分的文本&lt;/strong&gt;. 若没有匹配, 就需要 &lt;strong&gt;给出默认值&lt;/strong&gt; 或让该属性 &lt;strong&gt;留空&lt;/strong&gt;, 若有多个匹配则需要从中挑选.&lt;/p&gt;

&lt;p&gt;课上介绍的正则表达式语法规则如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220122184830.png&quot; alt=&quot;20220122184830&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;信息提取的概率模型&quot;&gt;信息提取的概率模型&lt;/h3&gt;

&lt;p&gt;概率模型适用于从 &lt;strong&gt;有噪音的, 变化的文本&lt;/strong&gt; 中抽取信息, 在这里我们使用 &lt;strong&gt;隐 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 模型&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;隐 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 模型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt;) 描述了一个 &lt;strong&gt;隐含状态序列&lt;/strong&gt;, 该序列的每一步都附有一个 &lt;strong&gt;观察值 $e_t$&lt;/strong&gt;. 在这里, 为了将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 应用于信息提取问题上, 我们 &lt;strong&gt;为每个属性分别建立一个独立的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在这里, 观察值序列就是 &lt;strong&gt;文本的单词序列&lt;/strong&gt;, 隐含状态分别表示 &lt;strong&gt;处于属性模版&lt;/strong&gt; 的 &lt;strong&gt;目标, 前缀或后缀部分&lt;/strong&gt; 或 &lt;strong&gt;(不在属性模版中的)背景部分&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;例如, 下图给出了一个简短的文本和一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt;. 这个模型的功能是识别这条通知信息中提到的报告人:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220105100932.png&quot; alt=&quot;20220105100932&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PRE&lt;/code&gt; 表示模版的前缀 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prefix&lt;/code&gt;) 部分, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 表示模版的目标 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target&lt;/code&gt;) 部分, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt; 表示模版的后缀 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Postfix&lt;/code&gt;) 部分, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; 表示不属于模版中的背景状态.&lt;/p&gt;

&lt;p&gt;在信息提取问题中, 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 相比使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FSA&lt;/code&gt; 有两大主要优势:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 是 &lt;strong&gt;概率模型&lt;/strong&gt;, 因此具有抗噪声的特点, 而在正则表达式中, 只要被检测的句子中哪怕有一个预期的字符丢失了, 正则表达式的匹配也会失败. 而若使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt;, 我们就可以很好地对句子中丢失的字符或单词进行 &lt;strong&gt;退化处理&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Degradation&lt;/code&gt;): 用概率值表示匹配的程度, 而非一刀切地用布尔值表示 “匹配成功” 或 “匹配失败”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 可以通过数据训练得到, 而无需构造复杂的匹配模版. 因此, 这样构造的模型还具有可扩展性的特点, 可以适应 &lt;strong&gt;随着时间推移不断变化&lt;/strong&gt; 的文本.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 中, 我们已经假定了这样的结构: 我们的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 模版由一系列目标状态组成, 且 &lt;strong&gt;任何前缀状态&lt;/strong&gt; 必须 &lt;strong&gt;在目标状态之前&lt;/strong&gt;, 而 &lt;strong&gt;后缀状态&lt;/strong&gt; 必须 &lt;strong&gt;在目标状态之后&lt;/strong&gt;, 其他状态都表示 &lt;strong&gt;背景&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 进行信息提取存在一个问题: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 实际上是一个 &lt;strong&gt;生成模型&lt;/strong&gt;, 除了进行信息提取之外, 它还可以依照同样的规则进行信息生成. 虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HMM&lt;/code&gt; 功能强大, 但它对很多和问题不相关的概率进行了建模, 而这些是我们不关心的. 自然地, 我们会考虑, 是否 &lt;strong&gt;不对这些不相关的概率进行建模得到的抽取模型性能会更好&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;我们为理解文本所需的是 &lt;strong&gt;判别模型&lt;/strong&gt;, 它可以为给定的观察值 (在这里就是文本) 建立 &lt;strong&gt;隐含属性的条件概率模型&lt;/strong&gt;: 给定文本 $e_{1 : N}$, 条件模型将寻找使概率&lt;/p&gt;

\[P(X_{1:N} ~\vert~ e_{1:N})\]

&lt;p&gt;最大化的隐含状态序列 $X_{1:N}$.&lt;/p&gt;

&lt;p&gt;在前文提到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;会议报告&lt;/code&gt; 的例子中, 文本 $e_{1 : N}$ 就是第一行中给定的, 要被抽取信息的原文, 而得到的序列 $X_{1:N}$ 就是第二行中的模版匹配序列, 这个序列告诉我们在原文中的哪个单词最有可能是模版中的 &lt;strong&gt;目标&lt;/strong&gt;, &lt;strong&gt;前缀&lt;/strong&gt; 或 &lt;strong&gt;后缀&lt;/strong&gt;, 进而我们就可以以此为基准进行信息提取.&lt;/p&gt;

&lt;p&gt;这类模型的一个重要架构是 &lt;strong&gt;条件随机场&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conditional Random Field&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRF&lt;/code&gt;). 对于给定的观察变量集合, 条件随机场对 &lt;strong&gt;一组目标变量&lt;/strong&gt; 的 &lt;strong&gt;条件概率分布&lt;/strong&gt; 建模.&lt;/p&gt;

&lt;p&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bayes 网络&lt;/code&gt; 类似, 条件随机场也可以表示变量之间的依赖结构. 比如, &lt;strong&gt;线性链条件随机场&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linear-chain Conditional Random Field&lt;/code&gt;) 就可以表示 &lt;strong&gt;时间序列中变量之间的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markov&lt;/code&gt; 依赖关系&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;条件随机场模型的任务是: 给定观察序列 $x$, 返回标记序列 $y$, 且 $y$ 满足:&lt;/p&gt;

\[y = \text{argmax}_{y} ~ p_{\lambda}(y ~\vert~ x).\]

&lt;p&gt;而&lt;/p&gt;

\[p_{\lambda}(y ~\vert~ x) = \frac{1}{Z_x} \cdot \exp(\sum_{i=1}^{n} \sum_{j=1}^{m} \lambda_j \cdot f_j(y_{i-1}, y_i, x, i))\]

&lt;p&gt;其中:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$\frac{1}{Z_x}$ 是确保对所有的 $y$ 而言概率和为 $1$ 的 &lt;strong&gt;标准化因子&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
\[\sum_{j=1}^{m} \lambda_j \cdot f_j(y_{i-1}, y_i, x, i)\]

    &lt;p&gt;为 &lt;strong&gt;特征函数&lt;/strong&gt;, 显见它被定义为 $m$ 个特征函数 $f_1, \cdots, f_m$ 的加权和. 其中, 参数 $\lambda_j$ 通过最大后验估计过程学习得到.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;指数幂上的 $\sum_{i=1}^{n}$ 作用为对标记序列 $y$ 中的每个标记 $y_i$ 求和 (也就是说特征函数要应用在每个标记上).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此外, 特征函数是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRF&lt;/code&gt; 的重要组成部分: 它通过 &lt;strong&gt;相邻的状态&lt;/strong&gt;, &lt;strong&gt;全部的观察值序列 $x$&lt;/strong&gt; 和时序中的当前位置 $i$ 进行计算. 举例而言, 我们可以定义这样的一个特征函数:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220105120140.png&quot; alt=&quot;20220105120140&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2021/12/30/COMP24011-Ch7/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/30/COMP24011-Ch7/</guid>
        
        <category>2021</category>
        
        <category>课程笔记</category>
        
        <category>COMP24011</category>
        
        
      </item>
    
      <item>
        <title>人工智能导论 模糊逻辑</title>
        <description>&lt;h1 id=&quot;模糊逻辑&quot;&gt;模糊逻辑&lt;/h1&gt;

&lt;p&gt;我们使用 &lt;strong&gt;模糊逻辑&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fuzzy Logic&lt;/code&gt;) 描述具有模糊性的语言形式和思维. 在应用中, 我们通过 &lt;strong&gt;模糊控制系统&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fuzzy Control System&lt;/code&gt;) 使 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 得以基于 &lt;strong&gt;模糊规则&lt;/strong&gt; 利用具有模糊性的现实事实并以此为基准作出可靠的决策.&lt;/p&gt;

&lt;p&gt;标准的 &lt;strong&gt;模糊控制系统&lt;/strong&gt; 架构如下图所示. 在接下来的数节中我们将详细介绍它:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220103172213.png&quot; alt=&quot;20220103172213&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-隶属度-degree-of-membership&quot;&gt;1. 隶属度 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Degree of Membership&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;和此前介绍的传统逻辑 (或清晰逻辑) 不同, 在模糊逻辑中事物不是 &lt;strong&gt;非黑即白&lt;/strong&gt; 的, 不能直接用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; 表达, 而需要取一个 &lt;strong&gt;介于 $0$ 和 $1$ 之间的值&lt;/strong&gt; 描述这个事件 (或事物) 接近/远离 某个状态 (如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;) 的程度.&lt;/p&gt;

&lt;p&gt;考虑一个例子: 我们称 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Axton&lt;/code&gt; 很强&lt;/strong&gt;, 但究竟什么样才算是 &lt;strong&gt;很强&lt;/strong&gt;, 什么样算是 &lt;strong&gt;比较强&lt;/strong&gt;, 什么样算是 &lt;strong&gt;不太强&lt;/strong&gt;? 在布尔逻辑中, 我们可以直接处理 &lt;strong&gt;是非分明&lt;/strong&gt; 的场景, 比如判断一个人, Ta要么强, 要么根本不强. 但在模糊逻辑中, &lt;strong&gt;很强&lt;/strong&gt;, &lt;strong&gt;比较强&lt;/strong&gt;, &lt;strong&gt;不太强&lt;/strong&gt; 之间并没有严格界限, 换言之某个人能力的强弱不完全归属于一个类, 而是被一个称为 &lt;strong&gt;隶属度&lt;/strong&gt; 的数值衡量的.&lt;/p&gt;
&lt;h2 id=&quot;2-模糊化-fuzzification&quot;&gt;2. 模糊化 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fuzzification&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;模糊化&lt;/strong&gt; 就是将逻辑的输入数值转换为各个分类集合的隶属度的过程, 输入数值和隶属度的关系被 &lt;strong&gt;隶属度函数&lt;/strong&gt; 定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220103154812.png&quot; alt=&quot;20220103154812&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如在上图的隶属度函数中可以看到, 温度被人为地划分为 &lt;strong&gt;寒冷&lt;/strong&gt;, &lt;strong&gt;温暖&lt;/strong&gt; 和 &lt;strong&gt;炎热&lt;/strong&gt; 分类, 而这三个分类的隶属度函数分别在平面上以 &lt;strong&gt;蓝色&lt;/strong&gt;, &lt;strong&gt;橙色&lt;/strong&gt; 与 &lt;strong&gt;红色&lt;/strong&gt; 表示.&lt;/p&gt;

&lt;p&gt;在该问题中, &lt;strong&gt;温度由三个模糊集合组成&lt;/strong&gt;, 且 &lt;strong&gt;给定温度数值, 该数值对应于不同模糊集合的隶属度由这三个集合的隶属度函数确定&lt;/strong&gt;, 比如 $21$ 度 (对应图中竖线) 被视为 &lt;strong&gt;寒冷&lt;/strong&gt; 的隶属度为 $0.8$, 视为 &lt;strong&gt;温暖&lt;/strong&gt; 的隶属度为 $0.2$, &lt;strong&gt;炎热&lt;/strong&gt; 的隶属度为 $0$.&lt;/p&gt;

&lt;p&gt;值得注意的是, 一个值可以同时属于不同的模糊集合.&lt;/p&gt;

&lt;h2 id=&quot;3-逻辑运算&quot;&gt;3. 逻辑运算&lt;/h2&gt;

&lt;p&gt;模糊逻辑中的逻辑运算就是 &lt;strong&gt;模糊逻辑中, 分解出的各个隶属度的运算&lt;/strong&gt;. 它们被定义为:&lt;/p&gt;

&lt;p&gt;给定谓词 $A$, $B$, 则有:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;最小隶属法 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Conjunction&lt;/code&gt;):&lt;/p&gt;

\[T(A \wedge B) = \text{min}(T(A), T(B))\]
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最大隶属法 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Disjunction&lt;/code&gt;):&lt;/p&gt;

\[T(A \vee B) = \text{max}(T(A), T(B))\]
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;取反 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Negation&lt;/code&gt;):&lt;/p&gt;

\[T(\neg A) = 1-T(A)\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-决策规则&quot;&gt;4. 决策规则&lt;/h2&gt;

&lt;p&gt;在模糊化输入后, 我们需要构造规则, 应用模糊逻辑的运算将得到的隶属度组合计算, 以作为决策的依据.&lt;/p&gt;

&lt;p&gt;一般地, 模糊逻辑的决策规则都为包含一系列逻辑语句的集合, 这些逻辑语句具备这样的结构:&lt;/p&gt;

\[\text{IF} ~&amp;lt;\text{antecedents}&amp;gt;~ \text{THEN} ~&amp;lt;\text{consequent}&amp;gt;~\]

&lt;p&gt;考虑讲义中提及的 &lt;a href=&quot;https://ww2.mathworks.cn/help/fuzzy/building-systems-with-fuzzy-logic-toolbox-software.html#brzqs45&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;The Basic Tipping Problem&lt;/code&gt;&lt;/a&gt;, 我们有下列规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;给定前件规则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务水平低或食材质量差&lt;/code&gt;, 限定结果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;只给很少的小费;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;给定前件规则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务水平比较好&lt;/code&gt;, 限定结果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;只给一般水平的小费;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;给定前件规则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务水平很高或食材质量很好&lt;/code&gt;, 限定结果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;慷慨解囊&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;则我们可以将该模糊逻辑问题中如上描述的三条规则表示为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220103171204.png&quot; alt=&quot;20220103171204&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是, 如上面三条例子所描述的一样:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;决策规则中的前件条件可以是某个由多个子条件组成的复合谓词公式, 如第一条规则中的前件条件实际上由两个子条件: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;服务水低&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;食材质量差&lt;/code&gt; 组成.&lt;/li&gt;
  &lt;li&gt;决策规则中的前件条件可以是恰好由一个条件组成的复合谓词公式, 如第二条规则.&lt;/li&gt;
  &lt;li&gt;决策规则中前件条件的形式可以是某个谓词公式的取反, 如第三条规则.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对某个问题而言, 在给定所有的决策规则后, 我们需要使用上一节介绍的三种基础逻辑运算将这些规则转换为逻辑公式, 从而实现将给定的模糊条件转化为对应的 &lt;strong&gt;规则强度&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rule Strength&lt;/code&gt;) 的功能.&lt;/p&gt;

&lt;h2 id=&quot;5-推断和去模糊化&quot;&gt;5. 推断和去模糊化&lt;/h2&gt;

&lt;p&gt;在执行 &lt;strong&gt;推断&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inference&lt;/code&gt;) 时, 我们的基本任务是基于 &lt;strong&gt;给定的模糊输入&lt;/strong&gt; 确定 &lt;strong&gt;每一条规则给出的结果&lt;/strong&gt;, 并 &lt;strong&gt;将这些不同的规则给出的结果综合起来&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在执行 &lt;strong&gt;去模糊化&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Defuzzification&lt;/code&gt;) 时, 我们的基本任务是给出一个数值作为最终的输出.&lt;/p&gt;

&lt;p&gt;在模糊逻辑中, 执行 &lt;strong&gt;推断&lt;/strong&gt; 的常用方法包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mamdami 模糊逻辑推理&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sugeno 模糊逻辑推理&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;前者的输出仍是一个模糊集, 而后者的输出为由某个 &lt;strong&gt;单例隶属函数&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Singleton Membership Function&lt;/code&gt;) 定义的常数或线性函数.&lt;/p&gt;

&lt;p&gt;单例隶属函数的特征为: 它只在其定义域上的某个点处具有非零函数值, 而在其他任何位置上的函数值均为 $0$. 我们下面详细描述两种推断方法的具体工作流程:&lt;/p&gt;

&lt;h3 id=&quot;mamdami-模糊逻辑推理&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mamdami 模糊逻辑推理&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220103181744.png&quot; alt=&quot;20220103181744&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简要地说, 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mamdami 模糊逻辑推理&lt;/code&gt; 计算模糊推断系统 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fuzzy Inference System, FIS&lt;/code&gt;) 的输出需要下列的六个步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;确定给定问题的所有模糊规则 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fuzzy Rules&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;使用隶属函数将输入值模糊化.&lt;/li&gt;
  &lt;li&gt;基于模糊规则将 &lt;strong&gt;已经被模糊化的输入&lt;/strong&gt; 结合, 进而计算出该规则在给定模糊输入下对应的 &lt;strong&gt;规则强度&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rule Strength&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;结合上一步中计算出的 &lt;strong&gt;规则强度&lt;/strong&gt; 和 &lt;strong&gt;给定规则的输出隶属函数&lt;/strong&gt;, 得出基于当前的模糊输入下该规则的 &lt;strong&gt;结果&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Consequence&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;将来自所有规则的结果相结合, 从而得出输出分布 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Output Distribution&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在第四步中, &lt;strong&gt;结果&lt;/strong&gt; 是通过将 &lt;strong&gt;给定规则的输出隶属函数&lt;/strong&gt; 在 &lt;strong&gt;规则强度&lt;/strong&gt; 的高度上 &lt;strong&gt;推平&lt;/strong&gt; 得到的:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220103180247.png&quot; alt=&quot;20220103180247&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在第五步中, 绝大多数情况下 &lt;strong&gt;输出分布在定义域上任何点的值&lt;/strong&gt; 都是 &lt;strong&gt;全体规则的输出隶属函数的析取&lt;/strong&gt; (也就是取并):&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220103180408.png&quot; alt=&quot;20220103180408&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在得到输出分布后, 我们需要 &lt;strong&gt;去模糊化&lt;/strong&gt;, 这一般是通过取 &lt;strong&gt;输出分布的函数和 $x$ 轴围成的图形的质心&lt;/strong&gt; 得到的. 计算公式如下:&lt;/p&gt;

\[z = \frac{\sum_{i=1}^{q} Z_i \cdot u_c(Z_i)}{\sum_{i=1}^{q} u_c(Z_i)}\]

&lt;p&gt;其中 $q$ 为人为指定的划分份数, $Z_i$ 为 $x$ 轴上的对应划分处的值, $u_c(Z_j)$ 为输出分布在 $x$ 轴上某个位置上对应的函数值.&lt;/p&gt;

&lt;h3 id=&quot;sugeno-模糊逻辑推理&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sugeno 模糊逻辑推理&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220103181800.png&quot; alt=&quot;20220103181800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sugeno 模糊逻辑推理&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mamdami 模糊逻辑推理&lt;/code&gt; 的流程基本类似, 主要区别在前者 &lt;strong&gt;不以隶属函数作为输出&lt;/strong&gt;, 其输出是通过以 &lt;strong&gt;每条规则的输出隶属函数取极值时对应的 $x$ 坐标&lt;/strong&gt; 为系数, 和 &lt;strong&gt;每条规则在给定的模糊输入下算出的, 对应的规则强度&lt;/strong&gt; 取 &lt;strong&gt;加权平均&lt;/strong&gt; 得到的.&lt;/p&gt;

&lt;p&gt;如本题中, 计算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sugeno 模糊逻辑推理&lt;/code&gt; 的算法就是:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220121213438.png&quot; alt=&quot;20220121213438&quot; /&gt;&lt;/p&gt;

\[\text{ans} = \frac{k_1 \cdot \lambda_1 + k_2 \cdot \lambda_2 + k_3 \cdot \lambda_3}{\lambda_1 + \lambda_2 + \lambda_3} = \frac{0.1 \cdot 20 + 0.2 \cdot 50 + 0.5 \cdot 80}{0.1 + 0.2 + 0.5} = 65.\]

&lt;p&gt;Reference:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.cs.princeton.edu/courses/archive/fall07/cos436/HIDDEN/Knapp/fuzzy004.htm&quot;&gt;4. Fuzzy inference systems&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://ww2.mathworks.cn/help/fuzzy/types-of-fuzzy-inference-systems.html&quot;&gt;Mamdani and Sugeno Fuzzy Inference Systems&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://learn-eu-central-1-prod-fleet01-xythos.content.blackboardcdn.com/5f0eeec577cec/12883725?X-Blackboard-Expiration=1641232800000&amp;amp;X-Blackboard-Signature=mHdaeaz60HCdc3E6iCzNLhwj%2Bp081LkxU5lz47Kxw6M%3D&amp;amp;X-Blackboard-Client-Id=301771&amp;amp;response-cache-control=private%2C%20max-age%3D21600&amp;amp;response-content-disposition=inline%3B%20filename%2A%3DUTF-8%27%27FuzzyLogic.pdf&amp;amp;response-content-type=application%2Fpdf&amp;amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjEFMaDGV1LWNlbnRyYWwtMSJHMEUCIAZdlkcvnkCP9QJEw4SKw0HoLf1jzV3H%2FseZxSs%2FGcdNAiEAkf5Nio8F%2FDUEytVFDFYadtKL901DXky1jq5muKv8EhYqgAQIXBACGgw2MzU1Njc5MjQxODMiDHqOLapsGfV5Btx6nCrdA7hQKcgRFK7mHrRkmZ%2BJqD83dHbIoN8ixXRO2jclWLCcX%2Fol2v22MSIdytHLTDafDzPdwdglCf%2FWsZPeum8T3%2FexmmqkUUWUzs%2FpRXqfaQZV55qlqJA0t%2BhmQKzOouMPBDeC34s4Y6%2BYFBQ%2FHeSp5UuwIGXxs2tubJ73rAXWBuIGTY207Em64d%2FtTtgyiDzkPpwBCQ%2F0hGLtR57%2FwvOZFVdKq1D57LDXvliy2DfmOsCTDtvZXSxP6fcUrK3SIuAF4jewLRfrBusyPBI0Z9fCvBNHKRnvmUOawPWFl%2F8Y4Dfkzsj9eNlHx1TeoRZjPfd4qbr31%2BBG37dRfOR3rhKoExKQpVM%2FWSwP9P6QD70Qirw26irO3zj48MzH8hkcWQScXuYcYASu1O%2BRU8N3AkNxqPKONAKigH2XCvxTtf6%2BAq2G3qBROMaTo4JXKFGAXX28z3EfA969%2Bq82vLFh%2BGZCeTq%2By6dNXSvZSr8xlS9eKE%2BR27uHg6HXGvdvFR0FB6yPPbq42tMLgx9%2FzQVqa8dVbm1kmTDRbJ1arkDNo4pn5dMoXq0W1%2ByPVvFRbOTB78S1AHJYbhCh74XYkwaH41P6haeptOyqE0xAjgNlEtGUHnAy9B5wxQowt0cx14WDvjCussuOBjqlAaCkMwxgeYEvMIz%2FcI62MXKoVhiPK%2B946C%2BuKCZdmtzLEHmzcV61TVVeauvMNcuODA8Ao1DYZtqdJ4fAPvurop4IaxdGLdj8%2FuHQxzM9UZBaPmHR8Nh6PSGxeUQ9ziDNv8rf8aeEniiAU7clFS3gG71kbwKyqr1ulVkvImKOO%2FDiy67ka6f8kKt8NCRgAnONCHqCO4yo1lzYPqRtRIHGWwpaMY67bw%3D%3D&amp;amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Date=20220103T120000Z&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Expires=21600&amp;amp;X-Amz-Credential=ASIAZH6WM4PL3YVKKN7V%2F20220103%2Feu-central-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Signature=77f685b4136b02b6b4f1bfe510dfae5590200abee7c27439e7e5e7d0b6531efb&quot;&gt;Fuzzy Logic&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://ebookcentral.proquest.com/lib/manchester/reader.action?docID=333988&amp;amp;ppg=268&quot;&gt;Knowledge Representation and Reasoning, Ch 12.4&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://ww2.mathworks.cn/help/fuzzy/fuzzy-inference-process.html&quot;&gt;Fuzzy Inference Process&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2021/12/28/COMP24011-Ch6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/28/COMP24011-Ch6/</guid>
        
        <category>2021</category>
        
        <category>课程笔记</category>
        
        <category>COMP24011</category>
        
        
      </item>
    
      <item>
        <title>人工智能导论 知识表示</title>
        <description>&lt;h1 id=&quot;知识表示&quot;&gt;知识表示&lt;/h1&gt;

&lt;p&gt;本章中我们将说明如何使用一阶逻辑表示现实世界中的知识. 在介绍 &lt;strong&gt;通用本体论&lt;/strong&gt; 后, 我们将介绍如何表示 &lt;strong&gt;对象&lt;/strong&gt;, &lt;strong&gt;物质&lt;/strong&gt;, &lt;strong&gt;量度&lt;/strong&gt;, &lt;strong&gt;事件&lt;/strong&gt; 和 &lt;strong&gt;信念&lt;/strong&gt;, 然后讨论对应用在 &lt;strong&gt;高效类别推理&lt;/strong&gt; 中的推理系统的设计.&lt;/p&gt;

&lt;h2 id=&quot;51-本体论&quot;&gt;5.1 本体论&lt;/h2&gt;

&lt;p&gt;我们使用 &lt;strong&gt;本体论&lt;/strong&gt; 表示现实世界中的客观事物, 知识和通用概念. 在各种不同的情况下, 我们可能需要在 &lt;strong&gt;上位本体论&lt;/strong&gt; 的框架下进行扩展, 使用一些特化的本体论表示具体的情形:&lt;/p&gt;

&lt;p&gt;比如在对电路建模时, 我们可能需要忽略时间的概念, 假定信号是固定且不传播的; 或者, 我们在对模拟电路建模时可能需要考虑特定时刻的信号, 还要将电路中的导线长度和信号传播的延迟考虑在内.&lt;/p&gt;

&lt;p&gt;对任何上述用于描述特殊情况的 &lt;strong&gt;特化的本体论&lt;/strong&gt; 而言,它们是 &lt;strong&gt;有可能&lt;/strong&gt; 收敛到一种通用的本体论的. 我们可以指出两个能够将 &lt;strong&gt;通用本体论&lt;/strong&gt; 与 &lt;strong&gt;特化本体论&lt;/strong&gt; 区分开来的特征:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通用本体论应该或多或少地具备应用于任何特殊领域的能力.&lt;/li&gt;
  &lt;li&gt;在任何足够特殊化的问题中, 通用本体论必须能够将来自不同领域的知识统一化.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;类别和对象&quot;&gt;类别和对象&lt;/h3&gt;

&lt;p&gt;由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 在与世界的交互发生在 &lt;strong&gt;个体对象&lt;/strong&gt; 层面, 而推理发生在 &lt;strong&gt;类别&lt;/strong&gt; 层面上, 因此在知识表示中, 将对象组织成类别是很重要的.&lt;/p&gt;

&lt;p&gt;在确定了对象的分类后, 类别信息就可以用于对对象进行预测: 我们可以从 &lt;strong&gt;感知&lt;/strong&gt; 推断出 &lt;strong&gt;某种对象的存在&lt;/strong&gt;, 从 &lt;strong&gt;感知到的对象属性&lt;/strong&gt; 进一步推断它的 &lt;strong&gt;类别归属&lt;/strong&gt;, 然后用推断得到的类别信息对这些对象进行预测.&lt;/p&gt;

&lt;p&gt;举例而言, 给定某台笔记本电脑, 从厚重的机身, 丑陋的缺口显示屏, 被涂黑的键盘区域和机身上意义不明的专用磁吸充电口, 我们就可以推断出这个对象是 $2021$ 年推出的最新款 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MacBook Pro&lt;/code&gt;, 由此推断出这样的产品比较适合拿来垫桌脚.&lt;/p&gt;

&lt;p&gt;在使用一阶逻辑表示类别时, 我们可以使用谓词表示某个对象的类别, 也可以将某个类别物化 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reify&lt;/code&gt;) 为一个对象.&lt;/p&gt;

&lt;p&gt;我们通过在不同的类别之间构造 &lt;strong&gt;继承&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inheritance&lt;/code&gt;) 关系来组织和简化知识库. 子类关系将类别组织成 &lt;strong&gt;分类系统&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Taxonomy&lt;/code&gt;) 或 &lt;strong&gt;分类层次&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Taxonomic Hierarchy&lt;/code&gt;), 比如生物学上的物种分类系统和图书馆的书籍分类系统.&lt;/p&gt;

&lt;p&gt;一阶逻辑通过 &lt;strong&gt;在对象和类别之间建立联系&lt;/strong&gt; 或 &lt;strong&gt;在类别的成员上量化&lt;/strong&gt;, 从而描述 &lt;strong&gt;关于类别的事实&lt;/strong&gt;. 举例而言, 它可以表示:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;某个对象是某个类别的成员.&lt;/li&gt;
  &lt;li&gt;某个类别是另一个类别的子类.&lt;/li&gt;
  &lt;li&gt;某个类别中的所有成员均拥有某种属性.&lt;/li&gt;
  &lt;li&gt;一个类别的成员可以通过某些属性识别.&lt;/li&gt;
  &lt;li&gt;一个类别作为整体拥有某些属性.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们接下来给出关于划分的一些概念:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义 5.1.1&lt;/strong&gt; (不相交的)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;称两个或以上的类别为 &lt;strong&gt;不相交的&lt;/strong&gt;, 若他们没有公共成员.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 5.1.2&lt;/strong&gt; (完全分解)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;若两个或以上的类别完全包括了父类中的所有成员, 称它们为一个 &lt;strong&gt;完全分解&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 5.1.3&lt;/strong&gt; (划分)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们称不相交的完全分解为 &lt;strong&gt;划分&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对划分的表示语法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;# 可以使用谓词描述某个物体属于某个类别 (Cetegory):
Basketball(b)

# 可以通过将抽象的类别物化的方法标示某个物体的类别从属:

# 比如我们将 “篮球” 类物化为谓词 `Basketball`:
Member(b, Basketballs)
# 或者
b ∈ Basketballs

# 同时物化方法也可用来表示子类:
Subset(Basketballs, Balls)
# 或者
Basketballs ⊂ Balls

# 我们也可以通过描述物体的属性表示它在类别意义上的从属:
(b ∈ Basketballs) ⟹ Spherical(b)

Orange(b) ∧ Round(b) ∧ Diameter(b) = 9.5inches ∧ b∈ Balls ⟹ b ∈ Basketballs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;物理构成&quot;&gt;物理构成&lt;/h3&gt;

&lt;p&gt;自然地, 某个对象可以是另一个对象的一部分, 这一关系用谓词 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PartOf&lt;/code&gt; 表示. 需要注意, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PartOf&lt;/code&gt; 关系是 &lt;strong&gt;传递的&lt;/strong&gt; 和 &lt;strong&gt;自反的&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复合对象&lt;/strong&gt; 的类别通常通过各部分之间的结构关系刻画. 我们可以定义类似于类别 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Partition&lt;/code&gt; 关系的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PartPartition&lt;/code&gt; 关系: 一个对象由它的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PartPartition&lt;/code&gt; 中的各个部分组成, 则可看作这个对象从这些组成部分中得到了某些属性.&lt;/p&gt;

&lt;p&gt;我们还可以定义 &lt;strong&gt;具有确定部分但没有特定结构&lt;/strong&gt; 的复合对象. 举例而言, “这箱 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MacBook Pro 2021&lt;/code&gt; 价值 $4000$ 美元”, 我们会倾向于认为这个价值归于箱子里包装盒而非盒子里的笔记本电脑的价值, 而非箱子本身的价值, 因为 &lt;strong&gt;集合&lt;/strong&gt; 是抽象的数学概念, 它由元素组成但不具备 “价值” 这个属性.&lt;/p&gt;

&lt;p&gt;对应的, 我们需要构造一个新概念: 束 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bunch&lt;/code&gt;): 它描述了由一系列对象作为 &lt;strong&gt;部分&lt;/strong&gt; 而组成的复合对象.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;# 表示 “一部分”:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PartOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bucharest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Romania&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;PartOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Romania&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EasternEurope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;PartOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EasternEurope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Europe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;PartOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Europe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Earth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;量度&quot;&gt;量度&lt;/h3&gt;

&lt;p&gt;显然在关于世界的科学理论和常识中, 对象具备 &lt;strong&gt;高度&lt;/strong&gt;, &lt;strong&gt;质量&lt;/strong&gt;, &lt;strong&gt;价值&lt;/strong&gt;, &lt;strong&gt;成本&lt;/strong&gt; 等不同的属性, 我们赋予这些属性的值就被称为 &lt;strong&gt;量度&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Measures&lt;/code&gt;). 我们用 &lt;strong&gt;单位函数&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Units Function&lt;/code&gt;) 和数字作为参数来表示量度.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;# 描述物体的量度属性:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Inches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Centimeters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.81&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Diameter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Inches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;9.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;IQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Axton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;114514&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 描述对量度值之间的比较:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Difficulty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comp24011&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Difficulty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comp22111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;物体和物质&quot;&gt;物体和物质&lt;/h3&gt;

&lt;p&gt;现实世界可以看作是由不可再分的基元对象 (如微粒子) 和由它们构成的复合对象组成的. 但在现实中存在一部分无法被简单地划分, 无法给出明确数量的对象, 例如水和气体, 我们称这类不服从明显的个体化 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Individuation&lt;/code&gt;) 的对象为 &lt;strong&gt;物质&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stuff&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;需要注意的是, 对象的一些属性是 &lt;strong&gt;固有的&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intrinsic&lt;/code&gt;), 它们属于对象的每个实体而非整体: 当我们将物质切成两半时, 新得到的两半物质共享同样的固有属性集, 如密度, 沸点, 燃点, 颜色, 所有权等, 而类似重量, 长度, 形状等在划分时 &lt;strong&gt;无法保持不变&lt;/strong&gt; 的 &lt;strong&gt;非固有属性&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Extrinsic&lt;/code&gt;) 属性就不同.&lt;/p&gt;

&lt;p&gt;在定义中, 只包括固有属性的对象类就是 &lt;strong&gt;物质&lt;/strong&gt; 或 &lt;strong&gt;物质名词&lt;/strong&gt;, 而在定义中包含了任何非固有属性的类就是 &lt;strong&gt;可数名词&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;# 描述不可数的物质:
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∈&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Butter&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∧&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PartOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟹&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∈&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Butter&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∈&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Butter&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟹&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MeltingPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Centigrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 注意: 描述物质时使用下列语法:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;变量&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∈&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;物质名&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟹&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;这一物质的属性&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;事件&quot;&gt;事件&lt;/h3&gt;

&lt;p&gt;我们可以使用 &lt;strong&gt;情景演算&lt;/strong&gt; 表示 &lt;strong&gt;离散的, 瞬间的&lt;/strong&gt; 动作. 考虑连续动作, 如无害化处理一台 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MacBook Pro 2021&lt;/code&gt;, 情景演算可以告诉我们, 在这个动作之前我们有一台电子垃圾, 在这个动作之后我们得到了一系列可以被回收利用的电子元器件, 但它不能描述在这个动作期间发生了什么, 它也无法描述 &lt;strong&gt;在同一时间发生两个动作的情形&lt;/strong&gt;: 如在等拆卸 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MacBook Pro&lt;/code&gt; 完成的时候同时碾碎存有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Windows 11&lt;/code&gt; 源码的硬盘.&lt;/p&gt;

&lt;p&gt;为了处理这种情况, 我们引入基于 &lt;strong&gt;时间点&lt;/strong&gt; 而非 &lt;strong&gt;情景&lt;/strong&gt; 的,称为 &lt;strong&gt;事件演算&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Event Calculus&lt;/code&gt;) 的形式体系.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流&lt;/strong&gt; 和 &lt;strong&gt;事件&lt;/strong&gt; 在事件演算中是被物化的. 在事件演算中, 流是一个描述了某种事实的对象, 但它并不会提供更详细的信息, 诸如 “这个事实是否成立”. 我们需要使用额外的谓词声称一个流实际上在某些时间点成立.&lt;/p&gt;

&lt;p&gt;举例而言, 考虑流 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StudyIn(Axton, UoM)&lt;/code&gt;, 我们使用谓词 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T(flow, timePoint)&lt;/code&gt; 说明这个流在某个时间点 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; 上成立: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T(StudyIn(Axton, UoM), t)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;事件被描述为 &lt;strong&gt;事件类别的实例&lt;/strong&gt;. 如 “&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Axton&lt;/code&gt; 从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Manchester&lt;/code&gt; 飞到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Paris&lt;/code&gt; 的事件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E1&lt;/code&gt;” 表示为:&lt;/p&gt;

\[E_1 \in \text{Flyings} \wedge \text{Flyer}(E_1, \text{Axton}) \wedge \text{Origin}(E_1, \text{Manchester}) \wedge \text{Destination}(E_1, \text{Paris}).\]

&lt;p&gt;随后, 我们使用 $\text{Happens}(E_1, i)$ 表示 &lt;strong&gt;事件 $E_1$&lt;/strong&gt; 发生在事件区间 $i$. 一个事件演算版本的完整谓词集如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220102095836.png&quot; alt=&quot;20220102095836&quot; /&gt;&lt;/p&gt;

&lt;p&gt;构造一个特别事件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Start&lt;/code&gt;, 这一事件描述 &lt;strong&gt;初始状态&lt;/strong&gt;, 指出在起始时刻那些流被启动 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Initiate&lt;/code&gt;), 哪些流被终结 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Terminate&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;同时定义谓词 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T(event, t)&lt;/code&gt;: 若某个流被 &lt;strong&gt;过去某个时间的某个时间启动且没有被任何干扰事件终止 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clipped&lt;/code&gt;)&lt;/strong&gt;, 则这个流在当前的时间点为真. 反之, 若这个流 &lt;strong&gt;被某个事件终结且尚未被任何事件所恢复 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Restored&lt;/code&gt;)&lt;/strong&gt; 则这个流在当前时间点不成立. 形式上的公理为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220102100250.png&quot; alt=&quot;20220102100250&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clipped&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Restored&lt;/code&gt; 定义为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220102100318.png&quot; alt=&quot;20220102100318&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还可以将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 扩展到事件区间中: 一个流在某个时间区间上成立, 当且仅当它在 &lt;strong&gt;这个时间区间内的每个点上&lt;/strong&gt; 都成立.&lt;/p&gt;

\[T(f, (t_1, t_2)) \Leftrightarrow [\forall t (t_1\leqslant t &amp;lt; t_2) \Rightarrow T(f, t)].\]

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;# any process e that happens over an interval happens over any subinterval
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∈&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Processes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∧&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Happens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∧&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⟹&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Happens&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
 
&lt;span class=&quot;c1&quot;&gt;# 注意: 描述事件时遵循下列语法:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;变量&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∈&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;事件具备的一系列性质的合取&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 如: b ∈ Buyings ∧ Buyer(b, Mary) ∧ Seller(b, John) ∧ Price(b, GBP(400)) ∧ Item(b, bike) 
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 或者:
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;变量&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∈&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;事件名&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;事件中涉及的实体1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;事件中涉及的实体2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;事件中涉及的物体1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 如: b ∈ Buyings(Mary, John, GBP(400), bike)
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而在谓词 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 中, 流和动作使用专门领域公理定义.&lt;/p&gt;

&lt;p&gt;通过物化事件, 我们可以给它们增加 &lt;strong&gt;任何数量&lt;/strong&gt; 的 &lt;strong&gt;任意信息&lt;/strong&gt;. 通过扩展事件演算, 我们就可以表示 &lt;strong&gt;同时发生的事件&lt;/strong&gt;, &lt;strong&gt;外因事件&lt;/strong&gt;, &lt;strong&gt;连续事件&lt;/strong&gt; 和其他的复杂事件.&lt;/p&gt;

&lt;h3 id=&quot;过程&quot;&gt;过程&lt;/h3&gt;

&lt;p&gt;有一类事件具有 &lt;strong&gt;起始&lt;/strong&gt;, &lt;strong&gt;中途&lt;/strong&gt; 和 &lt;strong&gt;结尾&lt;/strong&gt;, 若从中间将这一事件打断, 事件的性质就会发生变化. 同时, 这样的事件类别具有不同的属性.&lt;/p&gt;

&lt;p&gt;具有这种特征的事件类别被称为 &lt;strong&gt;过程&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Process&lt;/code&gt;) 或 &lt;strong&gt;流事件&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Liquid Event&lt;/code&gt;): 发生在一个时间区间内的任何过程 $e$ 也可以在该时间区间的任何子区间内完成.&lt;/p&gt;

&lt;h3 id=&quot;时间区间&quot;&gt;时间区间&lt;/h3&gt;

&lt;p&gt;我们考虑两种时间区间: &lt;strong&gt;时刻 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Moment&lt;/code&gt;)&lt;/strong&gt; 与 &lt;strong&gt;时间 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExtendedIntervals&lt;/code&gt;)&lt;/strong&gt;. 它们的区别在于, &lt;strong&gt;时刻&lt;/strong&gt; 的长度为 $0$, 也就是说它只有 &lt;strong&gt;零刻度&lt;/strong&gt;.&lt;/p&gt;

\[\text{Partition}(\{\text{Moments}, \text{ExtendedIntervals}\}, \text{Intervals})\]

\[i \in \text{Moments} \Leftrightarrow \text{Duration}(i) = \text{Seconds}(0)\]

&lt;p&gt;随后我们取一个用来提供 &lt;strong&gt;绝对时间&lt;/strong&gt; 的 &lt;strong&gt;时间标尺&lt;/strong&gt;: 比如我们可以取格林尼治时区的 $1900$ 年 $1$ 月 $1$ 日 $00:00$ 为 $0$ 时刻, 构造函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Begin&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;End&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Duration&lt;/code&gt; 分别用来: 取一个区间的最早时刻, 取一个区间的最晚时刻, 为某个时刻在给定的时间标尺上找出对应的刻度点, 以及给出开始时间和结束时间的差值.&lt;/p&gt;

&lt;h3 id=&quot;流和对象&quot;&gt;流和对象&lt;/h3&gt;

&lt;p&gt;物理对象可以被视为是 &lt;strong&gt;一块时空片段&lt;/strong&gt;, 由此它也可以被视为 &lt;strong&gt;泛化事件&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;思维事件和思维对象&quot;&gt;思维事件和思维对象&lt;/h3&gt;

&lt;p&gt;到此为止, 我们已经构造出了对于现实世界中具备物理实体的事物的表示方式, 由此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 可以对它们产生和具备 &lt;strong&gt;信念&lt;/strong&gt; (或者知识), 并以此为基础演绎出新的信念. 下面, 我们需要考虑描述 &lt;strong&gt;思维对象&lt;/strong&gt; 和 &lt;strong&gt;操控这些思维对象的思维模型&lt;/strong&gt; 的模型.&lt;/p&gt;

&lt;p&gt;首先从 &lt;strong&gt;命题态度&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Propositional Attitudes&lt;/code&gt;) 入手. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt; 对思维对象可以有一系列的 &lt;strong&gt;态度&lt;/strong&gt;, 如 “确信“, ”了解”, “想要”, “打算”等, 我们使用 &lt;strong&gt;模态逻辑&lt;/strong&gt; 表示这些态度.&lt;/p&gt;

&lt;p&gt;常规的逻辑关注 &lt;strong&gt;单模态&lt;/strong&gt;, &lt;strong&gt;真值模态&lt;/strong&gt;, 如 “命题 $P$ 为真”. 而模态逻辑包含以 &lt;strong&gt;语句&lt;/strong&gt; 而非 &lt;strong&gt;项&lt;/strong&gt; 作为参数的 &lt;strong&gt;专用模态算子&lt;/strong&gt;, 如 “$A$ 知道 $P$” 用 $\mathbf{K}_{A}P$ 表示, 其中 $\mathbf{K}$ 就是用于知识的 &lt;strong&gt;模态算子&lt;/strong&gt;. 该算子具有两个参数: 一个记为下标的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Agent&lt;/code&gt;, 和一个语句.&lt;/p&gt;

&lt;p&gt;补充:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220105170752.png&quot; alt=&quot;20220105170752&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220105170802.png&quot; alt=&quot;20220105170802&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Equals()&lt;/code&gt; 公式处的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Before(i)&lt;/code&gt; 应该改为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Begin(i)&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;During&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Begin(i), Begin(j)&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;End(i), End(j)&lt;/code&gt; 是 &lt;strong&gt;严格不等关系&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220125215607.png&quot; alt=&quot;20220125215607&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Semantic Network:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;only Binary Relations&lt;/li&gt;
  &lt;li&gt;n-ary assertions &lt;strong&gt;need to be break down into binary relations&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Description Logics:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Subsumption: check if one category is a subset of another one by comparing definitions&lt;/li&gt;
  &lt;li&gt;Classification: Check whether an obj belongs to a category&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Consistency: Whether the membership crteria are logically satisfiable&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220125215806.png&quot; alt=&quot;20220125215806&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2021/12/25/COMP24011-Ch5/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/12/25/COMP24011-Ch5/</guid>
        
        <category>2021</category>
        
        <category>课程笔记</category>
        
        <category>COMP24011</category>
        
        
      </item>
    
  </channel>
</rss>
