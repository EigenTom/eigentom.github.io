<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>某一般线性空间</title>
    <description>由于作者太菜, 博客内容无法显示.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 11 Jun 2022 08:54:21 +0100</pubDate>
    <lastBuildDate>Sat, 11 Jun 2022 08:54:21 +0100</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>计算机图形学导论：复习</title>
        <description>&lt;h1 id=&quot;计算机图形学导论-复习&quot;&gt;计算机图形学导论: 复习&lt;/h1&gt;

&lt;h2 id=&quot;quiz&quot;&gt;Quiz&lt;/h2&gt;

&lt;h3 id=&quot;computer-graphics&quot;&gt;Computer Graphics&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521125744.png&quot; alt=&quot;20220521125744&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fragment&lt;/code&gt; 的定义.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521125811.png&quot; alt=&quot;20220521125811&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 实际上还是和答案有区别的: 阳间的计算机图形学框架会提供预先实现的着色器, 甚至会在用户未指定着色器时使用默认着色器渲染.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521125911.png&quot; alt=&quot;20220521125911&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这个要是考了的话我把出题人吃下去…)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521125941.png&quot; alt=&quot;20220521125941&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130037.png&quot; alt=&quot;20220521130037&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 因为为了统一表示平移变换 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Translation&lt;/code&gt;, 旋转变换 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rotation&lt;/code&gt; 和拉伸变换 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaling&lt;/code&gt;, 我们使用维度为 $4$ 而不为 $3$ 的齐次坐标)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130047.png&quot; alt=&quot;20220521130047&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 同时回顾以任意三维向量作为旋转轴时应该怎么做: 旋转轴转换到坐标轴上 - 执行旋转 - 转换回来)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130153.png&quot; alt=&quot;20220521130153&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 向量归一化的基本定义.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130309.png&quot; alt=&quot;20220521130309&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130220.png&quot; alt=&quot;20220521130220&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意向量点乘和叉乘的基本性质, 同时回顾使用右手定则确定向量叉乘结果方向的方法)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130318.png&quot; alt=&quot;20220521130318&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 栅格化, 也称曲面细分, 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenGL&lt;/code&gt; 只能处理凸多边形. 其实解答这类题目最困难的地方在于单词背不下来….)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130440.png&quot; alt=&quot;20220521130440&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 视角控制的是我们观察模型的方式.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130513.png&quot; alt=&quot;20220521130513&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这也是为什么 “用固定视点模拟虚拟相机” 可行的原因.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130547.png&quot; alt=&quot;20220521130547&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 实在记不住的话就回顾三维图形管线流程图: 模型变换总在视角变换之前应用.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130626.png&quot; alt=&quot;20220521130626&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 平行投影和透视投影是最基本的两种投影方式.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521130702.png&quot; alt=&quot;20220521130702&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 此处注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tetrahedron&lt;/code&gt; 就是 “台体/四面体”, 它是透视投影的视景体.)&lt;/p&gt;

&lt;h3 id=&quot;image-processing&quot;&gt;Image Processing&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606232905.png&quot; alt=&quot;20220606232905&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 计算方法不多赘述, 此处需要注意, 对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RGB&lt;/code&gt; 图像它包含三个颜色通道, 因此需要将计算出的, 存储单个颜色通道 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intensity&lt;/code&gt; 的文件大小相应地 &lt;strong&gt;乘以$3$&lt;/strong&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606233032.png&quot; alt=&quot;20220606233032&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 第一点最全面, 也最准确. 第二点可以描述是仿射变换和镜头畸变, 第三点是图像处理的基本假设, 第四点则属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Region Processing&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606233152.png&quot; alt=&quot;20220606233152&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thresholding&lt;/code&gt; 的实质是将灰度图像转换为只包含 $0$ 和 $255$ 两种 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intensity&lt;/code&gt; 的二值图, 其中黑色的部分是我们需要分离的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object&lt;/code&gt;, 背景被统一设为白色)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606233306.png&quot; alt=&quot;20220606233306&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 基于三原色理论, 我们可以使用三种基础颜色的混合得到大量的不同颜色, 同时三原色也和人眼视觉细胞对红, 绿, 蓝敏感的生理规律匹配.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606233425.png&quot; alt=&quot;20220606233425&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回忆: 色彩空间的基本分类为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CIE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YCrCb&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Perceptual Space&lt;/code&gt;. 第一个是 $1931$ 年的古墓级标准, 第二个用于数字视频领域, 最后一个具备的特点是贴合视觉规律, 即: 我们关注色彩的变化而不是绝对准确的色彩表示. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CIE&lt;/code&gt; 色域图中边缘部分的不同色彩在人看来实际上非常相似, 这并不是我们所需要的)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606233758.png&quot; alt=&quot;20220606233758&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 对基本 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pointwise Processing&lt;/code&gt; 的变换原理和对应的变换矩阵表示需要非常熟悉! 显然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaling&lt;/code&gt; 本质是对比度调节, 但是对比度调节中同时伴随了亮度变化.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606233929.png&quot; alt=&quot;20220606233929&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾课上介绍的非线性变换曲线. 显然曲线的形状会决定 $x$ 轴对应 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intensity value&lt;/code&gt; 被映射到的值. 基于曲线凹凸形状不同, 每个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;intensity&lt;/code&gt; 可能被映射到不同的值, 具体会体现出多少效果, 体现出哪些效果完全依照曲线形状而定)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606234145.png&quot; alt=&quot;20220606234145&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slides&lt;/code&gt; 上那张曼哈顿街区的图: 灰度插值不仅会导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Image Histogram&lt;/code&gt; 中每一条柱之间存在间隙, 在视觉上还会有 “色彩断层” 的效果.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606234504.png&quot; alt=&quot;20220606234504&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意仿射变换是几何变换的 &lt;strong&gt;子集&lt;/strong&gt;, 任何几何变换一定会影响像素在图像坐标系中的坐标. 此处考虑一般性, 不许举诸原地旋转 $360\degree$, 缩放 $1$ 倍这种例子抬杠)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220606234646.png&quot; alt=&quot;20220606234646&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 此处注意回忆角分辨率的计算方式和性质. 可知在固定像素数量不变的情况下, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fov&lt;/code&gt; 越大角分辨率越大, 每个像素对应的视角度数越大, 能表示的最小物体的大小越大, 越不清晰.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609115129.png&quot; alt=&quot;20220609115129&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意卷积运算在图形处理中的实际作用: 检查image和template之间的相似性. 剩下的三个选项分别是template matching 卷积核, Box Filter/Gaussian Filter, Edge Detectors的功能, 它们本质上执行的都是卷积运算.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609164353.png&quot; alt=&quot;20220609164353&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 在正常情况下, 绝大多数噪音都是远小于实际信号的, 因此可以通过averaging让这些噪音自行互相抵消.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609164436.png&quot; alt=&quot;20220609164436&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾课上内容: 常规的 box filter 对边缘的模糊效应最严重, Gaussian Filter 可以避免在边缘上出现 ringing effect, 但仍然会模糊边缘. median filter 则基本不会模糊边缘, 也就是 “retain significant image structures”.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609164618.png&quot; alt=&quot;20220609164618&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这里实际上就是在描述 Gaussian Smoothing 不会导致边缘出现 ringing effect 的特性.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609164702.png&quot; alt=&quot;20220609164702&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回忆对 Prewitt, Sobel 卷积核的, 拆成一个averaging kernel 和一个edge detection kernel 的拆解过程. 同时明确卷积计算的时间复杂度, 从此可以看出通过将 square template 拆分成两个卷积核分别计算可以节约大量的计算资源和时间.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609164844.png&quot; alt=&quot;20220609164844&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 避免 overflow 是老生常谈的事情)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609164925.png&quot; alt=&quot;20220609164925&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意对 “边” 的定义. $12$ 题的做法实际上就是最简单的 Simple edge detection 进行的操作)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609165136.png&quot; alt=&quot;20220609165136&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾课上介绍的例子, template 源于图片本身)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609165958.png&quot; alt=&quot;20220609165958&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意对 blob 的定义: 一系列连续的, 共享某些性质的像素的集合. 它被用于物体识别和表示, 我们可通过表示 blob 的外围构造 (path, chain code), 计算周长, 计算大致面积 (shoelace algorithm), 表示颜色等方式描述它的特征.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609170143.png&quot; alt=&quot;20220609170143&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 实际上这也是我们在课上唯一关心的, 检测 blob 的方式.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609170237.png&quot; alt=&quot;20220609170237&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path&lt;/code&gt; 是 &lt;strong&gt;首尾相连&lt;/strong&gt; 的. 一般可以用 chain code 表示.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609170308.png&quot; alt=&quot;20220609170308&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回忆 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CCA&lt;/code&gt; 分为两次扫描, 得到的结果是: 同一个 blob 中所有的像素均被赋予相同的 label.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609170354.png&quot; alt=&quot;20220609170354&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Central Moment&lt;/code&gt; 可视为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Moment&lt;/code&gt; 关于 blob 重心的偏置)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609170600.png&quot; alt=&quot;20220609170600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意此处 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;center of gravity&lt;/code&gt; 的计算方式: $\frac{M_{10}}{M_{00}}, \frac{M_{01}}{M_{00}}$.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609170728.png&quot; alt=&quot;20220609170728&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回忆我们使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;differential chain code&lt;/code&gt; 表示 blob 边缘的生成, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perimeter&lt;/code&gt; 的计算涉及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain code&lt;/code&gt; 中奇数和偶数的数量, 由于外部环境的影响得到的图像中 blob 的亮度可能随着光照不同发生变化, 属于干扰 blob tracking 的不利因素, 应当利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HSI, HSB&lt;/code&gt; 等色彩和亮度分离的色彩标准, 排除 Intensity 的影响只考虑 Chromaticity.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609165223.png&quot; alt=&quot;20220609165223&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ Hough Transformation 将图像平面中的点映射为一条直线, 也就是表示 “所有过这点可能的直线”; 将图像平面中的直线映射为一个点.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609165403.png&quot; alt=&quot;20220609165403&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609165332.png&quot; alt=&quot;20220609165332&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 务必对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hough Plane&lt;/code&gt; 中, 直线的直角坐标表示和极坐标表示足够熟悉. 直线用这样的直角坐标表示是因为我们找到点之后已经固定了 $x$ 和 $y$, 此时变量就是 $m$ 和 $c$.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609165853.png&quot; alt=&quot;20220609165853&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ Structured elements 就是一系列像素组成的物体, 大小和形状不定.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220609165758.png&quot; alt=&quot;20220609165758&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 如果被 erode 的 structuring element 太小的话它自身就可能会连同 noise 一起被腐蚀掉.)&lt;/p&gt;

&lt;h2 id=&quot;复习笔记&quot;&gt;复习笔记&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/KirisameR/KirisameR.github.io/blob/master/_posts/IP%20REVISION.pdf&quot;&gt;Here&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jun 2022 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/2022/06/06/REV-COMP27112/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/06/06/REV-COMP27112/</guid>
        
        <category>课程笔记</category>
        
        <category>计算机图形学</category>
        
        <category>大二下期末总复习</category>
        
        
      </item>
    
      <item>
        <title>机器学习导论： 复习</title>
        <description>&lt;h1 id=&quot;comp24112-期末总复习&quot;&gt;COMP24112 期末总复习&lt;/h1&gt;

&lt;p&gt;见笔记: &lt;a href=&quot;https://github.com/KirisameR/KirisameR.github.io/blob/master/_posts/ML%20REVISION.pdf&quot;&gt;Here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直接参考资料: COMP24112全部课程内容
框架体系直接参考对象: COMP24112复习指导Slides&lt;/p&gt;

&lt;p&gt;注: 和复习指导Slides相比, 部分章节中的部分项有合并, 顺序也有重新安排.&lt;/p&gt;
</description>
        <pubDate>Tue, 31 May 2022 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/2022/05/31/REV-COMP24112/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/05/31/REV-COMP24112/</guid>
        
        <category>课程笔记</category>
        
        <category>人工智能</category>
        
        <category>机器学习</category>
        
        <category>大二下期末总复习</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： 复习</title>
        <description>&lt;h1 id=&quot;comp26120-算法期末总复习&quot;&gt;COMP26120 算法期末总复习&lt;/h1&gt;

&lt;h2 id=&quot;quiz&quot;&gt;Quiz&lt;/h2&gt;

&lt;h3 id=&quot;week1-graph-traverse-and-topological-sorting&quot;&gt;Week1: Graph Traverse and Topological Sorting&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522165005.png&quot; alt=&quot;20220522165005&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意存储图的两种方式: 空间占用小但删除边和检测边时间复杂度为 $O(\vert v \vert)$ 的邻接列表, 和只有检测后继边时间复杂度为 $O(\vert v \vert)$ 但空间占用为 $O(\vert v^2 \vert)$的邻接矩阵法, 后者适合边多的图, 前者适合边稀疏的图)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522165219.png&quot; alt=&quot;20220522165219&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意简单图的定义: 就是没有重复的边的图, 显然上面的图有圈)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522165256.png&quot; alt=&quot;20220522165256&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 如果有向图中的任何节点 &lt;strong&gt;既没有任何父节点&lt;/strong&gt; 又 &lt;strong&gt;不是初始节点&lt;/strong&gt;, 则它永远不可达)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522165359.png&quot; alt=&quot;20220522165359&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 别脑抽把堆和栈搞混了. 清楚的记忆方式是: 假设检查到新节点时总是将新节点放到一个列表末尾, 如果把列表当作栈处理则总是弹出刚刚插入的新节点 (因此深度优先), 反之则优先弹出旧节点 (因此广度优先).)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522165522.png&quot; alt=&quot;20220522165522&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 深度优先不会搜索已发现过的节点)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522165618.png&quot; alt=&quot;20220522165618&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意拓扑排序的执行过程: 先执行 &lt;strong&gt;对有向图&lt;/strong&gt; 的含圈检测, 只有确定图中无圈后才会进一步执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFS&lt;/code&gt; 得到排序结果)&lt;/p&gt;

&lt;h3 id=&quot;week2-shortest-path&quot;&gt;Week2: Shortest Path&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173038.png&quot; alt=&quot;20220522173038&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173052.png&quot; alt=&quot;20220522173052&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BFS&lt;/code&gt; 的最短路径寻觅算法用 &lt;strong&gt;队列&lt;/strong&gt; 存储 &lt;strong&gt;每个节点的深度最低的父节点&lt;/strong&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173159.png&quot; alt=&quot;20220522173159&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 所以某种意义上说, 有权图中任意两点的路径具有唯一性)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173230.png&quot; alt=&quot;20220522173230&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 最短路径 &lt;strong&gt;可以不唯一&lt;/strong&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173248.png&quot; alt=&quot;20220522173248&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法的 &lt;strong&gt;适用范围&lt;/strong&gt;: 只要图中 &lt;strong&gt;不存在总权重为负的圈&lt;/strong&gt;, 那么不管这个图长啥样都适用该算法.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173334.png&quot; alt=&quot;20220522173334&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这种题都做错的话说明 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法的基本原理都没搞懂, 罚你留级)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173417.png&quot; alt=&quot;20220522173417&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法松弛循环的最大运行次数, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Worst Case&lt;/code&gt;: 图退化为路径, 以及该算法的实际时间复杂度 $O(\vert V \vert \cdot \vert E \vert)$. 原因: 因为还要同时检查图里是否有负权圈, 所以增加了时间复杂度)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522173548.png&quot; alt=&quot;20220522173548&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾解释 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法正确性时对循环不变量的构造)&lt;/p&gt;

&lt;h3 id=&quot;week3-dijkstra-和-a&quot;&gt;Week3: Dijkstra 和 A*&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522193123.png&quot; alt=&quot;20220522193123&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522193929.png&quot; alt=&quot;20220522193929&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 如果做错的话请再次回顾三种计算有权图最短路径算法的适用范围, 这个问题已经在前面的笔记里着重强调多次了, 还不会的话罚你明年重修)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522193225.png&quot; alt=&quot;20220522193225&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522193619.png&quot; alt=&quot;20220522193619&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法对所有节点目标路径权重的估计逻辑和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 算法是一样的; 同时回顾定义: 如果真的有某条 “边” 在 &lt;strong&gt;边的&lt;/strong&gt; 权重矩阵中对应值为 $\infty$, 说明 &lt;strong&gt;对应两个节点之间实际上不相连&lt;/strong&gt;. )&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522193305.png&quot; alt=&quot;20220522193305&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这样可以优先找路径权重估计相对最小的点, 比在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D (Discovered Nodes)&lt;/code&gt; 中盲目瞎猜可以更快地先找到真正的最短路径)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522193656.png&quot; alt=&quot;20220522193656&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 该题不难, 但想象一下新场景: 如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w(a,b)=3.75&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w(s, c)=3.5&lt;/code&gt;, 此时该选谁?)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522193745.png&quot; alt=&quot;20220522193745&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这个性质是和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 结合启发式的贪心剪枝特征结合的, 正是由于结合了启发式, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 可以安全地确保只要计算到目标节点的松弛时, 所计算出的一定是最优解.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522194026.png&quot; alt=&quot;20220522194026&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522194033.png&quot; alt=&quot;20220522194033&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A*&lt;/code&gt; 算法的优化原理与各自的假设必须理解得非常清楚: 二者实际上都是基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bellman-Ford&lt;/code&gt; 发展而来的产物, 前者的性能优化基于 “单源最短路径的求解具有贪心性质: 最优解的局部解必也是最优局部解” 这一假设; 而后者在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 基础上引入了启发式函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H()&lt;/code&gt; 估计每个节点到目标节点的距离用以实现进一步剪枝)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522194306.png&quot; alt=&quot;20220522194306&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾课上介绍 “启发单调性” 时展示的三角形关系可知, 满足启发单调性的启发函数绝不会 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;overestimate&lt;/code&gt;; 也可回忆课上对这部分内容介绍时的逻辑顺序: 启发单调性实际上是比可启发性更强的性质)&lt;/p&gt;

&lt;h3 id=&quot;week4-最小生成树&quot;&gt;Week4: 最小生成树&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522205130.png&quot; alt=&quot;20220522205130&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 生成树的基本定义)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522205153.png&quot; alt=&quot;20220522205153&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 关于贪心算法的性质可以回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lab5&lt;/code&gt; 中对 $0-1$ 背包问题的贪心算法实现)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522205234.png&quot; alt=&quot;20220522205234&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 通用贪心算法每次循环都让子 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt; 多连接一个图中的点, a.k.a. 多一条边, 因此需要循环 $\vert V\vert -1$ 次才能包含图中所有点)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522205339.png&quot; alt=&quot;20220522205339&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cut&lt;/code&gt; 一定要经过边 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ad&lt;/code&gt;, 在此基础上它可以经过任意其他边. 显然在这里它可以经过权重最小的边 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cd&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522205439.png&quot; alt=&quot;20220522205439&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法的基本思路, 它是 &lt;strong&gt;基于任何边的权重&lt;/strong&gt; 的, 添加的边可能当前并不和子 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt; 连通, 但最终总会连通. 因此它会考虑剩下的全局权重最小边, 必然选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ef&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522205604.png&quot; alt=&quot;20220522205604&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Union By Rank&lt;/code&gt; 的概念. 所谓的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rank&lt;/code&gt; 实际上指的是树的深度, 浅的树的根节点直接挂靠到更深的树的根节点上.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522205656.png&quot; alt=&quot;20220522205656&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 此处借这个例子解释一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法的执行过程):&lt;/p&gt;

&lt;p&gt;首先生成 $6$ 个并查集和一个空的子 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt;, 记为 $A$. 然后考虑全局权重最小边, 不妨假设在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ac&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bf&lt;/code&gt; 中随机选择了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;然后监测到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 所在的并查集代表元不同, 因此合并. 这里因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 的并查集深度相同所以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Union By Rank&lt;/code&gt; 规则下怎么合并都行, 不妨假设 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 挂靠到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 上. 此时将这条最短边 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bf&lt;/code&gt; 加入 $A$ 中.&lt;/p&gt;

&lt;p&gt;然后在剩下的边中找剩下的最短边, 挑到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ac&lt;/code&gt;. 重复同样的过程, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 挂靠在一起, 新的边&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ac&lt;/code&gt; 被加入 $A$.&lt;/p&gt;

&lt;p&gt;再然后用相同的方式可以随机选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cf&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df&lt;/code&gt;, 为了偷懒少打字解释这里假设随机选到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cf&lt;/code&gt;. 由此我们就将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 合四为一放在同一个并查集里, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cf&lt;/code&gt; 被加入 $A$ 中.&lt;/p&gt;

&lt;p&gt;进一步地就剩下了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df&lt;/code&gt;. 在这一步之后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 也被扔进 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acbf&lt;/code&gt; 集中营, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df&lt;/code&gt; 加入 $A$ 中.&lt;/p&gt;

&lt;p&gt;然后按照规则我们应该在剩余的边里选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ab&lt;/code&gt;. 由于已知 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acbfd&lt;/code&gt; 此时都挤在同一个并查集里, 所以根据规则这条边不能加, 扔掉.&lt;/p&gt;

&lt;p&gt;再然后我们可以用同样的原因扔掉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cd&lt;/code&gt;, 把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;de&lt;/code&gt; 加入 $A$. 此时只剩下唯一的一个并查集, 其中就已经全部包含了图的所有顶点.&lt;/p&gt;

&lt;p&gt;此时回头看我们的 $A$, 知道包含边 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bf&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ac&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cf&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;de&lt;/code&gt;, 权重总和为 $19$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522210552.png&quot; alt=&quot;20220522210552&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 此处借此机会解释一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法的运作过程):&lt;/p&gt;

&lt;p&gt;我们拿到的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法运作的中间状态, 此时子树 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 已经包含 &lt;strong&gt;连通&lt;/strong&gt; 的三条边 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ac&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ab&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;然后考虑剩下的边中 &lt;strong&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 相连, 至少有一个顶点不在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 中, 而且权重最小&lt;/strong&gt; 的边, 显然排除掉不满足规则的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cf&lt;/code&gt; 之后最合适的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 的 “早有预谋” 不同, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 算法就是这样一步步地逐渐生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 的. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法每一步扔进 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 的边都是 “不一定和当前子树连接, 但最终必会相连” 的边, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prims&lt;/code&gt; 每次新增的边都是和当前子树连接的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522210947.png&quot; alt=&quot;20220522210947&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 因此不难看出, 其实这个错误选项所描述的更像是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kruskal&lt;/code&gt; 算法)&lt;/p&gt;

&lt;h3 id=&quot;week5-线性规划&quot;&gt;Week5: 线性规划&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522212332.png&quot; alt=&quot;20220522212332&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 务必注意线性规划中 &lt;strong&gt;目标函数&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Objective Function&lt;/code&gt;) 和 &lt;strong&gt;约束函数&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Constraint Function&lt;/code&gt;) 的区别! 这里要我们找的是目标函数, 不是约束函数.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522212459.png&quot; alt=&quot;20220522212459&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 虽然反直觉, 但是考虑到如果要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Minimise&lt;/code&gt; 则无意义的 $0$ 就一定是解. 具体的解释看高亮部分)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522212541.png&quot; alt=&quot;20220522212541&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这也会是下一章单纯形法原理的一部分)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522212623.png&quot; alt=&quot;20220522212623&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522212651.png&quot; alt=&quot;20220522212651&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意在线性规划的标准形式下目标函数总是要被取最大值的, 所有的约束要表示为 “小于等于” 形式)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522212736.png&quot; alt=&quot;20220522212736&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 只要可被表示为 &lt;strong&gt;线性的&lt;/strong&gt; 包含 &lt;strong&gt;小于等于号&lt;/strong&gt; 的形式, 它就是合法约束)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522212825.png&quot; alt=&quot;20220522212825&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 想什么呢, 你甚至都不是线性的…)&lt;/p&gt;

&lt;h3 id=&quot;week6-单纯形法&quot;&gt;Week6: 单纯形法&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522213106.png&quot; alt=&quot;20220522213106&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522213155.png&quot; alt=&quot;20220522213155&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 “基础变量”, “松弛变量” 和 “基础解” 的定义)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507212049.png&quot; alt=&quot;20220507212049&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( $\uparrow$ 注意高亮部分对 “为何 Pivoting 等价于从一个可行解移动到邻接的另一个可行解” 的解释.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507212153.png&quot; alt=&quot;20220507212153&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( $\uparrow$ 注意运用课上提到的, 选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pivot&lt;/code&gt; 行的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Heuristic&lt;/code&gt; 规则.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507212223.png&quot; alt=&quot;20220507212223&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507212244.png&quot; alt=&quot;20220507212244&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( $\uparrow$ 检查 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unbounded&lt;/code&gt; 问题时都需要考虑全面.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507212351.png&quot; alt=&quot;20220507212351&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( $\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Degeneracy&lt;/code&gt; 的概念: “A pivot in the Simplex Method is said to be degenerate when it doesn’t change the basic solution”.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507212458.png&quot; alt=&quot;20220507212458&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( $\uparrow$ 注意对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Simplex&lt;/code&gt; 算法最高执行次数的分析)&lt;/p&gt;

&lt;h3 id=&quot;week7-高级单纯形法&quot;&gt;Week7: 高级单纯形法&lt;/h3&gt;

&lt;p&gt;先连着看几个 &lt;strong&gt;同类型问题&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508154438.png&quot; alt=&quot;20220508154438&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508154738.png&quot; alt=&quot;20220508154738&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508155003.png&quot; alt=&quot;20220508155003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508155137.png&quot; alt=&quot;20220508155137&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leaving variable&lt;/code&gt; 的选择顺序: 若 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entering variable&lt;/code&gt;列参数不全为负则问题有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bound&lt;/code&gt;; 然后检查 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pivot&lt;/code&gt; 是否有 $0$ 值, 如果有 $0$ 值的话再检查 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entering variable&lt;/code&gt; 列的系数: 如果有正系数且对应 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pivot&lt;/code&gt; 为 $0$, 则选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pivot&lt;/code&gt; 为 $0$ 中 &lt;strong&gt;正系数最小&lt;/strong&gt; 的; 如果只有负系数则和原来一样考虑使 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pivot&lt;/code&gt; 非负且最小的行.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508154817.png&quot; alt=&quot;20220508154817&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 其实不一定非得选 $a_1$, 只要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leaving variable&lt;/code&gt; 为 $s_1$, 通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pivoting&lt;/code&gt; 能把问题转换为常规形态可解问题的话选啥都行, 但在这里选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a_1&lt;/code&gt; 的话方便计算, 好做)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508155029.png&quot; alt=&quot;20220508155029&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 只要看到某列系数全负直接扔掉)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508155120.png&quot; alt=&quot;20220508155120&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 解释的很清楚了, 自己看)&lt;/p&gt;

&lt;h3 id=&quot;week8-el-gamel&quot;&gt;Week8: El Gamel&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522213931.png&quot; alt=&quot;20220522213931&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 实际上, 从数论知识可知任何素数 $p$ 都有 $\phi(\phi(p))$ 个原根, 因此在这里 $11$ 的原根有 $4$ 个.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522214436.png&quot; alt=&quot;20220522214436&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这里其实无需考虑太多, 首先 $2$ 和 $8$ 就不互素).&lt;/p&gt;

&lt;p&gt;此处介绍一个 &lt;strong&gt;快速判断给定数 $g$ 是否为某个素数 $m$ 的原根的方法&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;若 $g$ 是 素数 $m$ 的原根, 则它必然满足;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$0 \leqslant g &amp;lt; m$&lt;/li&gt;
  &lt;li&gt;$\text{gcd(g, m) = 1}$&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考虑 $\phi(m)$ 中的所有 &lt;strong&gt;质因子&lt;/strong&gt;, 对任何其质因子 $q$, 均有&lt;/p&gt;

\[g^{\frac{\phi(m))}{q}} \not \equiv 1 ~\text{mod}~ p.\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522214653.png&quot; alt=&quot;20220522214653&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522214704.png&quot; alt=&quot;20220522214704&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这个…没啥好说的, 背吧…)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522214753.png&quot; alt=&quot;20220522214753&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾最后一章中介绍的 &lt;strong&gt;伪线性时间复杂度&lt;/strong&gt; 算法的定义以及素数检测章节中 &lt;strong&gt;伪线性的朴素素数检测法&lt;/strong&gt;, 可知这个函数才是计算困难度理论下的真正的线性函数: 计算时间的增长关于输入位数长度的增长是线性的.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522214840.png&quot; alt=&quot;20220522214840&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾 “单向加密” 原则)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522215002.png&quot; alt=&quot;20220522215002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 此处注意联系 &lt;strong&gt;原根&lt;/strong&gt; 的定义理解. 实际上对于任何一个合法的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamel&lt;/code&gt; 加密公钥, 只要前两个值分别是: 素数 $p$, 以及 $p$ 的原根, a.k.a. $\mathbb{Z}_{p}$ 的生成元, 则第三个数 $y$ 只要比 $p$ 小就行, 因为总存在一个位于 $p$ 的简化剩余系中的 $x$ 使 $g^{x} ~ \text{mod} ~ p \equiv y$.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522215412.png&quot; alt=&quot;20220522215412&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 此处第一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Statement&lt;/code&gt; 成立的原因实际上是和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamel&lt;/code&gt; 加密法公钥和私钥精密的构造方式直接相关的)&lt;/p&gt;

&lt;h3 id=&quot;week9-素数检测&quot;&gt;Week9: 素数检测&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220512025430.png&quot; alt=&quot;20220512025430&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 抓住基本定义: 对二进制形式位长为 $n$ 的数 $x$ 而言,$\pi(x)) \approx \frac{x}{\ln(2^n)}$, 因此平均要测 $\ln(2^n)$ 次.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220512025549.png&quot; alt=&quot;20220512025549&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 二进制形式位长为 $n$ 的数大小最多不超过 $2^n$, 而基本除法从该数的平方根开始反推到 $1$, 因此最多执行不超过 $2^{\frac{n}{2}}$ 次.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220512025957.png&quot; alt=&quot;20220512025957&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220512025943.png&quot; alt=&quot;20220512025943&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 两个同类问题, 注意对随机素数判定法循环体中循环次数 $t$ 的计算方式和推导原理, 记住计算完后要向上取整.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220512030101.png&quot; alt=&quot;20220512030101&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 经典问题, 注意费马小定理的重要条件: 可正确判定 $x$ 为素数的必要不充分条件是 $x$ 还需要和 $n$ 互素.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220512030215.png&quot; alt=&quot;20220512030215&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回顾我们在介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 素数判定法时引入的结论: 当且仅当 $n$ 为素数时, 对于 $x^2 ~\equiv~1~\text{mod} (n)$ 有 $x ~\equiv~ \pm 1 ~\text{mod}~n$. 在本题中对 $x$ 的取值范围限定了 $x$ 绝不可能满足 $x ~\equiv~ \pm 1 ~\text{mod}~n$, 因此 $x$ 必不为素数.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220512030535.png&quot; alt=&quot;20220512030535&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 此处对算法运行时间复杂度的估计需要结合上一章中对快速模幂算法的时间复杂度 $O(\log(n))$.)&lt;/p&gt;

&lt;h3 id=&quot;week10-不-可计算性&quot;&gt;Week10: (不) 可计算性&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201627.png&quot; alt=&quot;20220521201627&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 基础的定义问题, 包含关系弄反了)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201655.png&quot; alt=&quot;20220521201655&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这个问题的答案本质上是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P != NP?&lt;/code&gt; 的答案. 但是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P != NP?&lt;/code&gt; 有答案吗? 想想量子计算机.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201818.png&quot; alt=&quot;20220521201818&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 检测的时间复杂度必须是 &lt;strong&gt;关于输入长度呈多项式级&lt;/strong&gt; 的.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201946.png&quot; alt=&quot;20220521201946&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201956.png&quot; alt=&quot;20220521201956&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 记住偏序关系 $\leqslant_{P}$ 的构造顺序: &lt;strong&gt;若$A$ 可被多项式时间内简化为 $B$, 则计算困难度关系为 $A \leqslant_{P} B$&lt;/strong&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521202113.png&quot; alt=&quot;20220521202113&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 记住: 对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题, 其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;certificate&lt;/code&gt; 的长度和检验 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;certificae&lt;/code&gt; 消耗的时间都要与其 &lt;strong&gt;输入长度而非输入数值大小&lt;/strong&gt; 的变化呈 &lt;strong&gt;多项式&lt;/strong&gt; 级别的关系.)&lt;/p&gt;

&lt;h3 id=&quot;week11-展示-np-completeness&quot;&gt;Week11: 展示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Completeness&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522001001.png&quot; alt=&quot;20220522001001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 对于 $k \geqslant 3$, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k-SAT&lt;/code&gt; 问题都是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; 的.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522001424.png&quot; alt=&quot;20220522001424&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 搭建逻辑门电路硬编码验证函数 $A(w, c)$, 所有了解从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 简化的人都应该对这个结论印象深刻)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522001606.png&quot; alt=&quot;20220522001606&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意熟悉不同图相关 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; 问题的定义)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522001643.png&quot; alt=&quot;20220522001643&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 仔细观察会发现这其实是 $0-1$ 背包问题, 由于没有分划因此问题和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bin Packing&lt;/code&gt; 无关, 由于该问题不涉及任何与图相关的语义 (不排除一开始看到地图会自然联想到旅行商问题, 但完整看一遍题目描述会发现主角并不能规划路线) 因此可排除出正确结果.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522001832.png&quot; alt=&quot;20220522001832&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 这里的定义解释的已经很清楚了, 有时间的话最后一周的最后一个视频还是要看)&lt;/p&gt;

&lt;h2 id=&quot;past-paper&quot;&gt;Past Paper&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525164500.png&quot; alt=&quot;20220525164500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意图的两种表示方式使用的数据结构区别: 列表/链表和数组. 其中后者只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;successor()&lt;/code&gt; 查找性能为 $O(V)$.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525164642.png&quot; alt=&quot;20220525164642&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 对深度优先和广度优先算法而言, 若在从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Discovered&lt;/code&gt; 序列/栈中弹出某个节点, 检查该节点时发现了任何 &lt;strong&gt;已经在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Discovered&lt;/code&gt; 中的子顶点&lt;/strong&gt;, 则需要将这些被新发现的顶点在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Discovered&lt;/code&gt; 中的顺序 &lt;strong&gt;更新&lt;/strong&gt;: 删掉原来的, 然后按照题目给定的顺序放到序列/栈尾.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525164846.png&quot; alt=&quot;20220525164846&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 不作过多解释. 需要注意, 最基础的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt; 算法: 通用贪心算法同样是依赖 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cut&lt;/code&gt; 的. 同时回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MST&lt;/code&gt; 的定义: 连接图中 &lt;strong&gt;所有&lt;/strong&gt; 顶点的树; 最小生成树可以不唯一, 也可以压根就没有.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525165059.png&quot; alt=&quot;20220525165059&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 处理这类题的时候务必使用 &lt;strong&gt;机器时间&lt;/strong&gt; 计算约束.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525165236.png&quot; alt=&quot;20220525165236&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 回忆单纯形法中选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pivot&lt;/code&gt; 的两条基本规则.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525165337.png&quot; alt=&quot;20220525165337&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 牢记 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 算法的基本原理和错误率 $q=0.25$.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525165429.png&quot; alt=&quot;20220525165429&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP, NP Hard, NPC&lt;/code&gt; 之间的关系: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPC&lt;/code&gt; 是那些同时为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP Hard&lt;/code&gt; 的问题. 因此此处的包含关系无误.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220525165540.png&quot; alt=&quot;20220525165540&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt; 关系有传递性.)&lt;/p&gt;

&lt;p&gt;最后注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Synoptic Questions&lt;/code&gt; 的答题要点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;给定问题要求提出算法类的问题需要依次回答 &lt;strong&gt;所使用的数据结构和算法, 以及算法设计技术&lt;/strong&gt;, &lt;strong&gt;算法本身的基本流程说明 (可以附上伪代码)&lt;/strong&gt; 以及 &lt;strong&gt;复杂度分析&lt;/strong&gt;. 每个过程都要详细说清楚, 如果涉及并查集或任何涉及并查集的算法需要一并说明并查集的实现方式: 树, 以及路径优化方式: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Path Compression&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;给定问题实现要求答出使用的算法/程序设计思想类型一类的问题需要明确回答 &lt;strong&gt;所使用的算法和程序设计思想&lt;/strong&gt;, &lt;strong&gt;使用循环不变量的方式证明程序的正确性&lt;/strong&gt; (Base Case, Step Case, Final case), 并分析说明程序的时间复杂度.&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 22 May 2022 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/2022/05/22/REV-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/05/22/REV-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        <category>大二下期末总复习</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： 可计算性问题</title>
        <description>&lt;h1 id=&quot;可计算性问题&quot;&gt;可计算性问题&lt;/h1&gt;

&lt;p&gt;在本章中, 我们将对 &lt;strong&gt;可计算性问题&lt;/strong&gt; 进行介绍. 我们将依序介绍三种 &lt;strong&gt;问题的复杂度类&lt;/strong&gt;: 可使用确定性算法在 &lt;strong&gt;多项式时间内&lt;/strong&gt; 被求解的问题类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Polynomial Time&lt;/code&gt;), &lt;strong&gt;使用确定性算法在多项式时间内无法求解但可验证&lt;/strong&gt; 的问题类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Non-Polynomial Time&lt;/code&gt;), &lt;strong&gt;比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题更难求解且无法确定能否在多项式时间内被验证&lt;/strong&gt; 的问题类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Hard&lt;/code&gt;, 以及 &lt;strong&gt;既是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题又是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Hard&lt;/code&gt; 问题&lt;/strong&gt; 的问题类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt;.、&lt;/p&gt;

&lt;p&gt;我们还将进一步介绍可用来验证给定问题属于哪个复杂度类的基本知识和技术, 并将通过一些例子说明应用.&lt;/p&gt;

&lt;h2 id=&quot;p-np-和其他非确定性问题-intractable-问题定义&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 和其他非确定性问题 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intractable&lt;/code&gt;) 问题定义&lt;/h2&gt;

&lt;h3 id=&quot;直观定义&quot;&gt;直观定义&lt;/h3&gt;

&lt;p&gt;我们首先分别说明 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Hard&lt;/code&gt; 的定义.&lt;/p&gt;

&lt;p&gt;首先明确, 这些定义都是对 &lt;strong&gt;问题的难易程度&lt;/strong&gt; 的描述. 在这里, 我们对问题的 “难易程度” 所下的定义就是: 解决这一问题所需要的 &lt;strong&gt;时间复杂度&lt;/strong&gt; 是什么. 显然, 对于计算能力相同的硬件而言, 需要更短计算时间就可解决的问题自然相对简单; 而对人类而言, 只有在我们的认知内可接受的时间范围内能够将问题解决的算法才具有实际意义.&lt;/p&gt;

&lt;p&gt;因此, 我们根据 &lt;strong&gt;时间复杂度&lt;/strong&gt; 可将计算问题粗略的分为三类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class P&lt;/code&gt;: 任何可在 &lt;strong&gt;多项式时间内&lt;/strong&gt; 由 &lt;strong&gt;确定性算法&lt;/strong&gt; 得出结论的问题都属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; 类问题.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt;: 任何 &lt;strong&gt;需要使用非确定性算法&lt;/strong&gt; 才能在多项式时间内求解, &lt;strong&gt;或&lt;/strong&gt; 可在 &lt;strong&gt;多项式时间内检验解答是否正确&lt;/strong&gt; 的问题属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP-Hard&lt;/code&gt;: &lt;strong&gt;难度至少和所有的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题一样难&lt;/strong&gt; 的问题属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Hard&lt;/code&gt; 问题.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP-Complete&lt;/code&gt;: &lt;strong&gt;既属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 类, 又属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Hard&lt;/code&gt; 类&lt;/strong&gt; 的问题为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Hard&lt;/code&gt; 问题.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521171150.png&quot; alt=&quot;20220521171150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在本课程中, 我们认为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Hard&lt;/code&gt; 问题之间是 &lt;strong&gt;包含关系&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521171342.png&quot; alt=&quot;20220521171342&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后我们引入 &lt;strong&gt;问题简化&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Problem Reduction&lt;/code&gt;) 的定义:&lt;/p&gt;

&lt;p&gt;考虑任意的计算问题 $A, B$, 若 &lt;strong&gt;所有 $A$ 问题的实例都可通过某个变换 $f_{I_A}$ 映射/转换为问题 $B$ 的某个实例&lt;/strong&gt;, 则称 $A$ 可被简化为 $B$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521171517.png&quot; alt=&quot;20220521171517&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;class-p-问题的形式化定义和对问题的编码&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class P&lt;/code&gt; 问题的形式化定义和对问题的编码&lt;/h3&gt;

&lt;p&gt;我们首先说明如何对问题进行 &lt;strong&gt;统一的二进制编码表示&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Encoding&lt;/code&gt;). 然后在此基础上给出对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class P&lt;/code&gt; 类问题的 &lt;strong&gt;形式化定义&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在研究问题的可计算性时, 我们 &lt;strong&gt;只关心决策问题&lt;/strong&gt; 而非优化问题, 至少不是 &lt;strong&gt;直接关注优化问题, 而是关注它的决策问题形式&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;广义上说, 决策问题就是一个函数, 它接收一些输入, 返回一个 &lt;strong&gt;是或否&lt;/strong&gt; ($0$ 或 $1$) 的结果.&lt;/p&gt;

&lt;p&gt;并且, 我们可以从一个著名的优化问题: 旅行商问题的例子观察到:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一般来说优化问题都可以 &lt;strong&gt;等价地简化为&lt;/strong&gt; 某个决策问题.&lt;/li&gt;
  &lt;li&gt;解决决策问题一般不会比解决优化问题更难.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 在考虑优化问题的困难程度和可计算性时, 我们实际考察的是 &lt;strong&gt;它的决策问题形式&lt;/strong&gt; 的困难程度与可计算性.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521180622.png&quot; alt=&quot;20220521180622&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;问题的统一编码&quot;&gt;问题的统一编码&lt;/h4&gt;

&lt;p&gt;下面, 为了 &lt;strong&gt;横向比较&lt;/strong&gt; 所有 &lt;strong&gt;形式, 输入, 输出都不同&lt;/strong&gt; 的决策问题, 我们需要首先 &lt;strong&gt;将它们转化为相同的形式&lt;/strong&gt;, 这是通过 &lt;strong&gt;对问题的编码&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Encoding&lt;/code&gt;) 实现的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521180836.png&quot; alt=&quot;20220521180836&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们 &lt;strong&gt;假设存在某种通用方法&lt;/strong&gt;, 可以将 &lt;strong&gt;不同的数据结构统一地在多项式时间内编码为二进制序列&lt;/strong&gt;, 由此对于所有的决策问题, 它们的输入形式现在就是相同的.&lt;/p&gt;

&lt;p&gt;因此, 另一种形式上对于决策问题的不同定义是:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所有以一系列二进制数串作为输入, 输出 $1$ 或 $0$ 的函数.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而在经过转换前, 表示问题真实语义 (如下面图中对问题 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATH&lt;/code&gt; 的描述) 的描述被称为问题的 &lt;strong&gt;语言&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Language&lt;/code&gt;), 它表示被形式化后的问题的真实含义.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521181116.png&quot; alt=&quot;20220521181116&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是, 对数字 $n$ 的二进制编码长度仅为 $k = \log_{2}(n)$. 因此, 我们需要注意, 某些问题的时间复杂度可能 &lt;strong&gt;关于输入的值的增长为线性的&lt;/strong&gt;, 但 &lt;strong&gt;关于输入长度的增长则为指数级的&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;我们称满足这种特性的问题为 &lt;strong&gt;伪多项式时间的问题&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pseudo-Polynomial&lt;/code&gt;), 比如 &lt;strong&gt;最简单的素数检测算法&lt;/strong&gt;. (回顾上一章介绍的内容)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521181514.png&quot; alt=&quot;20220521181514&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;class-p-问题的形式化定义&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class P&lt;/code&gt; 问题的形式化定义&lt;/h4&gt;

&lt;p&gt;在介绍了对决策问题的统一化编码方法后, 我们下面给出对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class P&lt;/code&gt; 问题的形式化定义.&lt;/p&gt;

&lt;p&gt;首先给出 “可被确定” 的定义:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;记算法 $A$ &lt;strong&gt;接纳&lt;/strong&gt; 某个二进制串 $x$, &lt;strong&gt;当且仅当满足&lt;/strong&gt; $A(x) = 1$.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后, 对任何 &lt;strong&gt;被问题的语言 $L$ 描述的二进制串 $x$&lt;/strong&gt;, 若所有这样的 $x$ 都被 $A$ &lt;strong&gt;接纳&lt;/strong&gt;, 也就是&lt;/p&gt;

\[A(x)=1 ~~ \text{for} ~ \forall x \in L\]

    &lt;p&gt;且&lt;/p&gt;

\[A(x)=0 ~~ \text{for} ~ \forall x \notin L\]

    &lt;p&gt;则称 &lt;strong&gt;问题的语言 $L$ 被算法 $A$ 所确定&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后给出 “问题的语言 $L$ 能够在多项式时间内被确定” 的 &lt;strong&gt;形式化&lt;/strong&gt; 定义:&lt;/p&gt;

&lt;p&gt;如果存在某个 &lt;strong&gt;常数 $k$&lt;/strong&gt;, 对问题的语言 $L$ 中所描述的 &lt;strong&gt;任何&lt;/strong&gt; 二进制串 $x$, 算法 $A$ 确定 $x$ 所需要消耗时间的复杂度为 $O(n^k)$, 则称 &lt;strong&gt;该问题的语言 $L$ 能够被算法 $A$ 在多项式时间内确定&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;最后, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class P&lt;/code&gt; 就是 &lt;strong&gt;全体能够被某个算法在多项式时间内确定的问题语言 $L$ 的集合&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521182511.png&quot; alt=&quot;20220521182511&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;class-np-问题的形式化定义与-certificate-的定义&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 问题的形式化定义与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 的定义&lt;/h3&gt;

&lt;p&gt;下面对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 给出形式化定义, 并介绍能够表明问题是否位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 中的标志: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 的定义.&lt;/p&gt;

&lt;p&gt;首先从一个简单的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题: &lt;strong&gt;图的顶点包含问题&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vertex Cover Problem&lt;/code&gt;) 开始.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图的顶点包含问题&lt;/strong&gt; 要求检测我们能否找到一个不大于 $k$ 的, 而且 &lt;strong&gt;包含了图中所有在任何一条边内顶点&lt;/strong&gt; 的集合 $C$.&lt;/p&gt;

&lt;p&gt;显然, 给定这样的一个集合 $C$, 我们可通过遍历图的边集中每一条边的方式判断, 对于每一条边而言, 是否至少一个顶点位于 $C$ 中. 因此, &lt;strong&gt;判断一个候选答案是否为问题的解&lt;/strong&gt; 的时间复杂度是 $O(kn)$.&lt;/p&gt;

&lt;p&gt;但要从零开始 &lt;strong&gt;生成满足条件的一个解 $C$&lt;/strong&gt;, 在最坏情况下我们需要检查图的顶点集 $V$ 的每一个子集, 因此要检查 $2^n$ 次.&lt;/p&gt;

&lt;p&gt;显然这是一个典型的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题: 无法使用确定性算法在多项式时间内求解, 但是可以在多项式时间内验证候选答案是否为解.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521191337.png&quot; alt=&quot;20220521191337&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此处对这个问题而言, $C$ 就是它的一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;, 可被 &lt;strong&gt;简单轻松地用来检测问题是否有解&lt;/strong&gt;. 任何被归类为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 的问题都有相应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;, 也正因如此可以看到, $P \in NP$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用人话说: 任何决策问题都可写为: “给定条件xxx或取值约束yyy, 求是否存在zzz, 使得…条件满足”. 在其中, 所谓的 “问题输入 $x$” 就是给定的条件xxx或问题的取值约束yyy, 如果在问题输入给定的基础下…条件确实满足, 那肯定可以找到对应的一个zzz, 这个zzz就是所谓的, 和问题输入对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们再来考虑更复杂的问题: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k-SAT&lt;/code&gt; 问题.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k-SAT&lt;/code&gt; 问题关注的是 &lt;strong&gt;对每个子句中最多有 $k$ 个文字&lt;/strong&gt; 的合取范式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CNF&lt;/code&gt;) 的可满足性问题. (回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COMP21111&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;其中, 实际上:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 问题可互相转换, 并且它们都是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题, 而且其实它们也都是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; 的.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2-SAT&lt;/code&gt; 可在多项式时间内被求解.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521191901.png&quot; alt=&quot;20220521191901&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及其他的一些 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521192114.png&quot; alt=&quot;20220521192114&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于上述的问题而言, 它们的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 分别为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;满足条件的集合 $S$.&lt;/li&gt;
  &lt;li&gt;一系列长不超过 $k$ 的操作序列, 可被证明确实满足条件.&lt;/li&gt;
  &lt;li&gt;现成的, 不超过 $k$ 的一个序列, 可被证明确实是两个字符串的公共序列.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 我们下面给出 &lt;strong&gt;基于可在多项式时间内对问题是否有解进行验证&lt;/strong&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 的定义:&lt;/p&gt;

&lt;p&gt;对于给定问题语言 $L$, 如果存在某个 &lt;strong&gt;验证函数 $A$&lt;/strong&gt;, 该函数接受 &lt;strong&gt;输入 (如图相关问题中的给定图, 约束满足问题中的表达式, 旅行商问题中的地图和其他约束条件等)&lt;/strong&gt; $x$ 和对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; $y$ (如图相关问题中的子图或顶点子集, 约束满足问题中的一组对变量的解释, 旅行商问题中对应的一组旅行策略等), 可以在 &lt;strong&gt;多项式时间内&lt;/strong&gt; 证明在 $x$ 的条件下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 是否满足问题要求, 也就是 ($A(x, y)=1$), 则称这样的问题语言 $L$ 属于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 类.&lt;/p&gt;

&lt;p&gt;而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 就是所有满足上述条件的问题语言组成的集合.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521192758.png&quot; alt=&quot;20220521192758&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时, 我们对应给出 &lt;strong&gt;基于非确定性计算&lt;/strong&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 的定义:&lt;/p&gt;

&lt;p&gt;我们称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NP&lt;/code&gt; 是所有可以使用 &lt;strong&gt;在非确定性计算机上运行的算法&lt;/strong&gt; 在 &lt;strong&gt;多项式时间内&lt;/strong&gt; 求解的问题组成的集合.&lt;/p&gt;

&lt;p&gt;在这里, &lt;strong&gt;非确定性计算机&lt;/strong&gt; 指具有 &lt;strong&gt;可以同时执行所有可能的计算&lt;/strong&gt; 的, 理论上的计算机.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521193119.png&quot; alt=&quot;20220521193119&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意: 这两个定义是 &lt;strong&gt;等价&lt;/strong&gt; 的. 经过多项式时间的 &lt;strong&gt;非确定性计算&lt;/strong&gt;, 生成的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; 也是 &lt;strong&gt;多项式长度&lt;/strong&gt; 的.&lt;/p&gt;

&lt;p&gt;需要注意的是: 如果我们能够制造出这样的 &lt;strong&gt;非确定性计算机&lt;/strong&gt;, 则 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P=NP&lt;/code&gt;, 反之则有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P!=NP&lt;/code&gt;. 由于这样的计算机尚未建成, 但又无法证明我们确实造不出这样的计算机, 因此 &lt;strong&gt;我们尚未明确 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P=NP&lt;/code&gt; 还是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P != NP&lt;/code&gt;&lt;/strong&gt;. (相关习题里有一个与这个结论相关的, 很nasty的题. 顺带一提, 截止目前量子计算机是最接近这一定义的.)&lt;/p&gt;

&lt;h3 id=&quot;分析计算困难度时对问题实际困难程度简化的技术-reduction&quot;&gt;分析计算困难度时对问题实际困难程度简化的技术 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduction&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;我们在上一节中已经看到, 不同的问题之间存在一定的联系, 某种问题可以被转化为另外一种问题, 而且我们观察到可以互相转换的问题之间, 它们的计算困难度似乎有一定的关联. 下面我们正式介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduction&lt;/code&gt; 的概念, 介绍如何正确地定义 “某个问题必难于另一个问题”.&lt;/p&gt;

&lt;p&gt;首先在此处 &lt;strong&gt;不加证明&lt;/strong&gt; 地给出下列结论:&lt;/p&gt;

&lt;p&gt;若存在问题语言 $L_1, L_2$, 且 $L_1$ 可在 &lt;strong&gt;多项式时间内&lt;/strong&gt; 被转化为 $L_2$, 则有: $L_1$ 的计算困难度 &lt;strong&gt;不高于&lt;/strong&gt; (小于等于) $L_2$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521200952.png&quot; alt=&quot;20220521200952&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意: 此处就有结论:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$L_1$ 简单不意味着 $L_2$ 一定简单, 但 $L_1$ 难一定意味着 $L_2$ 至少不会更简单.&lt;/li&gt;
  &lt;li&gt;$L_2$ 难不意味着 $L_1$ 一定难, 但 $L_2$ 简单一定意味着 $L_1$ 至少不会更难.&lt;/li&gt;
  &lt;li&gt;偏序关系 $\leqslant_{P}$ 是具有 &lt;strong&gt;传递性&lt;/strong&gt; 的.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其次给出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Class NPC&lt;/code&gt; 的定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201202.png&quot; alt=&quot;20220521201202&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意, 任何为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPC&lt;/code&gt; 的问题语言 $L$ 必须同时满足:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$L$ 也是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 的.&lt;/li&gt;
  &lt;li&gt;$L$ 同时不比 &lt;strong&gt;其他任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt;&lt;/strong&gt; 问题简单, 也就是说 “任何其他 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题都可 &lt;strong&gt;在多项式时间内&lt;/strong&gt; 被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt;”.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;相关习题解析&quot;&gt;相关习题解析&lt;/h3&gt;

&lt;p&gt;见笔记 “数据结构与算法： 复习”&lt;/p&gt;

&lt;h2 id=&quot;大脑升级-重要-np-complete-问题一览&quot;&gt;大脑升级: 重要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; 问题一览&lt;/h2&gt;

&lt;p&gt;在本节中, 我们将简要遍历数种重要的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; 问题. 了解这部分知识的主要目的是大脑升级而非清晰明确地了解每种问题的具体细节, 毕竟基本上每个问题本身都很复杂 (以 $0-1$ 背包问题为例, 光是做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lab&lt;/code&gt; 都要做的死去活来), 讲了你也听不懂.&lt;/p&gt;

&lt;h3 id=&quot;sat-问题系列&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 问题系列&lt;/h3&gt;

&lt;p&gt;首先回顾重要的 &lt;strong&gt;约束满足问题&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt;) 家族:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521222133.png&quot; alt=&quot;20220521222133&quot; /&gt;&lt;/p&gt;

&lt;p&gt;各种约束满足问题的 &lt;strong&gt;结构特性&lt;/strong&gt; 是: 我们有由 $k$ ($k$ 不固定) 个不同变量组成的约束或表达式, 而问题的实质是: 找出对这些变量的一组赋值, 使问题结果为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;考虑下图所示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 问题, 可见该电路的表示可以通过被转化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 从而解决. 不难看出, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 的结构可用于表示多种复杂的约束关系.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521223739.png&quot; alt=&quot;20220521223739&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;图相关问题系列&quot;&gt;图相关问题系列&lt;/h3&gt;

&lt;p&gt;其次了解三种基础但重要的图相关 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; 问题:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521223837.png&quot; alt=&quot;20220521223837&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vertex Cover Problem&lt;/code&gt;: 寻找顶点集 $V$ 的子集 $C$ 使图中每一条边中的至少一个顶点都在这个子集中.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique Cover Problem&lt;/code&gt;: 寻找大小不超过 $k$ 的 &lt;strong&gt;连通子图&lt;/strong&gt; 的顶点集, 其实就是在图中寻找 &lt;strong&gt;大小不少于 $\vert V-k\vert$ 的独立集&lt;/strong&gt; 问题的镜像问题.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Graph Coloring Problem&lt;/code&gt;: 图染色, 确保任一对相联的顶点染上的颜色不同.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下面的 &lt;strong&gt;分房问题&lt;/strong&gt; 为例, 它就可以被转化为图染色问题.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521224251.png&quot; alt=&quot;20220521224251&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后是重要的 &lt;strong&gt;汉密尔顿环&lt;/strong&gt; 问题以及 &lt;strong&gt;以此作为基础衍生而来&lt;/strong&gt; 的 &lt;strong&gt;旅行商问题&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521224507.png&quot; alt=&quot;20220521224507&quot; /&gt;&lt;/p&gt;

&lt;p&gt;汉密尔顿环问题要求的是在给定图中 &lt;strong&gt;恰好不重复地遍历所有节点&lt;/strong&gt; 的子环.&lt;/p&gt;

&lt;p&gt;而旅行商问题实际上就是有权图中对子环总权重加以限制的汉米尔顿环问题.&lt;/p&gt;

&lt;p&gt;举例而言, 考虑下面的两个图, 我们可以在左边的图中找到一个不重复地遍历了图中所有顶点的圈, 而在右侧的图中这样的圈则不存在.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521224848.png&quot; alt=&quot;20220521224848&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;图中最长最短路径计算问题&quot;&gt;图中最长/最短路径计算问题&lt;/h3&gt;

&lt;p&gt;首先需要注意: &lt;strong&gt;求图中的最长路径&lt;/strong&gt; 才是标准的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; 问题, 而求图中的最短路径 &lt;strong&gt;只是一个 $P$ 问题&lt;/strong&gt; (回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dijkstra&lt;/code&gt; 算法!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521225111.png&quot; alt=&quot;20220521225111&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;背包系列问题&quot;&gt;背包系列问题&lt;/h3&gt;

&lt;p&gt;然后回顾 &lt;strong&gt;背包&lt;/strong&gt; 系列问题.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521225900.png&quot; alt=&quot;20220521225900&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先考虑我们 &lt;strong&gt;并不熟悉&lt;/strong&gt; 的 &lt;strong&gt;划分背包问题/打包问题&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bin Packaging Problem&lt;/code&gt;), 其需求是给定一系列体积不同的物体以及对背包容积的约束 &lt;strong&gt;B&lt;/strong&gt; 和分组数量的约束 $k$, 要求能否将给定的这些物体 &lt;strong&gt;恰好划分为 $k$ 组&lt;/strong&gt;, 而且要求 &lt;strong&gt;每组中的总占地体积不超过一个背包的最大容积 $B$&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;其次回顾我们非常熟悉的 $0-1$ 背包问题. 在此我们无需赘述, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lab5&lt;/code&gt; 中我们已经使用了暴力列举, 动态规划和贪心算法实现了对该问题的求解. 而此处需要注意的是: 本 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slides&lt;/code&gt; 中提到的 $0-1$ 背包问题 &lt;strong&gt;对背包封装方案的最小收益&lt;/strong&gt; 有限制: &lt;strong&gt;不得低于约束 $V$&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;进一步地, 我们再关注对 $0-1$ 背包问题的 &lt;strong&gt;等价描述&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Sum Problem&lt;/code&gt;. 此处不再对定义赘述, 直接看图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521225822.png&quot; alt=&quot;20220521225822&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;线性规划问题&quot;&gt;线性规划问题&lt;/h3&gt;

&lt;p&gt;最后考虑 &lt;strong&gt;特殊的线性规划问题&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;数章前我们已经介绍了如何使用 &lt;strong&gt;单纯形法&lt;/strong&gt; 求解一般的线性规划问题. 此处需要注意: &lt;strong&gt;整数线性规划问题&lt;/strong&gt; 是 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt;&lt;/strong&gt; 的!&lt;/p&gt;

&lt;p&gt;整数线性规划问题的定义如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521230201.png&quot; alt=&quot;20220521230201&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在系数可取值不局限于整数, 而是 &lt;strong&gt;实数&lt;/strong&gt; 时, 就是我们熟知的常规线性规划问题, 可以使用单纯形法求解.&lt;/p&gt;

&lt;h2 id=&quot;对可满足性问题的简化-reduction&quot;&gt;对可满足性问题的简化 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduction&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;下面我们讨论 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k-SAT&lt;/code&gt; 之间的 &lt;strong&gt;简化问题&lt;/strong&gt;. 我们将说明:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521230624.png&quot; alt=&quot;20220521230624&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是说, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 问题可以被简化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 问题, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 问题可被进一步地简化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 问题.&lt;/p&gt;

&lt;h3 id=&quot;从任何-np-问题向-circuit-sat-的简化&quot;&gt;从任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 的简化&lt;/h3&gt;

&lt;p&gt;下面我们说明, &lt;strong&gt;任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题都可被简化为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 问题&lt;/strong&gt;. 这一性质的推导时通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cook Levin&lt;/code&gt; 算法实现的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521231610.png&quot; alt=&quot;20220521231610&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其基本思想是: 任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题都一定有一个 &lt;strong&gt;验证函数 $V(w,c)$&lt;/strong&gt;, 其中 $w$ 为&lt;strong&gt;问题输入&lt;/strong&gt;, $c$ 为 (可能存在的) &lt;strong&gt;与输入对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而要将该问题转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 问题, 我们首先需要 &lt;strong&gt;模拟原 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP&lt;/code&gt; 问题的验证算法 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Verification Algorithm&lt;/code&gt;): $A(w, c)$&lt;/strong&gt;,&lt;/p&gt;

&lt;p&gt;然后 &lt;strong&gt;将原问题的输入 $w$ 硬编码进验证函数&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;若原问题的输入 $w$ 有对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; (也就是 $w$ 在原问题的语境下是被接受的), 则电路的输出为 $1$.&lt;/p&gt;

&lt;p&gt;若原问题的输入 $w$ 没有对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Certificate&lt;/code&gt; (也就是 $w$ 在原问题的语境下是被拒绝的), 则电路的输出为 $0$.&lt;/p&gt;

&lt;p&gt;进一步地, 还需要证明对电路的构造过程和电路本身都是 &lt;strong&gt;多项式的&lt;/strong&gt;. 这需要同时 &lt;strong&gt;限制构造电路耗费的时间&lt;/strong&gt; 和 &lt;strong&gt;限制构造出电路的大小&lt;/strong&gt;. 这部分只要知道即可, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lecturer&lt;/code&gt; 没时间讲明白.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521232927.png&quot; alt=&quot;20220521232927&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而具体的实现方式是: 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 中的逻辑门电路 &lt;strong&gt;从零开始搭建一个硬编码了验证函数 $V(w, c)$ 的计算机&lt;/strong&gt;, 它以 $w$ 作为输入, 最终输出为 $0$ 或 $1$.&lt;/p&gt;

&lt;p&gt;(丧心病狂, 在iOS 短信应用存储的 gif 图里用逻辑门搭计算机的恶意软件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pegasus&lt;/code&gt; 的开发者直呼内行….)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521233514.png&quot; alt=&quot;20220521233514&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此, 只要确保搭建计算机所需的运行时间是多项式的, 其状态的数量就是多项式的, 进一步就可说明原问题的输入也是多项式的, 它本质上所表示的问题简化 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduction&lt;/code&gt;) 也就同样是多项式的.&lt;/p&gt;

&lt;p&gt;因此, 使用这一方法我们就可证明:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521230801.png&quot; alt=&quot;20220521230801&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;从-circuit-sat-向-sat-的简化&quot;&gt;从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 的简化&lt;/h3&gt;

&lt;p&gt;下面再来看从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 的简化.&lt;/p&gt;

&lt;p&gt;显然, 将电路直接建模为布尔表达式 &lt;strong&gt;不是多项式的&lt;/strong&gt;. 要证明我们期望的结论, 因此我们需要引入新变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wire&lt;/code&gt;, 用下图所示的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tseytin Transformation&lt;/code&gt; 进行多项式的转换:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521234251.png&quot; alt=&quot;20220521234251&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Tseytin Transformation&lt;/code&gt; 将一个将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit-SAT&lt;/code&gt; 转换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 的例子如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521234443.png&quot; alt=&quot;20220521234443&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此我们就可证明结论: $\text{Circuit-SAT} \leq_{p} \text{SAT}$.&lt;/p&gt;

&lt;h3 id=&quot;从-sat-向-3-sat-的简化&quot;&gt;从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 的简化&lt;/h3&gt;

&lt;p&gt;同样, 我们需要使用一些奇技淫巧才能实现多项式时间内的转换.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521234709.png&quot; alt=&quot;20220521234709&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们需要先将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SAT&lt;/code&gt; 转换回 &lt;strong&gt;分析树&lt;/strong&gt; 型的 (抽象) 电路, 然后再从它转换到 $3-SAT$, 如下面的例子所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521234814.png&quot; alt=&quot;20220521234814&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终我们就可证明所需的结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521234545.png&quot; alt=&quot;20220521234545&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521234945.png&quot; alt=&quot;20220521234945&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;从-3-sat-向-clique-的简化&quot;&gt;从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique&lt;/code&gt; 的简化&lt;/h3&gt;

&lt;p&gt;下面我们讨论从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique&lt;/code&gt; 的简化:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique&lt;/code&gt; 问题实际上就是考察: &lt;strong&gt;给定图 $G$ 和约束 $k$, 问该图中是否存在大小为 $k$ 的连通子图&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而下面我们的目的是: 构造一个映射, 将每个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 问题映射为对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique&lt;/code&gt; 问题.&lt;/p&gt;

&lt;p&gt;基本思路是: 被构造的图 $G$ 中的节点 将被拆分为 $k$ 个 &lt;strong&gt;三元组&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Triples&lt;/code&gt;), 而每个三元组都和 &lt;strong&gt;原来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 中的一个子句对应&lt;/strong&gt;. 这样我们就得到了图 $G$ 的顶点集 $V$.&lt;/p&gt;

&lt;p&gt;而连接边 (构造图 $G$ 的边集 $E$) 的原则是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在同一个三元组中的顶点 &lt;strong&gt;永不相连&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;不连接 &lt;strong&gt;符号相同&lt;/strong&gt; 但 &lt;strong&gt;正负性质不同&lt;/strong&gt; 的顶点, 如形如 $a_1$ 和 $\neg a_1$ 的顶点就不能相互连接, 但 $a_1$ 和 $\neg b_2$ 就可相连.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;随后, 我们得到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique&lt;/code&gt; 问题就等价于原来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 问题.&lt;/p&gt;

&lt;p&gt;举例而言: 使用上述的规则转换图中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt;, 在图大小约束为 $3$ 的情况下, 显然可以在图中找到一个大小为 $3$ 的连通子图, &lt;strong&gt;将连通子图顶点对应的文字赋值设为 $1$ 就得到了原 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 的一个翻译&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522000208.png&quot; alt=&quot;20220522000208&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;对图相关问题的简化&quot;&gt;对图相关问题的简化&lt;/h3&gt;

&lt;p&gt;本节讨论我们艰难旅程的最后一步: 对图相关问题的简化.&lt;/p&gt;

&lt;p&gt;我们考虑从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VertexCover&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique&lt;/code&gt; 的简化:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522000609.png&quot; alt=&quot;20220522000609&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此处的简化目的是: 给定输入的图 $G = (V, E)$ 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cover&lt;/code&gt; 的大小 $k$, 要求输出一个在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clique&lt;/code&gt; 语境下, 大小不超过 $k’$ 的新图 $G’ = (V’, E’)$.&lt;/p&gt;

&lt;p&gt;而这个新图满足:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;$V’ = V$&lt;/li&gt;
  &lt;li&gt;$E’ = \bar{E}$, 也就是对 $E$ 在 &lt;strong&gt;全体可能边集&lt;/strong&gt; 中的 &lt;strong&gt;取反&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;$k’ = \vert V \vert -k$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此处的原理是: $G$ 只能够存在某个最多大小为 $k$ 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cover&lt;/code&gt;: $C$ $\leftrightarrow$ $E$ 中的任何一条边上的至少一个节点在 $C$ 里 $\leftrightarrow$ 只要任两个节点 $u, v \notin C$, 则 $(u, v) \notin E$ $\leftrightarrow$ $(u, v) \in \bar{E} \leftrightarrow$ 集合 $V-C$ 就是一个大小最多为 $\vert V \vert -k$ 的团.&lt;/p&gt;

&lt;p&gt;进一步考虑从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 向 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-Color&lt;/code&gt; 的简化:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522000744.png&quot; alt=&quot;20220522000744&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意此处在构造子句对应的子图时, 我们引入了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Or Gadget&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;再进一步地, 可以依次从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-SAT&lt;/code&gt; 简化到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k-SAT&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220522000838.png&quot; alt=&quot;20220522000838&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;(这里有时间再补, 没时间就算了, 记结论就行)&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;最后对我们所介绍的各种 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPC&lt;/code&gt; 问题列举总结:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Circuit-SAT&lt;/li&gt;
  &lt;li&gt;SAT&lt;/li&gt;
  &lt;li&gt;3-SAT/k-SAT with k &amp;gt;= 3&lt;/li&gt;
  &lt;li&gt;Vertex Cover: find a subset C of V so that for each edge in E at least one node is in C given the constraint on maximum size of C&lt;/li&gt;
  &lt;li&gt;Clique: inverse question on independent sets, find complete sub graph’s vertex set C with constraint on the maximum size of C.&lt;/li&gt;
  &lt;li&gt;Graph Colorng: assign color to every nodes, but each pair of neighbors cannot share the same color.&lt;/li&gt;
  &lt;li&gt;Hamiltonian Cycle: find a shortest circle in graph that connect every vertex.&lt;/li&gt;
  &lt;li&gt;Bin Packing: separate the set into k subsets where each subset’s total weight is no more than P.&lt;/li&gt;
  &lt;li&gt;0-1 knapsack: given a list of weighted items and a bag no heavier than P, find an optimal combination of items to pack into the bag so that the weight constraint does not exceed but the total value can be maximised.&lt;/li&gt;
  &lt;li&gt;Integer programming: stricter linear programming, where each variables’ value can only be integer.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;相关习题解析-1&quot;&gt;相关习题解析&lt;/h3&gt;

&lt;p&gt;见笔记 “数据结构与算法： 复习”.&lt;/p&gt;
</description>
        <pubDate>Sun, 01 May 2022 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/2022/05/01/Ch9-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/05/01/Ch9-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： 素数查找问题</title>
        <description>&lt;h1 id=&quot;素数检测问题&quot;&gt;素数检测问题&lt;/h1&gt;

&lt;p&gt;在本章中, 我们考虑 &lt;strong&gt;寻找素数&lt;/strong&gt; 的问题. 由 &lt;strong&gt;素数定理&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prime Number Theorem&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;记 $\pi(n)$ 为 &lt;strong&gt;数值小于等于 $n$ 的所有数中素数的个数&lt;/strong&gt;, 则对任意 $n$, 有:&lt;/p&gt;

\[\lim_{n \rightarrow \infty} \frac{\pi(n)}{\frac{n}{\ln(n)}} = 1.\]

&lt;p&gt;也就是说, $\frac{n}{\ln(n)}$ 给出了 &lt;strong&gt;小于等于 $n$ 的素数个数&lt;/strong&gt; 的 &lt;strong&gt;近似&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此可知, 考虑一个 &lt;strong&gt;足够大&lt;/strong&gt; 的数 $n$, 则在&lt;strong&gt;前 $n$ 个数中有&lt;/strong&gt;&lt;/p&gt;

\[\pi(n) \approx \frac{n}{\ln(n)}\]

&lt;p&gt;&lt;strong&gt;个素数&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此, 在前 $n$ 个数中 &lt;strong&gt;随机抽取一个&lt;/strong&gt;, 得到的数确实是素数的概率为&lt;/p&gt;

\[\frac{\pi(n)}{n} = \frac{1}{\ln(n)}.\]

&lt;p&gt;比如, 如果我们需要找到一个二进制位长为 $1024$ 的整数, 则需要检查 $\ln(2^{1024}) \approx 710$ 次.&lt;/p&gt;

&lt;p&gt;素数定理告诉我们, 寻找素数问题等价于 &lt;strong&gt;检测某个范围内的随机数是否为素数&lt;/strong&gt; 的问题.&lt;/p&gt;

&lt;h2 id=&quot;素数检测的基本方法与核心思想&quot;&gt;素数检测的基本方法与核心思想&lt;/h2&gt;

&lt;p&gt;下面讨论检测素数的核心思想与基本方法: &lt;strong&gt;暴力测试&lt;/strong&gt; 和 &lt;strong&gt;费马小定理&lt;/strong&gt;, 并进一步解释为何 &lt;strong&gt;伪素数的存在决定我们无法直接使用费马小定理检测素数&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;从定义出发, 素数是只被自身和 $1$ 整除的数. 并且我们知道, 考虑数 $n$, 由于检查大于 $\sqrt{n}$ 且小于 $n$ 的数是否整除 $n$ 实际上就是在检查位于 $1$ 到 $\sqrt{n}$ 之间的数能否整除 $n$, 因此有:&lt;/p&gt;

&lt;h3 id=&quot;暴力测试&quot;&gt;暴力测试&lt;/h3&gt;

&lt;p&gt;最基本的 &lt;strong&gt;暴力测试&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trial Division&lt;/code&gt;) 就是在 $1$ 到 $\sqrt{n}$ 之间的数字中挨个检查它们能否整除 $n$ (当然, 除了 $1$ 以外). 如果它们中只要有一个能整除 (当然, $1$ 例外), 就说明被测数 $n$ &lt;strong&gt;不为素数&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220509231912.png&quot; alt=&quot;20220509231912&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;费马小定理和伪素数-carmichael-number&quot;&gt;费马小定理和伪素数 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Carmichael Number&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;进一步地, 我们还知道 &lt;strong&gt;费马小定理&lt;/strong&gt; 的结论:&lt;/p&gt;

&lt;p&gt;对任意整数 $x$ 和素数 $p$, 若 $x ~\text{mod}~p \neq 0$, 则均满足&lt;/p&gt;

\[x^{p-1} ~\equiv~ 1 ~ (\text{mod} ~ p)\]

&lt;p&gt;因此看上去, 利用时间复杂度为 &lt;strong&gt;线性&lt;/strong&gt; 的 &lt;strong&gt;快速模幂算法&lt;/strong&gt; 随机挑选满足条件的整数 $x$, 测试 $x^{n-1}$ 即可检测被测数 $n$ 是否为素数.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220509232159.png&quot; alt=&quot;20220509232159&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而不幸的是, 满足费马小定理只是一个数 $n$ 为素数的 &lt;strong&gt;必要条件&lt;/strong&gt;, 一类被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Carmichael Numbers&lt;/code&gt; (伪素数) 的合数 (非素数) 同样满足费马小定理:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220509232313.png&quot; alt=&quot;20220509232313&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此, 由于伪素数的存在, 我们无法直接应用费马小定理检测某个数 $n$ 是否为素数.&lt;/p&gt;

&lt;h2 id=&quot;随机素数判定法&quot;&gt;随机素数判定法&lt;/h2&gt;

&lt;p&gt;下面介绍 &lt;strong&gt;随机素数判定法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Randomized Primality Testing&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;基于上面一小节的描述, 我们知道满足费马小定理的数 &lt;strong&gt;可能是素数, 额可能是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Carmichael&lt;/code&gt; 伪素数&lt;/strong&gt;. 由于在现实中 &lt;strong&gt;小概率事件几乎不可能发生&lt;/strong&gt;, 因此只要我们找到一种 &lt;strong&gt;出错概率可控&lt;/strong&gt; 的素数判断函数, 将 &lt;strong&gt;它的出错概率控制在足够小的水平上&lt;/strong&gt;, 那么我们就可以放心地将它应用到实践中.&lt;/p&gt;

&lt;p&gt;考虑一个这样的函数, 记为 $\text{witness}(x, n)$, 用于 &lt;strong&gt;判定一个数是否为合数&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;若 $n$ 为素数则该函数返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;若 $n$ 不为素数, 则该函数有 $q &amp;lt; 1$ 的概率也返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;称其为 &lt;strong&gt;见证函数&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511094408.png&quot; alt=&quot;20220511094408&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面结合见证函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\text{witness}()&lt;/code&gt; 介绍 &lt;strong&gt;随机素数判定法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Randomized Primality Testing Algorithm&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511133117.png&quot; alt=&quot;20220511133117&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中, $n$ 为 &lt;strong&gt;需要被检测的数&lt;/strong&gt;, $k$ 称为置信度, 表明我们希望以多高的确定率 (准确率) 进行素数判定.&lt;/p&gt;

&lt;p&gt;注意此处 $t$ 为执行随机测试的次数, 每一次测试中我们都会生成一个随机数 $x$ 作为见证函数的另一个输入.&lt;/p&gt;

&lt;p&gt;如果在所有的随机测试中 $\text{witness}(x)$ 均判定数 $n$ 为素数, 则 &lt;strong&gt;在置信度为 $k$ 的前提下, 可判定 $n$ 为一个素数&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;下面说明 $t$ 如此取值的原因.&lt;/p&gt;

&lt;p&gt;首先进一步解释 &lt;strong&gt;置信度 $k$&lt;/strong&gt;, 它实际上约束的是 &lt;strong&gt;判定函数出错的概率&lt;/strong&gt;. 判定函数出错的概率需要为&lt;/p&gt;

\[2^{-k}.\]

&lt;p&gt;而函数整体返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 的概率客观上是 $q^{t}$, 因为在这一情况下任何一次检测中见证函数都需要返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;因此目标是&lt;/p&gt;

\[q^{t} \leqslant 2^{-k}\]

&lt;p&gt;因此有&lt;/p&gt;

\[t \leqslant \log_{q}(2^{-k}) = \frac{k}{-\log_{2}(q)} = \frac{k}{\log_{2}(\frac{1}{q})}.\]

&lt;p&gt;由此计算出 $t$ 的上界. 因此我们有:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511170104.png&quot; alt=&quot;20220511170104&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rabin-miller-素数判定法&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 素数判定法&lt;/h2&gt;

&lt;p&gt;最后介绍 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 素数判定法&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 素数判定法&lt;/strong&gt; 实际上就是一种特殊的随机素数判定法. 我们首先介绍它的见证函数.&lt;/p&gt;

&lt;p&gt;回顾定义可知, 见证函数 $\text{witness}(x, n)$ 是 &lt;strong&gt;接受随机输入 $x$, 检测某个数 $n$ 是否为素数&lt;/strong&gt; 的函数, &lt;strong&gt;若 $n$ 为素数的话返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;, 否则以 $1-q$ 的概率返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此, 基本思路是基于 &lt;strong&gt;费马小定理&lt;/strong&gt;, 检查 $x^{n-1} ~\text{mod}~(n) ~\equiv~ 1$ 是否成立, 并痛苦地接受费马小定理误报 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Carmichael Number&lt;/code&gt; 伪素数为素数的特殊情况.&lt;/p&gt;

&lt;p&gt;我們同時有以下結論 (二次探測定理):&lt;/p&gt;

&lt;p&gt;若 $p$ 为素数 $x$ 為 &lt;strong&gt;任意整數&lt;/strong&gt;, 則如果有&lt;/p&gt;

\[x^2 ~\text{mod}~p~\equiv 1\]

&lt;p&gt;则&lt;/p&gt;

\[x ~\equiv~ 1 ~ \text{mod} ~p\]

&lt;p&gt;或&lt;/p&gt;

\[x ~\equiv~ -1 ~ \text{mod} ~p\]

&lt;p&gt;若 $0 &amp;lt; x &amp;lt; p$, 则解必為 $x=1$ 或 $x = p-1$.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;进一步地, 基于数分解知识可知:&lt;/p&gt;

&lt;p&gt;若 $n$ 为 &lt;strong&gt;奇数&lt;/strong&gt;, 则 $n-1$ 可表示为:&lt;/p&gt;

\[n-1 = 2^k \cdot m\]

&lt;p&gt;其中 $m$ 为某个不可再被 $2$ 分解的奇数.&lt;/p&gt;

&lt;p&gt;由于即是偶数又是素数的只有 $2$, 因此在绝大多数情况下我见证函数的检查对象只会是奇数. 故在利用费马小定理进行素数检测时, 可以将&lt;/p&gt;

\[x^{n-1} ~\text{mod}~ n\]

&lt;p&gt;表示为&lt;/p&gt;

\[x^{2^k \cdot m} ~\text{mod}~ n\]

&lt;p&gt;其中 $2^k \cdot m = n-1$,
然后我们可以依次检测数列&lt;/p&gt;

\[x^{2^k \cdot m}, x^{2^{k-1} \cdot m}, \cdots, x^{m}.\]

&lt;p&gt;若:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;若 $n$ 可能为素数&lt;/strong&gt;, 则對上述的序列中的 $x^{2i \cdot m}, i=k, k-1, …, m$ 取關於 $n$ 的餘數, &lt;strong&gt;第一個必然為 $1$&lt;/strong&gt;, 而剩下的序列中 &lt;strong&gt;第一個不為 $1$ 的數必然是 $-1$&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511222037.png&quot; alt=&quot;20220511222037&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;若 $n$ 为合数&lt;/strong&gt;, 则从 $x^{m}$ 反推, 自 $k=0$ 开始到某个 $k=t$ 为止模运算结果都不为 $\pm 1$, 而 $k &amp;gt; t$ 时模运算结果均为 $1$ 或都不为 $1$.&lt;/p&gt;

    &lt;p&gt;(換言之, 對於 $n$ 為合數的情形, 從序列開頭 $x^{2k \cdot m}$ 開始取於數, 要麼 &lt;strong&gt;一個 $1$ 都沒有&lt;/strong&gt;, 要麼是一串 $1$ 後面緊跟著第一個數不為 $-1$.)&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511222408.png&quot; alt=&quot;20220511222408&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511222427.png&quot; alt=&quot;20220511222427&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就完成了一种见证函数, 也就是 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 算法&lt;/strong&gt; 的实现.&lt;/p&gt;

&lt;p&gt;下面讨论该见证函数的错误率:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511222508.png&quot; alt=&quot;20220511222508&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也就是說, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 算法的錯誤率最多為 $\frac{1}{4}$. 因此對於給定的顯著水平 $k$, 若將 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 函數作為隨機素數判定法的 &lt;strong&gt;見證函數&lt;/strong&gt;, 則知循環次數 $t$ 為:&lt;/p&gt;

\[t = \lceil \frac{k}{\log_{2}(\frac{1}{q})} \rceil = \lceil \frac{k}{2} \rceil.\]

&lt;p&gt;最后给出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rabin-Miller&lt;/code&gt; 算法的 &lt;strong&gt;时间复杂度&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220511222709.png&quot; alt=&quot;20220511222709&quot; /&gt;&lt;/p&gt;

&lt;p&gt;該算法的時間複雜度是 $O(k \cdot \log(n)).$&lt;/p&gt;

&lt;h2 id=&quot;相关习题解析&quot;&gt;相关习题解析&lt;/h2&gt;

&lt;p&gt;见笔记 “数据结构与算法： 复习”.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Apr 2022 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/2022/04/02/Ch8-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/04/02/Ch8-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： El Gamal加密算法</title>
        <description>&lt;h1 id=&quot;el-gamal-加密算法&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 加密算法&lt;/h1&gt;

&lt;p&gt;本节简单介绍 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 加密算法的基本原则, 涉及的计算算法和操作步骤.&lt;/p&gt;

&lt;h2 id=&quot;el-gamal-加密算法的基本原则&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 加密算法的基本原则&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 算法是一种 &lt;strong&gt;公钥-私钥&lt;/strong&gt; 加密算法, 其基本思路是: 构造一个 &lt;strong&gt;从自变量计算出因变量相对容易, 但反过来给定因变量反推自变量极其困难&lt;/strong&gt; 的 &lt;strong&gt;单向函数&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而在公钥-私钥加密算法中, 我们将包含部分自变量信息, 可以用于解密的信息作为 &lt;strong&gt;私钥&lt;/strong&gt;, 只有信息接收者拥有; 而信息接收者通过使用私钥生成 &lt;strong&gt;可以加密信息但无法将密文解密&lt;/strong&gt; 的 &lt;strong&gt;公钥&lt;/strong&gt; 自由分发, &lt;strong&gt;任何人都可以使用公钥向接受者发送加密的信息&lt;/strong&gt;, 而这些信息 &lt;strong&gt;只有掌握私钥的接受者自己&lt;/strong&gt; 才能解密.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508162722.png&quot; alt=&quot;20220508162722&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 算法中, 核心的加密思想涉及下列的单向函数:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508162746.png&quot; alt=&quot;20220508162746&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在知道 $y, a, p$ 的情况下反推出 $b$ 基本是不可能的.&lt;/p&gt;

&lt;p&gt;下面介绍一些在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 算法中涉及的数论概念:&lt;/p&gt;

&lt;h3 id=&quot;模运算&quot;&gt;模运算&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508163147.png&quot; alt=&quot;20220508163147&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面给出 &lt;strong&gt;剩余系&lt;/strong&gt;, &lt;strong&gt;简化剩余系&lt;/strong&gt;, &lt;strong&gt;模逆&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Modular Inverse&lt;/code&gt;), &lt;strong&gt;生成元&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Generator&lt;/code&gt;) 和 &lt;strong&gt;原根&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Primitive Root&lt;/code&gt;) 的定义:&lt;/p&gt;

&lt;h4 id=&quot;剩余系-简化剩余系和模逆&quot;&gt;剩余系, 简化剩余系和模逆&lt;/h4&gt;

&lt;p&gt;记 $\mathbf{Z}_n$: 模 $n$ 的剩余系.&lt;/p&gt;

&lt;p&gt;同时有结论: 若 $x$ 和 $n$ 互素, 则 $x$ 在 $\mathbf{Z}_n$ 中的代表元对于 $n$ 有 &lt;strong&gt;模逆&lt;/strong&gt;, 即:&lt;/p&gt;

&lt;p&gt;存在 $x$ 在 $\mathbf{Z}_n$ 中的模逆 $x^{-1}$, 使得&lt;/p&gt;

\[x \cdot x^{-1} \equiv 1 ~ (\text{mod} n).\]

&lt;p&gt;记 $\mathbf{Z}^{*}_n$: 模 $n$ 的 &lt;strong&gt;简化剩余系&lt;/strong&gt;: 其中任何代表元 &lt;strong&gt;均和 $n$ 互素&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;故对素数 $p$, 有: $\mathbf{Z}_p = \mathbf{Z}^{*}_p$. 立即可知:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;素数的剩余系就是其简化剩余系.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;素数的剩余系中的任何代表元都关于该素数的模运算存在模逆.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;阶-生成元和原根&quot;&gt;阶, 生成元和原根&lt;/h4&gt;

&lt;p&gt;记 $m$ 为素数 $p$ 的简化剩余系中的一个代表元. 若存在 $k$, 满足&lt;/p&gt;

\[m^1 ~ \text{mod}~  p, m^2 ~ \text{mod}~  p, \cdots, m^{k} ~ \text{mod}~  p\]

&lt;p&gt;&lt;strong&gt;恰好构成了&lt;/strong&gt; 模 $p$ 的简化剩余系, 则称 $k$ 为数 $m$ 在 $p$ 的简化剩余系中的 &lt;strong&gt;阶&lt;/strong&gt;, 方便记忆可记为 “$m$ 关于 $p$ 的阶”, 你自己知道实际上表示什么含义就行.&lt;/p&gt;

&lt;p&gt;若 $m$ 关于 $p$ 的阶恰为 $p-1$ (任何素数 $p$ 的剩余系, 简化剩余系恰含 $p-1$ 个代表元), 则称 $m$ 为 &lt;strong&gt;$p$ 的简化剩余系的&lt;/strong&gt; 一个 &lt;strong&gt;生成元&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Generator&lt;/code&gt;), 或称 $m$ 为 $p$ 的一个 &lt;strong&gt;原根&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Primitive Root&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;下面给出一些关于生成元存在性的证明:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508164950.png&quot; alt=&quot;20220508164950&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以不记, 官宣不考.&lt;/p&gt;

&lt;h2 id=&quot;el-gamal-加密算法中涉及的计算算法&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 加密算法中涉及的计算算法&lt;/h2&gt;

&lt;p&gt;下面介绍一些 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 加密算法中涉及的必须计算算法. 由于大概率这些算法 &lt;strong&gt;要求记忆&lt;/strong&gt;, 请务必 &lt;strong&gt;谨慎对待&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;欧几里得算法&quot;&gt;欧几里得算法&lt;/h3&gt;

&lt;p&gt;欧几里得算法用来计算 &lt;strong&gt;两个数的最大公约数&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508171357.png&quot; alt=&quot;20220508171357&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508171411.png&quot; alt=&quot;20220508171411&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;快速欧几里得算法&quot;&gt;快速欧几里得算法&lt;/h3&gt;

&lt;p&gt;快速欧几里得算法用来计算 &lt;strong&gt;模逆&lt;/strong&gt;, 应用在 &lt;strong&gt;解密过程中&lt;/strong&gt;. (计算的是 $a^{-1} ~\text{mod}~b$, 就是返回的 $j$)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508171541.png&quot; alt=&quot;20220508171541&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508171515.png&quot; alt=&quot;20220508171515&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;快速模幂算法&quot;&gt;快速模幂算法&lt;/h3&gt;

&lt;p&gt;快速模幂算法用于给定 $p, q, x$, 计算 $q^x ~\text{mod}~ p$, 应用在 &lt;strong&gt;加密过程中&lt;/strong&gt;. (按照下图算法计算的是 $a^{p} ~\text{mod}~ n$)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508171431.png&quot; alt=&quot;20220508171431&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;el-gamal-加密算法的操作步骤&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 加密算法的操作步骤&lt;/h2&gt;

&lt;h3 id=&quot;创建公钥和私钥&quot;&gt;创建公钥和私钥&lt;/h3&gt;

&lt;h4 id=&quot;el-gamal-算法的-公钥&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 算法的 &lt;strong&gt;公钥&lt;/strong&gt;:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508165237.png&quot; alt=&quot;20220508165237&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$g$ 是 $p$ 的 &lt;strong&gt;原根&lt;/strong&gt;, 考试时会直接提供.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$x$ 是 &lt;strong&gt;$p$ 的简化剩余系中的任意元素&lt;/strong&gt;, 除此以外没有选择限制.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;el-gamal-算法的-私钥&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 算法的 &lt;strong&gt;私钥&lt;/strong&gt;:&lt;/h4&gt;

&lt;p&gt;构造公钥时, 在 $p$ 的简化剩余系中挑选的 $x$ 就是 &lt;strong&gt;只有信息接收者持有的&lt;/strong&gt; 私钥.&lt;/p&gt;

&lt;h3 id=&quot;加密&quot;&gt;加密&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;El Gamal&lt;/code&gt; 算法中的加密过程是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;信息发送者接收到广播的私钥: $(p, g, y)$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;信息发送者选择要发送的信息 $M$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;信息发送者 &lt;strong&gt;随便选择某个数 $k$&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;信息发送者发送密文:&lt;/p&gt;

\[(g^k ~\text{mod}~p, ~M\cdot y^k ~\text{mod}~p).\]
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;解密&quot;&gt;解密&lt;/h3&gt;

&lt;p&gt;记信息接收者得到的信息为&lt;/p&gt;

\[(a, b).\]

&lt;p&gt;解密步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用私钥 $x$ 计算 $a^{x} ~\text{mod}~p.$&lt;/li&gt;
  &lt;li&gt;计算 $a^{x} ~\text{mod}~p.$ 关于 $p$ 的 &lt;strong&gt;模逆&lt;/strong&gt; $r$.&lt;/li&gt;
  &lt;li&gt;计算 $b \cdot r ~\text{mod}~p$, 所得结果即为明文.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;回顾构造密文的精密之处: 站在旁观者角度我们知道这里的 $y$ 实际上就是 $g^{x} ~\text{mod}~p$. 在解密时, 解密者只需用私钥计算出 $g^{kx} ~\text{mod}~p$, 进一步算出这个数关于 $p$ 的模逆, 乘上 $M\cdot y^k ~\text{mod}~p$ 就恢复得到了被加密的明文.&lt;/p&gt;

</description>
        <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/25/Ch7-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/25/Ch7-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
      <item>
        <title>计算机图形学导论：渲染</title>
        <description>&lt;h1 id=&quot;渲染&quot;&gt;渲染&lt;/h1&gt;

&lt;p&gt;在前面依次讨论完图形管线的基本组成, 顶点和边的渲染与近似, 几何变换的表示, 曲面的表示/存储和上色, 视角的确定和投影后, 我们在本章中讨论对物体表面的渲染问题.&lt;/p&gt;

&lt;p&gt;此时, 我们所得到的是在屏幕平面上已经处于合适的视角, 清除了隐藏面的网格. 要进行渲染, 就需要结合 &lt;strong&gt;光照模型&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Illumination Model&lt;/code&gt;) 的基础上对网格表示的曲面进行 &lt;strong&gt;平滑上色&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520221515.png&quot; alt=&quot;20220520221515&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreeJS&lt;/code&gt; 中, &lt;strong&gt;光照模型和上色方式的选定&lt;/strong&gt; 被封装在声明三维物体时的 &lt;strong&gt;材质选择&lt;/strong&gt; 中:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520221611.png&quot; alt=&quot;20220520221611&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;光照&quot;&gt;光照&lt;/h2&gt;

&lt;p&gt;对光照的建模有两种常见方式: &lt;strong&gt;局部光照模型&lt;/strong&gt; 和 &lt;strong&gt;全局光照模型&lt;/strong&gt;, 其中前者只考虑由某个空间中的独立光源对模型的照射结果, 而后者在此基础上还要同时考虑 &lt;strong&gt;光线反射, 折射&lt;/strong&gt; 以及 &lt;strong&gt;物体之间相互干涉&lt;/strong&gt; 的作用.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520221902.png&quot; alt=&quot;20220520221902&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在本课程中, 我们讨论简单的 &lt;strong&gt;局部光照模型&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520221914.png&quot; alt=&quot;20220520221914&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于现实世界中的光照是极其复杂的, 我们在计算机图形学中建模光照时永远考虑的是现实情形中的 &lt;strong&gt;近似&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520222129.png&quot; alt=&quot;20220520222129&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;反射&quot;&gt;反射&lt;/h2&gt;

&lt;p&gt;举例而言, 在实际情况下 &lt;strong&gt;由于任何物体表面都不可能完全不透光&lt;/strong&gt;, 因此光线照射到物体表面时, 会 &lt;strong&gt;穿过物体表面薄薄的一层&lt;/strong&gt;, 并照射到色素粒子上, 构成一些经过干涉产生的漫反射光.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520224507.png&quot; alt=&quot;20220520224507&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此, 漫反射可以被视为 &lt;strong&gt;物体表面吸收部分波长的光&lt;/strong&gt; 并 &lt;strong&gt;将剩余的光均一辐射&lt;/strong&gt; 的结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520224623.png&quot; alt=&quot;20220520224623&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它的特征就是, 光线照射到物体表面后会向 &lt;strong&gt;所有方向&lt;/strong&gt; 传播:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520224958.png&quot; alt=&quot;20220520224958&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而镜面反射则可被视为是光在物体和空气界面交界处产生的反射.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520224700.png&quot; alt=&quot;20220520224700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在实际情况中, 镜面反射还被进一步细分出 &lt;strong&gt;完美镜面反射&lt;/strong&gt; 和 &lt;strong&gt;不完美镜面反射&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;完美镜面反射基本只在 &lt;strong&gt;理想条件下&lt;/strong&gt; 发生, 此时入射光打到 &lt;strong&gt;完全平滑&lt;/strong&gt; 的表面上, 因此被直接反射出去, 入射角和反射角恰好相等.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520225105.png&quot; alt=&quot;20220520225105&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在实际情况中, 由于任何平面总是会存在一些不规则的坑洼, 而不可能完全平滑, 因此发生的实际上是反射角度 &lt;strong&gt;有略微不同&lt;/strong&gt; 的 &lt;strong&gt;不完美镜面反射&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520225300.png&quot; alt=&quot;20220520225300&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;建模漫反射-diffuse-reflection&quot;&gt;建模漫反射 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Diffuse Reflection&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;下面我们考虑对 &lt;strong&gt;漫反射&lt;/strong&gt; 的建模. 我们同时考虑三种不同的光源: &lt;strong&gt;环境光&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ambient Illumination&lt;/code&gt;), &lt;strong&gt;无穷远的点光源&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Directional Illumination&lt;/code&gt;) 和 &lt;strong&gt;场景中的点光源&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;首先, 由于已知漫反射过程中存在对入射光的部分吸收, 我们可以近似认为在不考虑颜色的情况下, 入射光在物体表面发生漫反射后的反射光 &lt;strong&gt;光强有所降低&lt;/strong&gt;. 因此我们使用系数 $k_a$ 控制漫反射光被削弱的强度:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520230440.png&quot; alt=&quot;20220520230440&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此我们就得到了最简单的第一版局部光照模型.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520232935.png&quot; alt=&quot;20220520232935&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于在该模型中物体的每个面的漫反射系数相同 (因为材质相同), 因此得到的渲染结果中自然每个面的亮度都是相同的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520230616.png&quot; alt=&quot;20220520230616&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520230635.png&quot; alt=&quot;20220520230635&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面我们进一步考虑 &lt;strong&gt;有向光照&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Directional Lighting&lt;/code&gt;), 也就是点光源.&lt;/p&gt;

&lt;p&gt;在对点光源进行建模时, 我们可以考虑的主要参数包括:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;光照强度随距离光源远近的衰减&lt;/li&gt;
  &lt;li&gt;光线入射角随距离光源远近的变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520230949.png&quot; alt=&quot;20220520230949&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此我们可以进一步确定在不同情况下点光源照射有颜色物体后, 该物体实际表现出的颜色应该是什么.&lt;/p&gt;

&lt;p&gt;我们首先对漫反射中 &lt;strong&gt;入射角&lt;/strong&gt; 的作用进行建模.&lt;/p&gt;

&lt;p&gt;考虑下列模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520232027.png&quot; alt=&quot;20220520232027&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们希望对 &lt;strong&gt;入射光打到平面上时, 平面所接受的实际光强&lt;/strong&gt; 和 &lt;strong&gt;入射角度&lt;/strong&gt; 之间的关系建模. 此处的建模方式是直接利用漫反射中的一个结论: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lambert's Law&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520232155.png&quot; alt=&quot;20220520232155&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在入射角为 $\theta$ 时, 平面所接受的实际光照强度是 $I_p \cdot \cos(\theta)$, 这是由于光线倾斜射入平面的一段范围 $x‘$时, 实际上真正射入的光线只在 $x = x’ \cdot \cos(\theta)$ 内, 由于光线数量少了 (更科学的说法应该是光子数量, 因为实际上并不存在光线), 因此光强等比例减少. 当范围 $x$ 趋于 $0$ 时, 就得到了该定理的结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520232420.png&quot; alt=&quot;20220520232420&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时我们为 &lt;strong&gt;漫反射中从物体表面反射出的光强&lt;/strong&gt; 进行建模, 假定它受参数 $k_{d}$ 控制.&lt;/p&gt;

&lt;p&gt;由于我们知道 &lt;strong&gt;表示入射光和平面法线&lt;/strong&gt; 的 &lt;strong&gt;单位&lt;/strong&gt; 向量 $L$ 和 $N$ 点乘结果为 $L\cdot N \cdot \cos(\theta)$, 因此点光源对物体产生的漫反射光强就可表示为&lt;/p&gt;

\[I_{\text{diffuse}} = I_p \cdot k_d \cdot(N \cdot L).\]

&lt;p&gt;(因为 $N, L$ 都是单位向量, 所以 $N\cdot L = \vert N\vert  \cdot \vert L \vert \cdot \cos(\theta) = \cos(\theta)$.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520232842.png&quot; alt=&quot;20220520232842&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此我们就得到了第二版 &lt;strong&gt;由环境光和局部光照产生的漫反射&lt;/strong&gt; 组成的局部光照模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520233048.png&quot; alt=&quot;20220520233048&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而和我们的第一版模型相比, 可见在真实性上新版模型有了长足的进步.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520233125.png&quot; alt=&quot;20220520233125&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们最后考虑光强随光的传播距离而衰减的问题. 基于基本物理知识可知, 光强随传播距离的衰减关系满足:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520233216.png&quot; alt=&quot;20220520233216&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但需要注意的是, 由于 $d^2$ 变化速度太快, 因此在实际情况下分母都使用 &lt;strong&gt;二次多项式&lt;/strong&gt; 拟合, 多项式的系数被视为需要调整的超参数.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520233301.png&quot; alt=&quot;20220520233301&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此在进一步考虑点光源光强的衰减效果后, 我们得到了第三版局部光照模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220520233349.png&quot; alt=&quot;20220520233349&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;建模镜面反射-specular-reflection&quot;&gt;建模镜面反射 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Specular Reflection&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;下面我们在第三版局部光照模型的基础上考虑对镜面反射的建模.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521093540.png&quot; alt=&quot;20220521093540&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先考虑 &lt;strong&gt;不完美的镜面反射&lt;/strong&gt;. 基于现有知识, 由于不完美镜面反射由多个反射角 &lt;strong&gt;大于, 等于或小于&lt;/strong&gt; 入射角的反射光组成, 因此观察者看到的实际光强 &lt;strong&gt;和观察者的角度相关&lt;/strong&gt;, 此处我们认为其中一个影响因素是 &lt;strong&gt;观察者的观察方向和完美反射光之间形成的夹角 $\phi$&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;同时, 观察者观测到的反射光强显然还和 &lt;strong&gt;入射光强&lt;/strong&gt; 以及 &lt;strong&gt;入射光的波长&lt;/strong&gt; 相关, 因此在我们的建模中认为 &lt;strong&gt;观察者观测到的不完美反射光强&lt;/strong&gt; 和 &lt;strong&gt;观察方向与完美反射光方向之间的夹角, 入射光强和光的波长&lt;/strong&gt; 相关.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521093700.png&quot; alt=&quot;20220521093700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们首先观察观察到的光强和观察角度的影响. 我们将在不同角度上观察反射光所接收到的光强和观察角度 $\phi$ 的关系 &lt;strong&gt;使用 $\cos^{n}(\phi)$ 拟合&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521095135.png&quot; alt=&quot;20220521095135&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此有:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521095211.png&quot; alt=&quot;20220521095211&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们然后考虑光线波长的影响. 由下图可见, 实际情况是极其复杂的, 对其进行完全一致的建模基本上是一件不切实际的事情.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521095346.png&quot; alt=&quot;20220521095346&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于反射光强和入射角相关, 因此我们基于 &lt;strong&gt;菲涅尔定律&lt;/strong&gt; 对剩下的两个参数: 入射角和波长进行建模:&lt;/p&gt;

&lt;p&gt;菲涅尔定律的一个重要结论是: 任何物体都具备一个描述其 &lt;strong&gt;光线折射能力&lt;/strong&gt; 的系数 $\mu$: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Refractive Index&lt;/code&gt;. 而记 $\theta$ 为折射角, $\phi$ 为入射角, 则有:&lt;/p&gt;

\[\sin(\theta) = \frac{\sin(\phi)}{\mu}.\]

&lt;p&gt;而进一步地, 折射系数 $\mu$ 又和 &lt;strong&gt;光的波长&lt;/strong&gt; 相关.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521100650.png&quot; alt=&quot;20220521100650&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此进一步地我们就可以将 $F$ 近似为 &lt;strong&gt;镜面反射系数&lt;/strong&gt; $k_{s}$. 此时有:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521100751.png&quot; alt=&quot;20220521100751&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 $R\cdot V$ 是 &lt;strong&gt;观测方向和反射光线之间的夹角&lt;/strong&gt;. 由此我们就得到了第四版本的局部光照模型, 它同时考虑了环境光源, 点光源对物体造成的漫反射以及点光源对物体造成的镜面反射的影响.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521100928.png&quot; alt=&quot;20220521100928&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出第四版局部光照模型相比未考虑镜面反射的第三版模型更贴近真实情况.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521101010.png&quot; alt=&quot;20220521101010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后, 我们对三原色中的每个颜色通道均应用局部光照模型, 就实现了 &lt;strong&gt;颜色的引入&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521101150.png&quot; alt=&quot;20220521101150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;环境光漫反射系数 $k_a$ 和局部光漫反射系数 $k_d$ &lt;strong&gt;因颜色通道而异&lt;/strong&gt;!&lt;/li&gt;
  &lt;li&gt;镜面反射系数 $k_s$ &lt;strong&gt;不受颜色通道影响&lt;/strong&gt;!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过结合颜色, 我们就得到了第五版局部光照模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521101428.png&quot; alt=&quot;20220521101428&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在需要考虑 &lt;strong&gt;多个点光源&lt;/strong&gt; 时, 只需将点光源的作用效果 &lt;strong&gt;叠加&lt;/strong&gt; 即可:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521101457.png&quot; alt=&quot;20220521101457&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;着色&quot;&gt;着色&lt;/h2&gt;

&lt;p&gt;在得到局部光照模型后, 我们下面考虑 &lt;strong&gt;如何对网格 (物体表面) 上色&lt;/strong&gt; 的问题.&lt;/p&gt;

&lt;h3 id=&quot;flat-shading&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flat Shading&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flat Shading&lt;/code&gt; 又称 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Constant Shading&lt;/code&gt;, 在着色时, 使用 &lt;strong&gt;该面的法线&lt;/strong&gt; 结合光照模型计算颜色, 然后将这个颜色 &lt;strong&gt;应用在整个面上&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此同一个面中所有像素的颜色均相同, 我们可以明显观察到网格之间的差别.&lt;/p&gt;

&lt;p&gt;同时由于 &lt;strong&gt;马赫带效应&lt;/strong&gt;, 在人类的观察中不同颜色表面的交界 &lt;strong&gt;比实际更明显&lt;/strong&gt;, 因此可以观察到令人感到不适的割裂感.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521102939.png&quot; alt=&quot;20220521102939&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;gouraud-shading&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt; 使用 &lt;strong&gt;插值&lt;/strong&gt; 尝试 &lt;strong&gt;模糊化面法线不同的面之间颜色的区别&lt;/strong&gt;, 减少割裂感.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521103244.png&quot; alt=&quot;20220521103244&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中, 网格中每个顶点上的曲面法线实际上是 &lt;strong&gt;包含这个顶点的所有相邻面&lt;/strong&gt; 的 &lt;strong&gt;曲面法线的平均&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521103416.png&quot; alt=&quot;20220521103416&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示, 中间的顶点和五个面临接, 因此该顶点的曲面法线就是这周围五个面的曲面法线的平均.&lt;/p&gt;

&lt;p&gt;因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud&lt;/code&gt; 算法对面上每个像素颜色的近似过程就是:&lt;/p&gt;

&lt;p&gt;考虑最一般化的三角形面 (更复杂的面可以通过曲面细分表示为多个三角形面), 三个顶点处的对应曲面法线分别为 $N_A, N_B, N_C$, 基于曲面法线应用局部光照模型计算出的颜色分别为 $C_A, C_B, C_C$.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;假设平滑方向是自左向右, 首先分别关于左侧边 $AC$, 基于顶点颜色 $C_A, C_C$ 计算出该边上每个位置对应的 &lt;strong&gt;平均颜色&lt;/strong&gt; $C_{\text{left}}$ 的表达式.&lt;/li&gt;
  &lt;li&gt;其次关于右侧边 $BC$, 基于顶点颜色 $C_B, C_C$ 计算出该边上每个位置对应的 &lt;strong&gt;平均颜色&lt;/strong&gt; $C_{\text{right}}$ 的表达式.&lt;/li&gt;
  &lt;li&gt;然后 &lt;strong&gt;自左向右扫描&lt;/strong&gt;, 沿着从左向右的扫描线, 依次在线上基于该线的 $C_{\text{left}}$ 和 $C_{\text{right}}$ 对线上的颜色进行平均.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521104039.png&quot; alt=&quot;20220521104039&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt; 起到了相对良好的平滑效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521104221.png&quot; alt=&quot;20220521104221&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意到在每一条扫描线上, 颜色随着像素位置的递增变化值是 &lt;strong&gt;不变&lt;/strong&gt; 的. 因此在实际实现中, 一种性能优化方法就是: 不去分别计算每个像素点上的颜色, 而是从最左侧的颜色开始, 基于每个像素点的位置不同将对应位置上的颜色以 “base+offset” 的方式累计计算, 这样可以减少计算量.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521104500.png&quot; alt=&quot;20220521104500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt; 效率很高, 但它仍然存在两个主要问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它在一些情况下可能 &lt;strong&gt;会将镜面高光平滑掉&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;它在一些情况下可能将 &lt;strong&gt;不该被平滑的边缘平滑掉&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;phong-shading&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phong Shading&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phong Shading&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt; 的不同之处在于: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt; &lt;strong&gt;直接基于顶点的颜色&lt;/strong&gt; 对 &lt;strong&gt;颜色进行平滑&lt;/strong&gt;, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phong Shading&lt;/code&gt; &lt;strong&gt;先平滑法线向量 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Normal Vector&lt;/code&gt;)&lt;/strong&gt;, 然后再 &lt;strong&gt;基于法线向量分别计算每个像素的颜色&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521105615.png&quot; alt=&quot;20220521105615&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phong Shading&lt;/code&gt; 也被称为 &lt;strong&gt;法线向量着色&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Normal Vector Shading&lt;/code&gt;). 显然此处我们也可以类比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt;, 同样使用 “Base + Offset” 的方式计算每条扫描线上每个像素对应的法线向量, 减少计算次数.&lt;/p&gt;

&lt;p&gt;最后, 从横向对比中可以看出, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phong Shading&lt;/code&gt; 相比其他两种更简单的着色方式保留了更多应有的细节, 更加贴近真实情况.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521105600.png&quot; alt=&quot;20220521105600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得关注的是, 由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phong Shading&lt;/code&gt; 中在计算网格中每个像素的颜色时都需要基于该像素对应的法线向量代入光照模型计算颜色, 因此它相比直接对颜色进行平滑的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading&lt;/code&gt; 需要的计算量 &lt;strong&gt;明显更大&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521105834.png&quot; alt=&quot;20220521105834&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;贴图&quot;&gt;贴图&lt;/h2&gt;

&lt;p&gt;我们最后讨论 &lt;strong&gt;纹理贴图&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Texture Mapping&lt;/code&gt;) 和 &lt;strong&gt;凹凸贴图&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bump Mapping&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;纹理贴图&quot;&gt;纹理贴图&lt;/h3&gt;

&lt;p&gt;利用纹理贴图的方法主要分为两种: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Image-based&lt;/code&gt;, 将 &lt;strong&gt;表示纹理的图片直接映射到三维物体表面&lt;/strong&gt;, 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Procedural&lt;/code&gt;, 基于一定的规则 &lt;strong&gt;动态计算&lt;/strong&gt; 出物体表面对应位置的纹理.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521112518.png&quot; alt=&quot;20220521112518&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在本课程中, 我们只介绍第一种纹理贴图方法.&lt;/p&gt;

&lt;p&gt;利用纹理贴图的第一步是 &lt;strong&gt;定义纹理&lt;/strong&gt;. 在此我们简单地将表示物体纹理的图片理解为纹理贴图. 和像素一样, 纹理贴图中最小的组成单位被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Texel&lt;/code&gt; (纹素), 而我们引用纹理贴图中纹素的方式和我们引用位图中像素的方法一致, 都是通过 “建立坐标系 - 使用坐标引用” 的方式实现的. 一般地, 纹理贴图中坐标轴分别使用 $U, V$ 表示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521112840.png&quot; alt=&quot;20220521112840&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;纹理映射&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Texture Mapping&lt;/code&gt;) 就是将 &lt;strong&gt;纹理贴图映射到多边形面上&lt;/strong&gt; 的过程.&lt;/p&gt;

&lt;p&gt;考虑最简单的 “Texture-per-Polygon” 映射, 其流程就是: 基于多边形顶点坐标找到纹理贴图中的对应坐标 $T(u,v)$, 然后和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gouraud Shading/Phong Shading&lt;/code&gt; 中对颜色/法线的平滑逻辑一样, 我们可以得到每条扫描线上对应位置的纹理贴图坐标, 从而就可以对 &lt;strong&gt;多边形上每个像素&lt;/strong&gt; 绑定 &lt;strong&gt;纹理贴图中对应位置的纹素&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521113308.png&quot; alt=&quot;20220521113308&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;接缝问题&quot;&gt;接缝问题&lt;/h4&gt;

&lt;p&gt;而在现实中, 上述实现存在明显的问题. 首先如果纹理选择不当的话, 就可能在渲染结果中看到明显的 &lt;strong&gt;不一致的接缝 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Seams&lt;/code&gt;)&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521113503.png&quot; alt=&quot;20220521113503&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此 &lt;strong&gt;如果多个连续的多边形要使用同样的纹理&lt;/strong&gt;, 还需要确保纹理可以 &lt;strong&gt;无缝拼接&lt;/strong&gt;, 否则就会出现视觉上不一致的接缝.&lt;/p&gt;

&lt;h4 id=&quot;分辨率不一致问题&quot;&gt;分辨率不一致问题&lt;/h4&gt;

&lt;p&gt;此外, 在纹理贴图分辨率和多边形分辨率 &lt;strong&gt;不一致&lt;/strong&gt; 时, 为了确保合理的视觉效果就 &lt;strong&gt;不能直接进行映射&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521113718.png&quot; alt=&quot;20220521113718&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分辨率不一致的问题可以被细分为两种情况:&lt;/p&gt;

&lt;h5 id=&quot;像素分辨率大于纹理分辨率&quot;&gt;像素分辨率大于纹理分辨率&lt;/h5&gt;

&lt;p&gt;考虑像素分辨率大于纹理分辨率的情况, 原则上 &lt;strong&gt;多个不同像素就会被映射到同一个纹素上&lt;/strong&gt;. 因此我们可以选择 &lt;strong&gt;不做任何处理&lt;/strong&gt;, 也可应用 &lt;strong&gt;双线性插值过滤法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bilinear Interpolation Filtering&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521114956.png&quot; alt=&quot;20220521114956&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;无过滤&quot;&gt;无过滤&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521114037.png&quot; alt=&quot;20220521114037&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时由于纹素实际上被未经插值地直接等比例放大到更高分辨率的面上, 因此得到的结果会有明显的马赛克化, 不清晰.&lt;/p&gt;

&lt;h6 id=&quot;双线性插值过滤&quot;&gt;双线性插值过滤&lt;/h6&gt;

&lt;p&gt;在双线性插值过滤中, 每个像素的颜色实际上是 &lt;strong&gt;分数坐标&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fractional Coordinate&lt;/code&gt;) 表示下最近邻居纹素颜色的平均:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521114847.png&quot; alt=&quot;20220521114847&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时由于纹素被插值放大, 因此得到的结果会显得模糊, 但更加平滑.&lt;/p&gt;

&lt;h5 id=&quot;像素分辨率小于纹理分辨率&quot;&gt;像素分辨率小于纹理分辨率&lt;/h5&gt;

&lt;p&gt;考虑像素分辨率小于纹理分辨率的情况, 此时只有 &lt;strong&gt;一部分纹理贴图&lt;/strong&gt; 可被映射到多边形上. 如果直接映射的话, 相邻的像素就会被映射到 &lt;strong&gt;不相邻的纹素&lt;/strong&gt; 上, 导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aliasing&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521115147.png&quot; alt=&quot;20220521115147&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于此处涉及到纹理贴图的语义问题, 因此原则上没有全自动的处理方式, 合适的解决方法是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mipmap Filtering&lt;/code&gt;: 利用人眼 &lt;strong&gt;看不清远处物体细节&lt;/strong&gt; 的特征构造出一系列 &lt;strong&gt;包含信息逐渐减少&lt;/strong&gt; 的 &lt;strong&gt;尺寸不一&lt;/strong&gt; 的纹理贴图, 这样在需要将纹理贴图映射到低分辨率的多边形上时, 我们就可以直接选择分辨率一样低的贴图.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521115330.png&quot; alt=&quot;20220521115330&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(The origin of the term &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mipmap&lt;/code&gt; is an initialism of the Latin phrase multum in parvo (“much in a small space”)”)&lt;/p&gt;

&lt;p&gt;而构造这一系列不同分辨率的纹理贴图的方式就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subsampling&lt;/code&gt;, 用合适的方式令它们包含的语义和细节依次减少.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521115552.png&quot; alt=&quot;20220521115552&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而其存储空间的消耗实际上相对不多: 占用的空间只是分辨率最大的贴图 $t_0$ 的两倍.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521115701.png&quot; alt=&quot;20220521115701&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;纹理贴图的其他用处&quot;&gt;纹理贴图的其他用处&lt;/h4&gt;

&lt;p&gt;此外我们还可以使用纹理贴图构造光照效果, 保存光照信息的纹理贴图被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lightmap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521115822.png&quot; alt=&quot;20220521115822&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;凹凸贴图&quot;&gt;凹凸贴图&lt;/h3&gt;

&lt;p&gt;我们下面考虑使用凹凸贴图模拟 &lt;strong&gt;凹凸不平的表面&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;从常识来看, 光在凹凸不平的表面上的反射效果不同, 因此可以通过使用 &lt;strong&gt;凹凸贴图&lt;/strong&gt; 存储 &lt;strong&gt;对表面不同位置上法线向量的偏移&lt;/strong&gt; 使表面的法线向量 &lt;strong&gt;经过人为偏置之后和原来不同&lt;/strong&gt;, 进而在经过光照模型处理后具有 &lt;strong&gt;不一致的光照效果&lt;/strong&gt;, 产生表面凹凸不平的错觉.&lt;/p&gt;

&lt;p&gt;要影响法线向量, 最实际的方式就是构造一个由平面坐标轴方向向量 $u, v$ &lt;strong&gt;乘上对应缩放系数 $b_u, b_v$&lt;/strong&gt; 合成的偏置向量 $b_uN_u + b_vN_v$ (回顾: 贴图中的横纵坐标一般用 $u, v$ 表示, 而且此处的 $N_u, N_v$ 是单位方向向量), 使最终得到的, 经过偏置的法线向量是 &lt;strong&gt;原法线向量和偏置向量的合成&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521121618.png&quot; alt=&quot;20220521121618&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521121800.png&quot; alt=&quot;20220521121800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此我们就需要对每一个像素存储对应的偏置系数: $b_u, b_v$. 一种可行的计算方式是基于纹理贴图中 &lt;strong&gt;对应纹素颜色和其邻居颜色的差别梯度计算&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521121913.png&quot; alt=&quot;20220521121913&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521121947.png&quot; alt=&quot;20220521121947&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后总结: 在本课程中, 我们介绍了图形管线的基本结构, 基本了解了如何使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt; 对图形管线进行控制, 并详细从零开始初步分析了图形管线中 &lt;strong&gt;基本形状的表示和构造&lt;/strong&gt;, &lt;strong&gt;图形变换和视角变换&lt;/strong&gt; 的类型, 表示方式, 计算方式与合成方式, 基于 &lt;strong&gt;二维和三维平行/透视视角&lt;/strong&gt; 将三维空间映射到显示屏上的计算方法, 对 &lt;strong&gt;不同光照和反射&lt;/strong&gt; 的建模, &lt;strong&gt;不同类型纹理贴图&lt;/strong&gt; 的定义和应用, 以及 &lt;strong&gt;在此基础上对图形进行渲染&lt;/strong&gt; 的全部流程和步骤.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521122403.png&quot; alt=&quot;20220521122403&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后回顾图形管线的基本组成. 如果到此你还不能完整地回忆出图形管线的主要操作组成和图像处理流程的话, 建议你赶紧回头把前面的笔记全部看一遍, 或者选择明年重修这门课程.&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/15/Ch6-COMP27112/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/15/Ch6-COMP27112/</guid>
        
        <category>课程笔记</category>
        
        <category>计算机图形学</category>
        
        
      </item>
    
      <item>
        <title>进阶课题：并行计算和内存安全语言</title>
        <description>&lt;h1 id=&quot;进阶课题并行计算和内存安全语言&quot;&gt;进阶课题：并行计算和内存安全语言&lt;/h1&gt;

&lt;p&gt;本章将简介 &lt;strong&gt;程序语言与程序范式&lt;/strong&gt; 课程的最后一部分: 进阶课题. 我们将在这部分中首先介绍用于构造 &lt;strong&gt;智能契约 (程序被部署在网络上自动运行并通过信息传递互相交互)&lt;/strong&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt;, 并以此为契机引入一系列关于 &lt;strong&gt;并行编程&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Concurrent Programming&lt;/code&gt;) 的基本概念; 随后介绍一种较新的程序设计语言: 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 同样接近底层性能极高但内存安全的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;通过本章的学习, 我们将更深入地理解: 在现代程序设计语言中, 对资源的管理和利用愈发占据重要的位置.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504213955.png&quot; alt=&quot;20220504213955&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面首先讨论智能契约语言: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;1-solidity&quot;&gt;1. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 是一门主要用于编写智能契约的程序设计语言. 我们下面对 “智能契约” 给出定义:&lt;/p&gt;

&lt;p&gt;智能契约满足下列的四条性质:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;被部署在 &lt;strong&gt;网络&lt;/strong&gt; 上.&lt;/li&gt;
  &lt;li&gt;任何智能契约都具有 &lt;strong&gt;网络地址&lt;/strong&gt;, 并可以通过网络地址被访问.&lt;/li&gt;
  &lt;li&gt;智能契约具有 &lt;strong&gt;不同的状态&lt;/strong&gt;, 而且对于各种不同的状态都有对应的行为定义.&lt;/li&gt;
  &lt;li&gt;智能契约通过在网络上 &lt;strong&gt;发送和接受信息&lt;/strong&gt; 和外界进行信息交互.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而另外一个显著特征是: 智能契约在被部署后, 就会 &lt;strong&gt;自动地&lt;/strong&gt; 运行在计算机上.&lt;/p&gt;

&lt;h3 id=&quot;solidity-介绍&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 介绍&lt;/h3&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中, 和面向对象程序设计语言中的 &lt;strong&gt;类&lt;/strong&gt; 相对应的是 &lt;strong&gt;契约&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Contract&lt;/code&gt;), 本质上它所描述的是一个将会被部署到网络上自动运行的对象. 下面是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中契约的基本结构:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504214452.png&quot; alt=&quot;20220504214452&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出, 和类一样, 契约也可以具有大量成员变量 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Member Variables&lt;/code&gt;), 而且也有自己的 &lt;strong&gt;构造器&lt;/strong&gt;, 而契约和类之间行为差异的根源是, 契约具有 &lt;strong&gt;接收和处理外部信息&lt;/strong&gt; 的功能.&lt;/p&gt;

&lt;p&gt;我们应该近似地将契约中的每个方法和构造器都视为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Message Handler&lt;/code&gt;, 来自外部的信息可能会要求调用它们中的任一个.&lt;/p&gt;

&lt;p&gt;和其他方法不同的是, 契约中的构造器只有在 &lt;strong&gt;这个契约的对象被创建&lt;/strong&gt; 时才会被 &lt;strong&gt;这个契约的拥有者 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Owner&lt;/code&gt;)&lt;/strong&gt; 调用 &lt;strong&gt;一次&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;下面尝试在一个在线 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDE&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Remix&lt;/code&gt; 中编译和运行上图中的例子.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504215041.png&quot; alt=&quot;20220504215041&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;view&lt;/code&gt; 标记表明, 被标记的方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getCount()&lt;/code&gt; 被调用时 &lt;strong&gt;不会修改契约的当前状态&lt;/strong&gt;, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returns (uint)&lt;/code&gt; 关键字表明该方法被调用时会返回一个类型为无符号整型的数据.&lt;/p&gt;

&lt;h3 id=&quot;身份识别和不可分行为&quot;&gt;身份识别和不可分行为&lt;/h3&gt;

&lt;p&gt;契约语言需要具有 &lt;strong&gt;明确地表明下列三个对象的能力&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;信息发送者的身份.&lt;/li&gt;
  &lt;li&gt;不可再分的行为/操作/指令.&lt;/li&gt;
  &lt;li&gt;运行契约的成本和代价.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先, 由于智能契约需要具备在网络中通过发送和接受信息从而实现交互和信息传递的功能, 任何信息都需要标记它的发送者 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Message Sender&lt;/code&gt;) 是谁, 这显然是和常规的程序语言中调用函数的过程完全不一致的.&lt;/p&gt;

&lt;p&gt;其次, 由于我们同时需要考虑智能契约并行运行的可能性, 我们需要明确什么样的指令才能被视为不可再分 (&lt;strong&gt;不可以被任何同时在网络上运行的进程干扰和中断的指令&lt;/strong&gt;), 需要以原子的形态参与并行运行时的任务调度.&lt;/p&gt;

&lt;p&gt;最后, 由于智能契约运行在他人的计算机硬件上, 对系统资源 &lt;strong&gt;不具有控制权&lt;/strong&gt;, 因此我们还需要能够具有明确任何契约运行产生的成本和代价的能力. 从而使我们能够为了让契约运行恰好支付相应的代价以换取相应的计算资源.&lt;/p&gt;

&lt;h4 id=&quot;信息发送者身份的确定问题&quot;&gt;信息发送者身份的确定问题&lt;/h4&gt;

&lt;p&gt;回顾面向对象程序设计语言, 它们一般包含形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self&lt;/code&gt; 一类的, 用于指示在某个类内部的类变量或类方法的关键字. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中, 同样包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt; 关键字.&lt;/p&gt;

&lt;p&gt;但它的使用场景略有不同. 首先, 它可被用于获取 &lt;strong&gt;当前契约的余额&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address(this).balance&lt;/code&gt;, 可以进一步用于建模/构造某种意义上的 “在线交易”.&lt;/p&gt;

&lt;p&gt;同时, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 具有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg&lt;/code&gt; 关键字. 它的其中一个作用是允许我们获取信息发送者的地址: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.sender&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504220608.png&quot; alt=&quot;20220504220608&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;increment()&lt;/code&gt; 方法中我们对 &lt;strong&gt;要求调用这个方法的信息的发送者身份&lt;/strong&gt; 提出了限制: &lt;strong&gt;只有在要求调用本方法的信息的发送者是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;owner&lt;/code&gt;&lt;/strong&gt; (这通过检查地址实现) 时, 函数才会被执行, 否则 &lt;strong&gt;一旦发现要求不满足, 该方法此前执行的所有操作都会被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;revert&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;换言之, 此处的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require(msg.sender = owner)&lt;/code&gt; 实际上等同于:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;revert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而不同之处在于, 即使 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require(...)&lt;/code&gt; 在上图的例子中被放在了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;14&lt;/code&gt; 行后面, 只要条件不满足它也能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;revert&lt;/code&gt; 此前该方法执行过的所有操作.&lt;/p&gt;

&lt;h4 id=&quot;表示契约运行的成本问题&quot;&gt;表示契约运行的成本问题&lt;/h4&gt;

&lt;p&gt;在上一小节中介绍了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg&lt;/code&gt; 关键字, 它表示 &lt;strong&gt;传入契约的信息&lt;/strong&gt;. 除了使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.sender&lt;/code&gt; 获取信息发送者的身份外, 它还可被用于表示运行成本:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.gas&lt;/code&gt; 表示了这条信息所携带的, 关于处理它所需代价的补偿. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;payment for the cost of processing the message&lt;/code&gt;)&lt;/p&gt;

    &lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中, 这样的代价被称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gas&lt;/code&gt;, 单位为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wei&lt;/code&gt;.  (实际上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wei&lt;/code&gt; 是很小的单位)&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中的 &lt;strong&gt;任何一条指令&lt;/strong&gt; 都有对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gas&lt;/code&gt; 数额: 执行任何指令都会消耗相应数量的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gas&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.value&lt;/code&gt; 表示了这条信息所携带的, 用于支付契约所将提供的服务的费用. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;payment for the service&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504221933.png&quot; alt=&quot;20220504221933&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先对于方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;increment()&lt;/code&gt;, 我们定义任何调用它的信息都需要携带不少于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7 wei&lt;/code&gt; 的支付费用.&lt;/p&gt;

&lt;p&gt;其次, 对于方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waste()&lt;/code&gt;, 它被刻意设计为执行大量指令以高效地浪费 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gas&lt;/code&gt;. 如果我们限制 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gas limit&lt;/code&gt;, 则它会因为资源不足而无法执行.&lt;/p&gt;

&lt;h3 id=&quot;信息传递和并行执行相关的其他问题&quot;&gt;信息传递和并行执行相关的其他问题&lt;/h3&gt;

&lt;p&gt;本节我们讨论在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中如何向其他契约发送信息, 并进一步讨论因为契约的信息交互所可能产生的两种 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrency problem&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;信息传递-向其他契约发送信息&quot;&gt;信息传递: 向其他契约发送信息&lt;/h4&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中, 向其他契约发送信息的方式类似于面向对象程序设计语言中调用对象方法的方式:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504222856.png&quot; alt=&quot;20220504222856&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在上一节中可知, 在一些情况下还需要在发送信息时附上对目标契约服务的支付费用.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504222955.png&quot; alt=&quot;20220504222955&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;数据竞争问题-data-race&quot;&gt;数据竞争问题 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data-Race&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;我们下面简要讨论数据竞争问题. 考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223100.png&quot; alt=&quot;20220504223100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图所示的例子中, 左右两个线程 &lt;strong&gt;同时执行&lt;/strong&gt;, 并 &lt;strong&gt;同时具有&lt;/strong&gt; 对缓冲数组 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt; 的访问权限.&lt;/p&gt;

&lt;p&gt;右侧线程将会持续从外界接受输入并存到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer[indexi]&lt;/code&gt; 中, 然后更新 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indexi&lt;/code&gt; 确保它在 $0-9$ 内循环.&lt;/p&gt;

&lt;p&gt;左侧线程则会持续先用同样的方式循环更新数组指针 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indexo&lt;/code&gt;, 然后 输出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer[indexo]&lt;/code&gt; 存储的内容到外界.&lt;/p&gt;

&lt;p&gt;上述线程的问题是: &lt;strong&gt;二者的运行速度可能不同&lt;/strong&gt;. 如果右侧线程运行速度极快, 则它会先于左侧进程完成对缓冲数组 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt; 的信息更新, &lt;strong&gt;然后会覆写掉此前保存, 需要被左侧线程输出, 但还没有被输出的信息&lt;/strong&gt;, 导致信息丢失.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223700.png&quot; alt=&quot;20220504223700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的例子就是典型的 &lt;strong&gt;数据竞争问题&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;我们下面给出数据竞争问题的定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223736.png&quot; alt=&quot;20220504223736&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意在上面三点特征中, 导致问题发生的主要特征是: 不存在任何规范化信息读写顺序的机制. 如果信息读写可以被某套规则严格控制, 即使某个情况满足上面的前两点也不会发生数据竞争问题.&lt;/p&gt;

&lt;p&gt;数据竞争问题在操作系统寄存器读写, 大规模并行数据库内容读写等场景中极为常见, 一般的程序语言都通过引入各种资源锁缓解或避免问题.&lt;/p&gt;

&lt;p&gt;而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 的解决方法简单粗暴: 它彻底放弃并行性, 不允许任何契约同时执行….&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223959.png&quot; alt=&quot;20220504223959&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;重入问题-re-entrancy&quot;&gt;重入问题 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Re-entrancy&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;虽然在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中数据竞争问题不存在, 但由于智能契约语言中不可避免会出现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remote function call&lt;/code&gt;, 因此还是可能出现 &lt;strong&gt;重入问题&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504224144.png&quot; alt=&quot;20220504224144&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重入问题发生在两个函数中各自存在 &lt;strong&gt;相互调用&lt;/strong&gt; 的关系时, 基于双方函数中的逻辑以及对变量进行的操作, 可能出现包括数据不安全在内的问题.&lt;/p&gt;

&lt;h3 id=&quot;复杂并行问题&quot;&gt;复杂并行问题&lt;/h3&gt;

&lt;p&gt;下面我们暂时超出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 的范畴, 从一般的角度考虑复杂的并行问题.&lt;/p&gt;

&lt;p&gt;在本节中, “并行” 的定义是广义的: 指 &lt;strong&gt;大量计算&lt;/strong&gt; 在 &lt;strong&gt;同时执行&lt;/strong&gt; 的现象.&lt;/p&gt;

&lt;h4 id=&quot;进程和线程&quot;&gt;进程和线程&lt;/h4&gt;

&lt;p&gt;举例而言, 即使在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 中, 也可能出现 网络中 &lt;strong&gt;大量契约被同时部署&lt;/strong&gt; 的现象.&lt;/p&gt;

&lt;p&gt;但与此同时, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 使用名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Consensus Algorithm&lt;/code&gt; (共识算法) 的算法确保在任何时刻整个网络上只会有一个函数运行, 并且它还使用了一些加密技术确保任何实体都不可能违背这个顺序.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504225202.png&quot; alt=&quot;20220504225202&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但对于需要并行的其他场景而言, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 解决并行导致的问题的方法是不适用的. 我们下面介绍一些其他的解决方案: &lt;strong&gt;进程 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Process&lt;/code&gt;) 思想&lt;/strong&gt;, &lt;strong&gt;线程 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread&lt;/code&gt;) 思想&lt;/strong&gt; 或者让编译器自行优化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504225649.png&quot; alt=&quot;20220504225649&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程相比线程独立性更强, 有属于自身的, 不可被外界观测和控制的状态, 天生适合原子化 (不可再分的) 操作的实现.&lt;/li&gt;
  &lt;li&gt;线程实现存在潜在的数据竞争问题, 它们通过修改和读取表示状态的公共数据 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Public States&lt;/code&gt;) 确定数据是否可被安全读写, 避免数据竞争.&lt;/li&gt;
  &lt;li&gt;让编译器自行优化实际上是非常复杂和困难的, 而且一般编译器自动优化的结果本质上就是进程思想或线程思想的实现.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;信息传递问题&quot;&gt;信息传递问题&lt;/h4&gt;

&lt;p&gt;下面考虑和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 共通之处更多的 &lt;strong&gt;进程思想&lt;/strong&gt; 中可能出现的问题.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 通过强行确定信息的顺序让它们具有原子化的表现, 但标准的进程思想不同, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 不允许任何意义上的并行执行. 而这原本是状态私有不可被外界篡改的进程最适合执行的事.&lt;/p&gt;

&lt;p&gt;而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 选择这种实现的原因是它可以从底层确保状态安全, 通过禁止并行执行, 就彻底消除了进程间状态不一致的可能性.&lt;/p&gt;

&lt;p&gt;而为了确保信息通信的一致性, 同样有下列三种解决方案:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Remote Procedure Call&lt;/code&gt; 远程程序调用:
和调用方法类似, 信息发送者发送信息, 并在&lt;strong&gt;收到&lt;/strong&gt; 接收者 &lt;strong&gt;完成信息处理之后发送回复后&lt;/strong&gt; 继续执行程序.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Synchronous Messages&lt;/code&gt; 同步信息: 
信息发送者发送信息, 并在收到接收者 &lt;strong&gt;表明收到信息&lt;/strong&gt; 的回执后就继续执行程序, 不关心接收者是否完成了信息处理.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Asynchronous Messages&lt;/code&gt; 异步信息:
信息发送者发送信息, 然后直接继续执行程序, 既不关心信息是否送达, 也不关心信息是否被处理完成.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504230704.png&quot; alt=&quot;20220504230704&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;共享内存问题&quot;&gt;共享内存问题&lt;/h4&gt;

&lt;p&gt;下面考虑线程思想中可能出现的问题.&lt;/p&gt;

&lt;p&gt;由于线程思想中, 所有线程共用内存, 因此最直接明显的潜在问题就是数据竞争问题.&lt;/p&gt;

&lt;p&gt;而解决数据竞争问题的实质是: 如何确保对信息访问的 &lt;strong&gt;互斥&lt;/strong&gt;, 即如何避免对同一块内存的 &lt;strong&gt;同时访问&lt;/strong&gt;?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将对数据的读写操作 &lt;strong&gt;原子化&lt;/strong&gt;, 从而根除数据读写被中断导致数据污染或出现数据竞争的可能性. 这要求程序员使用特定的算法, 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Peterson's Algorithm&lt;/code&gt;, 确保数据读写的互斥性, 主要问题是低效, 而且不能确保对互斥的实现适用于所有硬件平台.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供底层的, 原子化的, 对数据的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test_and_set&lt;/code&gt; 操作&lt;/p&gt;

    &lt;p&gt;其实质是实现原子化的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test_and_set&lt;/code&gt; 方法, 实现在调用它时用 &lt;strong&gt;原子化的操作&lt;/strong&gt; 将变量值修改为新的, 同时返回旧的值.&lt;/p&gt;

    &lt;p&gt;由于实现了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test_and_set&lt;/code&gt; 方法后就可以使用比 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Peterson's Algorithm&lt;/code&gt; 简单的多的方法实现数据读写的原子化, 因此用这种方式可以一定程度上的提高效率.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接提供更高阶的同步方法, 如资源锁, 信号量等.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接为程序或函数提供同步方法: 直接定义一段代码或某个方法需要被同步 (不可被干扰), 被这样定义的程序运行时禁止其他任何并行操作.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504231551.png&quot; alt=&quot;20220504231551&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;高阶的并行问题&quot;&gt;高阶的并行问题&lt;/h4&gt;

&lt;p&gt;需要注意, 互斥 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutual Exclusion&lt;/code&gt;) 并不能防止所有的并行运行问题. 虽然它可以预防 &lt;strong&gt;特定的底层并行问题&lt;/strong&gt;, 但并不能预防其他的 &lt;strong&gt;高阶并行问题&lt;/strong&gt; 的发生, 如 &lt;strong&gt;死锁/活锁&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;(Dead lock: prevent anything to happen; Live lock: prevent useful things to happen but allow infinite number of useless things to happen)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504232747.png&quot; alt=&quot;20220504232747&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如下面的例子中所示, 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solidity&lt;/code&gt; 建模的哲学家问题就是一个死锁问题.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.4.22&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;philosopher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gotLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gotRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;happy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


    &lt;span class=&quot;n&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nright&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nright&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pickUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pickUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eatNoodles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gotRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;happy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;happy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;putDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;putDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;philosopher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;holder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pickUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;holder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;philosopher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;holder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;philosopher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;举例而言, 创建三个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;philosopher&lt;/code&gt; 契约, 每人均进行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pick left-chopstick&lt;/code&gt; 操作, 然后任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;philosopher&lt;/code&gt; 都无法再执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pick right-chopstick&lt;/code&gt; 操作, 因为任何 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;philosopher&lt;/code&gt; 的右筷子总是另一个人的左筷子, 死锁形成. 在这一情况下, 任何操作都无法被执行.&lt;/p&gt;

&lt;p&gt;在实际情况中, 我们除了考虑状态的 &lt;strong&gt;安全性质&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Safety Property&lt;/code&gt;) 外, 同时要考虑 &lt;strong&gt;生命性质&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Liveness Properties&lt;/code&gt;): 除了避免坏事发生之外, 我们还要确保好事终将发生.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504233355.png&quot; alt=&quot;20220504233355&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-rust&quot;&gt;2. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;在本节中我们将以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 为例进一步讨论 &lt;strong&gt;内存管理的基本方法&lt;/strong&gt;. 首先回顾其他程序设计语言中的内存管理策略.&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 中, &lt;strong&gt;不存在任何主动的内存管理机制&lt;/strong&gt;, 程序员需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;malloc()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free()&lt;/code&gt; 手动进行内存管理. 而显然这一机制可能会导致幽灵访问 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use after free&lt;/code&gt;) 和内存泄漏 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forget to free&lt;/code&gt;) 问题的发生.&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 中同样有对象和变量的引用 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reference&lt;/code&gt;) 机制, 解决内存管理问题的途径是引入 “垃圾回收机制”: 垃圾回收器 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Garbage Collector&lt;/code&gt;) 会自动地持续监测对程序中数据的引用, 若某个数据不再被程序中任何逻辑引用, 它就会被判定为 “垃圾” 从而被垃圾回收器自动回收.&lt;/p&gt;

&lt;p&gt;通过引入垃圾回收机制, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 避免了幽灵访问问题的发生, 也解决了潜在的内存溢出问题. 但由于垃圾回收器会持续检查引用, 因此这会带来性能损失, 导致程序运行效率下降.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505110317.png&quot; alt=&quot;20220505110317&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 的例子上可以看出, 程序运行效率与内存安全之间存在 &lt;strong&gt;权衡关系&lt;/strong&gt;, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; 中程序员通过承担确保内存安全的责任换来了高效率, 而在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 中让程序设计语言本身处理内存安全问题的代价是降低了程序运行效率.&lt;/p&gt;

&lt;p&gt;但实际上程序运行效率和内存安全之间的权衡并不是无法调和的. 从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 来看, 我们注意在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 中仍然存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NullPointerException&lt;/code&gt;, 这意味着 &lt;strong&gt;垃圾回收机制并不能从根本上解决所有的内存安全问题&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;可以注意到, 当 &lt;strong&gt;两个变量引用了相同的数据&lt;/strong&gt; (也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aliasing&lt;/code&gt;) 时, 如果其中一个变量对该内存空间中的数据进行了修改而另一个变量假设数据没有被修改, 就会出现状态上的 &lt;strong&gt;不一致性&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;注意在这里我们实际上可以把变量类比为线程.&lt;/p&gt;

&lt;p&gt;考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505111611.png&quot; alt=&quot;20220505111611&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述的代码看上去没有任何内存安全问题, 但编译执行的话结果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505111644.png&quot; alt=&quot;20220505111644&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原因在于, 在执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move(b, a)&lt;/code&gt; 方法时, 我们隐式地假定了 &lt;strong&gt;指针 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 引用的内存空间不同&lt;/strong&gt;, 但在下面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allocate_two_strings&lt;/code&gt; 定义中可以看到, 我们将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 引用的内存空间 &lt;strong&gt;设为了同一块&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505111543.png&quot; alt=&quot;20220505111543&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aliasing&lt;/code&gt; 就导致了报错提示的, 双重内存空间释放问题.&lt;/p&gt;

&lt;h3 id=&quot;rust-中的内存管理&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中的内存管理&lt;/h3&gt;

&lt;p&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 不同, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 使用一套构建在 &lt;strong&gt;编译器中&lt;/strong&gt; 的内存管理 &lt;strong&gt;规则&lt;/strong&gt; 而非机制确保诸如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aliasing&lt;/code&gt; 一样可能导致内存错误的问题永不发生.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505114145.png&quot; alt=&quot;20220505114145&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这套限制内存错误发生的约束系统称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ownership System&lt;/code&gt;. 它的细节如下:&lt;/p&gt;

&lt;h4 id=&quot;数据所有权&quot;&gt;数据所有权&lt;/h4&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中, 任何 &lt;strong&gt;引用类型的数据值&lt;/strong&gt; 都有一个 &lt;strong&gt;类型为变量&lt;/strong&gt; 的所有者 (可以近似地认为任何数据都有一个所有者, 这个所有者是变量). 进一步地, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 会确保:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;任何数据都同时 &lt;strong&gt;有且只有一个所属者&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若所属者离开了作用域 / 结束了生命周期, 则它拥有的数据占用的内存空间会被 &lt;strong&gt;自动释放&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;注意, 此处所指的, 变量的 “作用域” 是指 &lt;strong&gt;从变量被声明的那行代码到右中括号包起来的范围内&lt;/strong&gt;, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中我们可以使用中括号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{}&lt;/code&gt; 人为指定变量的作用域.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;数据的所有权会通过 &lt;strong&gt;变量赋值&lt;/strong&gt; 和 &lt;strong&gt;函数调用&lt;/strong&gt; 在变量之间发生 &lt;strong&gt;转换&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pass&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505115210.png&quot; alt=&quot;20220505115210&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;数据所有权租赁&quot;&gt;数据所有权租赁&lt;/h4&gt;

&lt;p&gt;进一步地, 为了避免频繁的在变量之间迁移数据的所属权, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 引入了 &lt;strong&gt;所属权租赁&lt;/strong&gt; 机制.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505115804.png&quot; alt=&quot;20220505115804&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;基本数据类型和数据可变性-mutability&quot;&gt;基本数据类型和数据可变性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutability&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;在上面的小节中我们提到过, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中只需关注 &lt;strong&gt;引用类型&lt;/strong&gt; 数据的所属权问题. 对形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u32&lt;/code&gt; ($32$ 位无符号整数) 一类的 &lt;strong&gt;基本数据类型&lt;/strong&gt;, 我们无须关注它们数据的所属权, 因为这些基础数据类型在变量赋值时是被直接 &lt;strong&gt;复制而非引用&lt;/strong&gt; 的, 因此无需关心 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aliasing&lt;/code&gt; 问题.&lt;/p&gt;

&lt;p&gt;但是需要注意的是: 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中, &lt;strong&gt;除非我们明确地声明它是可变的&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutable&lt;/code&gt;), 任何变量都是默认 &lt;strong&gt;不可变&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Immutable&lt;/code&gt;) 的. 这一规则不同于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ownership System&lt;/code&gt; 作用域仅限于引用数据类型, 它的应用范围是 &lt;strong&gt;全体数据类型&lt;/strong&gt; (引用数据类型和基本数据类型).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505154152.png&quot; alt=&quot;20220505154152&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如下面的例子所示: 由于 $10$ 是基础数据类型, 因此第 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt; 行的操作不会导致 $10$ 的所属权从 $i$ 变为 $j$ 导致 $i$ 无法被输出; 而由于我们在定义变量时 &lt;strong&gt;没有明确说明它们是否可变&lt;/strong&gt;, 编译器就默认声明的变量 $i$, $j$ 都是 &lt;strong&gt;不可变&lt;/strong&gt; 的, 因此尝试修改 $i$ 的值时报错.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505153950.png&quot; alt=&quot;20220505153950&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;与数据可变性和数据所有权租赁相关的问题&quot;&gt;与数据可变性和数据所有权租赁相关的问题&lt;/h4&gt;

&lt;p&gt;由于声明变量类型为 &lt;strong&gt;可变&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutable&lt;/code&gt;) 会导致变量数据可以发生变化 (换言之, 变量数据可以被修改), 而租赁变量的所属权又可能允许同一个变量的数据被多个访问对象访问和修改.&lt;/p&gt;

&lt;p&gt;因此考虑多个变量同时租赁同一个可变的数值数据的情况, &lt;strong&gt;将可变数据的所属权租赁&lt;/strong&gt; 看上去可能会带来和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aliasing&lt;/code&gt; 类似的问题.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 对这一潜在问题的解决方法是: &lt;strong&gt;任何情况下&lt;/strong&gt;, 在租赁某个数据值的所有权时都需要 &lt;strong&gt;明确声明以可变 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutable&lt;/code&gt;) 还是不可变 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Immutable&lt;/code&gt;) 的方式租赁所有权&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;随后, 若声明了将以 &lt;strong&gt;可变形式租赁所有权&lt;/strong&gt;, 则 &lt;strong&gt;该对象只能租赁数据所有权一次&lt;/strong&gt;, 否则将被允许以 &lt;strong&gt;不可变形式租赁所有权无数次&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505154920.png&quot; alt=&quot;20220505154920&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意此处的 “租赁一次” 并不是严格意义上的, 只要在租赁开始和租赁的数据最后一次被使用之间的时间段中, 对租赁的数据进行的任何使用都被视为 “同一次”.&lt;/p&gt;

&lt;p&gt;考虑下面的例子, 说明 &lt;strong&gt;在一个可变租赁内部进行对同一个数据的不可变租赁是不可行的&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505204556.png&quot; alt=&quot;20220505204556&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于字符串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; 被声明为可变, 因此我们可以对该变量所有的数据进行修改, 程序编译运行正常.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505205232.png&quot; alt=&quot;20220505205232&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们定义一个 &lt;strong&gt;可变的变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;&lt;/strong&gt;, 并让它以 &lt;strong&gt;可变的方式租赁变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; 所拥有的数据的所有权&lt;/strong&gt;. 根据 “同一次” 的定义, 在第 $6$ 行对这个租赁的声明开始, 到第 $13$ 行租赁的数据内容最后一次被使用为止这个租赁都是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;active&lt;/code&gt; 的, 而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;active&lt;/code&gt; 的可变形式租赁所借用的内容则不能被其他任何对象所访问, 因此第 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;12&lt;/code&gt; 行提示报错.&lt;/p&gt;

&lt;p&gt;下面尝试在一个不可变租赁内部对同一个数据进行可变租赁:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505205556.png&quot; alt=&quot;20220505205556&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时我们在第 $6$ 行声明了一个对变量 $s$ 的数据的 &lt;strong&gt;不可变租赁&lt;/strong&gt;: 这意味着暂时借到了数据所有权的变量 $x$ 只具有对数据的 &lt;strong&gt;访问权限&lt;/strong&gt; 而 &lt;strong&gt;不具备修改权限&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;基于租赁 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;active&lt;/code&gt; 的定义可知, 上图中高亮段恰为这个不可变租赁的激活范围, 而右侧报错指明, 无法在这个不可变租赁内部对同一个数据进行可变租赁 (第 $10$ 行).&lt;/p&gt;

&lt;p&gt;由此可知, 在执行可变租赁时, 我们可以安全地确保 &lt;strong&gt;只要此次租赁仍在激活范围内&lt;/strong&gt;, 租赁数据所有权的变量就 &lt;strong&gt;恰为唯一具备对该数据修改权限的变量&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;rust-中租赁的生命周期&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中租赁的生命周期&lt;/h3&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中, 租赁的生命周期恰为它的 &lt;strong&gt;激活范围&lt;/strong&gt;. 考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505211550.png&quot; alt=&quot;20220505211550&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中, 我们使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;字母&lt;/code&gt; 的方式表示生命周期. 在上图所示的例子中, 对 $s$ 的不可变租赁的生命周期为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'m&lt;/code&gt;, 而对 $s$ 的可变租赁的生命周期为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'n&lt;/code&gt;, 由于在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中, 可变租赁的生命周期 &lt;strong&gt;不能和其他任何租赁同数据的生命周期重合&lt;/strong&gt;: &lt;a href=&quot;https://stackoverflow.com/questions/60611296/why-can-i-use-a-mutable-variable-such-that-its-lifetime-overlaps-with-an-immutab&quot;&gt;“Mutable borrows are exclusive, though – a variable that is mutably borrowed can’t be used in any other way during the lifetime of the borrow.”&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;以及&lt;a href=&quot;https://stackoverflow.com/questions/57620041/how-does-lifetime-rule-stops-multiple-mutable-borrow&quot;&gt;另一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack Overflow&lt;/code&gt; 上的例子&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解决方法是避免可变租赁的生命周期和其他租赁的生命周期重合:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505212158.png&quot; alt=&quot;20220505212158&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面考虑更复杂的例子:&lt;/p&gt;

&lt;p&gt;回忆在介绍变量的生命周期时我们提到过, 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中我们可以使用中括号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{}&lt;/code&gt; 人为地构造代码段的域 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scope&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505212529.png&quot; alt=&quot;20220505212529&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 被定义为一个长为 $2$ 的数组, 并且定义了 &lt;strong&gt;类型为对某个数组类型数据的引用的变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/strong&gt;, 注意 &lt;strong&gt;$x$ 是且只能是引用&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;不同之处在于, 从第 $6$ 行到第 $11$ 行之间的代码段被中括号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{}&lt;/code&gt; 隔离在了一个 &lt;strong&gt;单独的作用域中&lt;/strong&gt;, 在作用域中我们额外定义了长为 $3$ 的数组 $b$, 以及另一个数组引用类型的变量 $y$, 并在第 $9$ 行应用了语法糖让 $x, y$ 分别 &lt;strong&gt;不可变地&lt;/strong&gt; 借用了变量 $a$, $b$ 数据的所有权.&lt;/p&gt;

&lt;p&gt;需要注意, 由于变量在脱离作用域后就会被回收, 因此在第 $12$ 行及以后的范围内 $y$ 和 $b$ 的内存空间都是被回收的, 但在域内执行的赋值操作仍然有效, 因此我们可以正常地在第 $13$ 行执行输出, 因为 $x$ 所引用的数据仍然在作用域内.&lt;/p&gt;

&lt;p&gt;而若我们让 $x$ 借用数组 $b$ 的数据, 则会出现问题, 因为在 $13$ 行执行 $x$ 借用数据的输出时, $x$ 所借用的数据已经脱离了它的作用域而被回收.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505213108.png&quot; alt=&quot;20220505213108&quot; /&gt;、&lt;/p&gt;

&lt;p&gt;在上面例子的基础上, 我们考虑是否可以通过将引用内容藏在函数中对换从而骗过编译器摆他一道, 让本不该出现在作用域外的数据逃出作用域:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505213833.png&quot; alt=&quot;20220505213833&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中, 编译器会直接报错: 要求我们为作为函数参数的每一个引用类型的变量都提供明确的生命周期.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505213925.png&quot; alt=&quot;20220505213925&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于此前我们对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中生命周期表示法的介绍, 我们做了如上图所示的修改. 但由于我们将作为函数输入的两个引用 &lt;strong&gt;在函数定义中对换了一遍&lt;/strong&gt;, 而在函数逻辑中 &lt;strong&gt;又对换了一遍&lt;/strong&gt;, 负负得正毫无变化, 属于是被编译器摆了一道.&lt;/p&gt;

&lt;p&gt;由此可知:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220505214143.png&quot; alt=&quot;20220505214143&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/15/Ch4-COMP26020/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/15/Ch4-COMP26020/</guid>
        
        <category>课程笔记</category>
        
        <category>并行计算</category>
        
        
      </item>
    
      <item>
        <title>编译器引论</title>
        <description>&lt;h1 id=&quot;编译器引论&quot;&gt;编译器引论&lt;/h1&gt;

&lt;p&gt;任何使用程序设计语言编写的计算机程序在被实际执行前都必须 &lt;strong&gt;转译为机器语言&lt;/strong&gt;, 而负责这一转译过程的软件系统就是 &lt;strong&gt;编译器&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Compiler&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;在本章中, 我们将简要介绍 &lt;strong&gt;编译&lt;/strong&gt; 流程的基本原理和技术, 并简单讨论在构造编译器时可能遇到的一些常见问题.&lt;/p&gt;

&lt;h2 id=&quot;1-绪论&quot;&gt;1. 绪论&lt;/h2&gt;

&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;我们首先为 &lt;strong&gt;编译器&lt;/strong&gt; 的概念给出形式化的定义.&lt;/p&gt;

&lt;p&gt;一种说法是, 任何接收一种一段程序字段作为输入, 并以另一种语言的程序字段作为输出, 且输入和输出的含义保持一致的程序就被称为 &lt;strong&gt;编译器&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;我们也可认为, 任何读入用一种语言编写的程序, 并将其翻译为另一种语言下的等价形式的程序也是 &lt;strong&gt;编译器&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;解释器&lt;/strong&gt; 的概念为: 任何读入一段 &lt;strong&gt;源程序&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Source Program&lt;/code&gt;) 并产出 &lt;strong&gt;执行这段源程序的结果&lt;/strong&gt; 的程序.&lt;/p&gt;

&lt;p&gt;必须使用 &lt;strong&gt;编译器&lt;/strong&gt; 才能生成可被直接运行的可执行文件的程序设计语言被称为 &lt;strong&gt;编译型语言&lt;/strong&gt;, 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C/C#/C++&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LaTeX&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;而无需编译可被解释器直接运行的语言称为 &lt;strong&gt;解释型语言&lt;/strong&gt;, 如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python, PHP, JavaScript&lt;/code&gt; 等.&lt;/p&gt;

&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;

&lt;p&gt;编译器作为衔接两种不同语言之间的桥梁, 其最基础的功能就是 &lt;strong&gt;在翻译过程中确保程序所含的语义 (意义) 保持不变&lt;/strong&gt;. 而在实际情况中, 编译器往往还承担了对源代码进行 (各种意义上的) 优化的功能, 如:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提升编译后的程序的运行速度&lt;/li&gt;
  &lt;li&gt;减少编译后的程序的占用空间&lt;/li&gt;
  &lt;li&gt;向用户提供有价值的反馈和信息&lt;/li&gt;
  &lt;li&gt;在编译失败时能够返回便于调试的错误信息&lt;/li&gt;
  &lt;li&gt;以较高的效率编译源码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而一般地, 我们认为优秀的编译器至少需要具备下列的其中一些特质:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314213639.png&quot; alt=&quot;20220314213639&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上, 编译技术的应用场景不仅局限在对程序设计语言的转换上. 它还可用于优化计算机机构, 实现自动的并行式计算, 提升软件安全性等.&lt;/p&gt;

&lt;h3 id=&quot;基本结构&quot;&gt;基本结构&lt;/h3&gt;

&lt;p&gt;下面我们考虑编译器的基本结构.&lt;/p&gt;

&lt;p&gt;我们在上面的介绍中已经知道, 编译器以 &lt;strong&gt;源代码&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Source Code&lt;/code&gt;) 作为输入, 将其转换输出 &lt;strong&gt;目标代码&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object Code&lt;/code&gt;). 因此, 正常工作的编译器需要具备的最基础性质是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;生成的目标代码必须是正确的, 保持源代码的语义不变.&lt;/li&gt;
  &lt;li&gt;必须具备识别源代码中错误的能力.&lt;/li&gt;
  &lt;li&gt;必须具备对源代码进行分析与合成目标代码的能力.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进一步地, 编译器内部又被划分为 &lt;strong&gt;前端&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Front-End&lt;/code&gt;) 以及 &lt;strong&gt;后端&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Back-End&lt;/code&gt;) 两个部分, 前端 &lt;strong&gt;输入源代码, 输出中间表示&lt;/strong&gt;, 而后端以 &lt;strong&gt;中间表示作为输入, 输出目标代码&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt; 负责对源代码进行 &lt;strong&gt;分析&lt;/strong&gt;, 源代码的合法性和可能存在的错误需要在这一阶段中被识别并反馈; 同时, 前端需要 “理解” 并收集源代码蕴含的语义, 并由此生成代码的 &lt;strong&gt;中间表示&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt; 负责对目标代码的 &lt;strong&gt;合成&lt;/strong&gt;: 在这一阶段中, 后端将对中间表示中每一行指令和运算选择合适的指令, 并由此将中间表示翻译为目标语言.&lt;/p&gt;

&lt;p&gt;需要注意, 前端涉及的大部分操作都可以被 &lt;strong&gt;自动化&lt;/strong&gt;, 因此对常见的编译器而言执行前端操作的时间复杂度为 $O(n)$ 级别, 而后端所需要处理的问题则为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NP-Complete&lt;/code&gt; (要想确保完全解决这类问题需要至少指数级别的时间复杂度) 的.&lt;/p&gt;

&lt;p&gt;编译器中 &lt;strong&gt;前后端分离&lt;/strong&gt; 的架构便于编译器的 &lt;strong&gt;模块化&lt;/strong&gt;, 它允许我们将 &lt;strong&gt;能够生成或处理相同类型的中间表示的&lt;/strong&gt;, 针对不同语言的前后端进行 &lt;strong&gt;拼接&lt;/strong&gt;, 从而构造出可以编译不同语言, 适配不同平台的编译器.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215002.png&quot; alt=&quot;20220314215002&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;前端结构&quot;&gt;前端结构&lt;/h3&gt;

&lt;p&gt;我们下面讨论编译器前端的基本结构.&lt;/p&gt;

&lt;p&gt;编译器前端一般由 &lt;strong&gt;词法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexical Analysis&lt;/code&gt;), &lt;strong&gt;语法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Syntax Analysis&lt;/code&gt;), &lt;strong&gt;语义分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semantic Analysis&lt;/code&gt;) 和 &lt;strong&gt;中间表示生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intemediate Code Generation&lt;/code&gt;) 四个部分组成.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215256.png&quot; alt=&quot;20220314215256&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先考虑 &lt;strong&gt;词法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexical Analysis&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scanning&lt;/code&gt;). 在这一步中, 编译器前端需要:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;扫描, 读入源代码的字符&lt;/strong&gt;, 并将其 &lt;strong&gt;分组为词汇&lt;/strong&gt; 形成有意义的 &lt;strong&gt;词素序列&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexeme&lt;/code&gt;).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成词汇, 并分析不同词汇的 &lt;strong&gt;类型&lt;/strong&gt;, 生成将要传递到下一步中进行语法分析的 &lt;strong&gt;词法单元&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;). 其形式一般为&lt;/p&gt;

\[\text{&amp;lt;type, lexeme&amp;gt;}\]

    &lt;p&gt;或&lt;/p&gt;

\[\text{&amp;lt;token\_class, attribute&amp;gt;}\]
  &lt;/li&gt;
  &lt;li&gt;此外, 在生成词法单元时, 词法分析器还需要维护 &lt;strong&gt;符号表&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Symbol Table&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;在词法分析中, 空格, 注释等和程序逻辑无关的内容都会被过滤.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其次考虑 &lt;strong&gt;语法分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Syntax Analysis&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parsing&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;在语法分析这一步中, 第一步中生成的各词法单元将被 &lt;strong&gt;解析&lt;/strong&gt;, 从而生成 &lt;strong&gt;树状的中间表示&lt;/strong&gt;, 常用的就是 &lt;strong&gt;语法树&lt;/strong&gt;. 树状的语法结构将被用于编译器的后续步骤来分析源程序并生成目标程序.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220308.png&quot; alt=&quot;20220314220308&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般地, 生成树还会被进一步通过删去多余的信息被简化为 &lt;strong&gt;抽象语法树&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abstract Syntax Tree&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AST&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220818.png&quot; alt=&quot;20220314220818&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后考虑 &lt;strong&gt;语义分析&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semantic Analysis&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context Handling&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;语义分析由 &lt;strong&gt;语义分析器&lt;/strong&gt; 完成, 负责收集语义信息, 检查语义错误, 如类型检查, 检测变量是否被合法地声明, 进行变量与函数的命名检查等. 它还将使用语法树和符号表中的信息检查源程序是否和源语言定义的语义一致.&lt;/p&gt;

&lt;p&gt;此外, 语义分析器也会收集 &lt;strong&gt;类型信息&lt;/strong&gt;, 并将这些信息放在语法树或符号表中.&lt;/p&gt;

&lt;p&gt;语义分析器最重要的功能是 &lt;strong&gt;类型检查&lt;/strong&gt;: 检测每个运算符 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operator&lt;/code&gt;) 是否具有 &lt;strong&gt;匹配的运算分量&lt;/strong&gt;, 若目标语言要求某个数组的下标必须是整数, 则若用浮点数作为下标的时候编译器就会将这种操作认定为类型错误.&lt;/p&gt;

&lt;p&gt;最后考虑 &lt;strong&gt;中间表示生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intemediate Code Generation&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;编译器会在完成源代码的词法分析, 语法分析和语义分析后生成一个 &lt;strong&gt;明确的, 类机器语言的中间表示&lt;/strong&gt;. 本质上, 中间表示是一种对源代码的抽象, 合格的中间表示必须是便于生成且便于翻译的, 常用的中间表示形式是 &lt;strong&gt;三地址指令&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Three-Address Instruction&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;后端结构&quot;&gt;后端结构&lt;/h3&gt;

&lt;p&gt;继续讨论编译器的后端结构.&lt;/p&gt;

&lt;p&gt;编译器后端一般由 &lt;strong&gt;中间表示优化&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Intermediate Code Optimisation&lt;/code&gt;), &lt;strong&gt;代码生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Code Generation&lt;/code&gt;), &lt;strong&gt;目标代码优化&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target Code Optimisation&lt;/code&gt;) 和 &lt;strong&gt;目标代码生成&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target Code Generation&lt;/code&gt;) 构成.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314221932.png&quot; alt=&quot;20220314221932&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先讨论 &lt;strong&gt;中间代码优化&lt;/strong&gt;. 在这一步中, 编译器后端会尝试基于预先给定的目标 (如生成能耗更低/更短/更快的代码) 对传入的中间代码进行优化.&lt;/p&gt;

&lt;p&gt;而在后续的步骤中, 需要以经过优化的中间代码作为输入, 并将其映射为目标语言. 若目标语言是机器语言, 还需要在这一步中 &lt;strong&gt;选择合适的机器指令, 为每个变量分配寄存器或指定内存位置&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314222308.png&quot; alt=&quot;20220314222308&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503223953.png&quot; alt=&quot;20220503223953&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224004.png&quot; alt=&quot;20220503224004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224023.png&quot; alt=&quot;20220503224023&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-词法分析-lexical-analysis&quot;&gt;2. 词法分析 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lexical Analysis&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;在本节中, 我们讨论词法分析步骤中的基本原理.&lt;/p&gt;

&lt;p&gt;回顾定义, 词法分析是读入程序源码并将其转换为一系列词素 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;) 的过程.&lt;/p&gt;

&lt;p&gt;为了避免人工编码复杂的词法分析器, 简化程序语言的语法定义和实现, 词法分析器对编译器而言至关重要.&lt;/p&gt;

&lt;p&gt;为了便于后续的解释, 此处引入一系列定义:&lt;/p&gt;

&lt;h3 id=&quot;基本定义&quot;&gt;基本定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;定义 2.1&lt;/strong&gt; (单词表, 字符串, 语言和语法)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;称由一系列不同符号组成的集合为单词表.&lt;/li&gt;
    &lt;li&gt;称由一系列单词表中的符号组成的有序队列为字符串.&lt;/li&gt;
    &lt;li&gt;称由所有定义在某个单词表上的字符串组成的集合为语言.&lt;/li&gt;
    &lt;li&gt;称任何一种有限的, 表示语言的方式为语法.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;定义 2.2&lt;/strong&gt; (上下文无关语法, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context-Free Grammar&lt;/code&gt;)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;记上下文无关语法 $G$ 为四元组&lt;/p&gt;

\[G = (S, N, T, P):\]

  &lt;ol&gt;
    &lt;li&gt;$S$: 起始符号 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Starting Symbol&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;$N$: 非终止符号 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Non-Terminal Symbol&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;$T$: 终止符号 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Terminal Symbol&lt;/code&gt;)&lt;/li&gt;
    &lt;li&gt;$P$: 生成规则&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此我们也可将语言定义为由某个上下文无关语法生成的所有终止的字符串组成的集合. 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222240.png&quot; alt=&quot;20220429222240&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一般情况下非终止符号均用大写字母表示.&lt;/li&gt;
  &lt;li&gt;上面的例子中使用的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LeftMost Derivation&lt;/code&gt;: 基于规则从左到右逐步构建字符串.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上下文无关语法对于词法分析至关重要. 使用恰当的表示方法, 我们即可利用上下文无关语法高度的结构性和过程性对程序语言的语法进行编码. 下面简介其中一种恰当的表示法: &lt;strong&gt;正则表达式&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;正则表达式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Regular Expression&lt;/code&gt;) 用于表示正则语言, 我们可以使用正则表达式表示无穷种字符串.&lt;/p&gt;

&lt;p&gt;正则表达式的基本语法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222758.png&quot; alt=&quot;20220429222758&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意, 正则表达式的基础语法恰为前三条, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shorthands&lt;/code&gt; 实为对前三条规则的简化封装, 类似语法糖.&lt;/p&gt;

&lt;p&gt;虽然 &lt;strong&gt;正则表达式无法用于表示所有语言&lt;/strong&gt;, 但它足够解决绝大多数的问题. 下面给出正则表达式表示整数, 浮点型和变量名的例子. 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt; 表达式的例子中, 我们使用正则表达式分别用常规方式和科学技术法表示了浮点型数字.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222904.png&quot; alt=&quot;20220429222904&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上文所述, 理论上我们完全可以将词法分析规则硬编码, 但这样做会极大降低分析器的可扩展性, 难以修改, 且工作量巨大. 正则表达式恰可以 &lt;strong&gt;自动化词法分析的过程&lt;/strong&gt;, 极大地简化我们在构造词法分析器时的工作.&lt;/p&gt;

&lt;p&gt;如下图所示, 正则表达式实际上可以被表示为状态转换图.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223259.png&quot; alt=&quot;20220429223259&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中的转换图可以被相应地 &lt;strong&gt;等价表示&lt;/strong&gt; 为下列的转换表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223347.png&quot; alt=&quot;20220429223347&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在转换表中, 第一列表示当前状态的编号, 第二列表示在当前状态下接受不同输入将会导致状态转换 (切换, 更新) 到什么新的状态上, 如在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state0&lt;/code&gt; 时, 若输入为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; 则所处状态将转换到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state1&lt;/code&gt;, 而任何其他输入都无法让当前状态转换.&lt;/p&gt;

&lt;p&gt;进一步地, 在将正则表达式所表示的状态转换图转化为状态转换表后, 我们就可以通过在词法分析逻辑中查询和调用状态转换表, 明显地优化性能.&lt;/p&gt;

&lt;p&gt;需要注意的是, 能够被利用的状态转换表必须是 &lt;strong&gt;确定性&lt;/strong&gt; 的, 也就是在任何状态下, 给定任何输入, 其状态转换效果必须唯一. 我们下面对不同类型的状态转换图, 转换表和状态机进行讨论.&lt;/p&gt;

&lt;h3 id=&quot;nfa-dfa-和转换与简化&quot;&gt;NFA, DFA 和转换与简化&lt;/h3&gt;

&lt;p&gt;在介绍各种状态机前, 我们首先明确它们在构建词法分析器的步骤中起到的作用:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223851.png&quot; alt=&quot;20220429223851&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们首先使用正则表达式编码程序设计语言的语法规则, 并通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thompson's Construction&lt;/code&gt; 先将其转换为非确定性有穷状态机, 再使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 将其转换为未经精简的确定性有穷状态机, 最后使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hopecroft's Algorithm&lt;/code&gt; 将其精简的方式得到可供特定的词法分析器生成工具作为输入的, 精简的确定性有穷状态机.&lt;/p&gt;

&lt;p&gt;首先回顾确定性有穷状态机 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt;) 和非确定性有穷状态机 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt;) 的定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223741.png&quot; alt=&quot;20220429223741&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;正则表达式到-nfa-的转换&quot;&gt;正则表达式到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 的转换&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thompson‘s Construction&lt;/code&gt; 的构造规则如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224213.png&quot; alt=&quot;20220429224213&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以使用这些表示正则表达式基本元素的中间件构造复杂的非确定性有穷状态机, 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224253.png&quot; alt=&quot;20220429224253&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;nfa-到-dfa-的转换&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的转换&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 的核心逻辑由两个操作组成:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move(s_i, a)&lt;/code&gt;: 找出从状态 $s_i$ 开始, 通过输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 所可以转换到的全部新状态.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure(s_i)&lt;/code&gt;: 所有从状态 $s_i$ 开始, 通过空输入 $\epsilon$ 所可以 &lt;strong&gt;直接或间接&lt;/strong&gt; 转换到的状态.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意: 对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt; 而言, 若考虑某个元素 $s$ 的闭包, 则闭包内包含的是 &lt;strong&gt;该元素本身&lt;/strong&gt; 以及 &lt;strong&gt;所有通过 $\epsilon$ 转换可以得到的其他元素&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;用于将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 转换到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 的基本逻辑是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 的 &lt;strong&gt;初始状态节点&lt;/strong&gt; 开始查找其 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;对找到的所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt;, 结合它们所可以接收到的所有类型的新输入 应用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;move()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;对新生成的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt; 再循环反复应用上述规则, 直到再也无法生成新的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt; 为止.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此时, 所生成的所有不同的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt; 就代表我们得到的, 等价的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的所有节点. 依据转换规则将这些新节点编号, 连接, 就得到了和原来的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 所等价的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224921.png&quot; alt=&quot;20220429224921&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中, 我们从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 的初始状态节点 $0$ 开始应用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epsilon-closure&lt;/code&gt;, 一步步扩展最终得到了五个不同的闭包. 上述 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NFA&lt;/code&gt; 即被相应地转换为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225030.png&quot; alt=&quot;20220429225030&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Subset Construction&lt;/code&gt; 得到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 存在大量冗余节点. 下面使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hopecroft's Algorithm&lt;/code&gt; 将其简化.&lt;/p&gt;

&lt;h4 id=&quot;dfa-的精简&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的精简&lt;/h4&gt;

&lt;p&gt;在对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 进行精简时, 我们将合并全部状态转换规则相同的节点, 检查冗余节点的方式为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hopecroft's Algorithm&lt;/code&gt; 的基本思想:&lt;/p&gt;

&lt;p&gt;首先将输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 的全部节点分为两个部分: 终止节点, 和非终止节点.&lt;/p&gt;

&lt;p&gt;其次, 根据不同输入分别判断: 非终止节点中是否有某个或某些节点在输入某些符号时状态转换的规则和其他的不一致. 如果对于任何一种输入出现了这种情况有的话, 将其聚类并拆分.&lt;/p&gt;

&lt;p&gt;对拆分后的节点集继续进行相同的检测, 直到无法再拆为止. 此时我们得到的一系列拆分后的节点集合就表明了原 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DFA&lt;/code&gt; 中哪些节点是互相等价, 可以合并的. 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225556.png&quot; alt=&quot;20220429225556&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225756.png&quot; alt=&quot;20220429225756&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;构造高效的词法分析器&quot;&gt;构造高效的词法分析器&lt;/h4&gt;

&lt;p&gt;在上面一小节中我们已经解释了如何从正则表达式通过数种中间形态转换到精简的确定性有穷状态机的过程. 而在将确定性有穷状态机转换成完全等价的状态转换表后, 它就可以被词法分析器调用以相对高效地完成词法分析任务.&lt;/p&gt;

&lt;p&gt;然而调用状态转换表仍然相对低效, 且会产生可观的内存开销. 因此, 契合实际的解决方案是: 将状态转换表编码的转换规则使用工具直接 &lt;strong&gt;自动化地集成&lt;/strong&gt; 到词法分析器中.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429230219.png&quot; alt=&quot;20220429230219&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在业界中, 常用的转换工具为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flex&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429230310.png&quot; alt=&quot;20220429230310&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它可以直接接受正则表达式为输入.&lt;/p&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;

&lt;p&gt;词法分析器将由一系列符号组成的源码经过分析和转换, 变为一系列词素. 这一过程是完全自动化的, 遵循 “正则表达式 - 非确定性有穷状态机 - 确定性有穷状态机” 的流程. 由于正则表达式具有表达多种复杂模式的强大功能, 它常被用于自动化词法分析的流程.&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析-1&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224133.png&quot; alt=&quot;20220503224133&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-语法分析-syntax-analysis&quot;&gt;3. 语法分析 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Syntax Analysis&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;在上面一节中, 我们已经介绍了词法分析的作用, 原理, 操作方法, 涉及的主要定理/算法与其他细节. 下面我们讨论完成词法分析后的下一步骤: 用于 &lt;strong&gt;生成构造出词法分析给出的一系列词素的流程&lt;/strong&gt; 的 &lt;strong&gt;语法分析&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430152802.png&quot; alt=&quot;20220430152802&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们首先明确语法分析的对象. 乔姆斯基的语法层级将语言大致按照逻辑严密性区分为了四个类别:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430152930.png&quot; alt=&quot;20220430152930&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中人类日常交流使用的自然语言语法位于最高 (也是逻辑性最差) 的一级, 正则语法的逻辑性最强, 而语法分析所需要处理的语言则为位于倒数第二级的 &lt;strong&gt;上下文无关语法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;这是由于正则语言存在两点无法避免的局限性:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430153315.png&quot; alt=&quot;20220430153315&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正则语言无法表示存在对称性和需要计数的字符串语言, 也无法直接应用未经完备定义的非终止符号.&lt;/p&gt;

&lt;p&gt;语法分析的目的是基于给定的语法, 分析出给定语素序列的 &lt;strong&gt;推导过程&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Derivation&lt;/code&gt;), 以及推导过程对应的 &lt;strong&gt;分析树&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse Tree&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;在分析推导过程时, 在每一步分析时都需要选择某个非终止符号并用合适的语法生成规则取代它, 而在每一步中选择不同的符号都会导致最后得出不同的生成规则.&lt;/p&gt;

&lt;p&gt;在编译器构造问题中, 我们主要关注的推导过程类型分为两种, 左起推导和右起推导:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430154501.png&quot; alt=&quot;20220430154501&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而分析树则是对推导过程的可视化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430154731.png&quot; alt=&quot;20220430154731&quot; /&gt;&lt;/p&gt;

&lt;p&gt;语法分析需要避免歧义性, 否则分析过程中会涉及相当数量的错误选择和回溯. 回顾定义, 我们知道, &lt;strong&gt;歧义性语言&lt;/strong&gt; 就是那些可以使用不止一种方式生成某些文字, 也就是分析过程会生成不止一种生成树的语言.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430155122.png&quot; alt=&quot;20220430155122&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了避免歧义性, 我们需要确保被分析语言的语法是不具歧义的. 解决这一问题的方法是 &lt;strong&gt;重写语法规则&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;下面先介绍两种常用的语法分析方法: &lt;strong&gt;自顶向下分析&lt;/strong&gt; 和 &lt;strong&gt;自底向上分析&lt;/strong&gt;, 并分别再讨论不同语法分析方法中解除歧义性的方法.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430155502.png&quot; alt=&quot;20220430155502&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意, 编译器常使用自底向上分析法.&lt;/p&gt;

&lt;h3 id=&quot;自顶向下分析&quot;&gt;自顶向下分析&lt;/h3&gt;

&lt;p&gt;自顶向下分析从 &lt;strong&gt;语法规定的起始符号&lt;/strong&gt; 开始, 从根开始 &lt;strong&gt;自顶向下&lt;/strong&gt; 分析语素序列, 构造对应的语法树, 直到我们构造的推导规则完整匹配了给定的序列为止:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160037.png&quot; alt=&quot;20220430160037&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而有效执行自顶向下分析的前提是在每一步分析时都选择语法中正确 (合适) 的生成规则, 否则分析器就需要回溯, 造成时间和资源的浪费. 举例而言, 基于下图所示的语法处理给定的字符串, 就有可能得到两种完全不同的生成规则:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160248.png&quot; alt=&quot;20220430160248&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而由于自顶向下分析的特征, 我们需要确保对应的语法 &lt;strong&gt;不为左递归 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;left-Recursive&lt;/code&gt;)&lt;/strong&gt; 的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160449.png&quot; alt=&quot;20220430160449&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而通过重写消除左递归, 我们就可以确保新的语法具有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LL(1)&lt;/code&gt; 性质:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160755.png&quot; alt=&quot;20220430160755&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在将语法生成规则重写确保它不为左递归的之后, 我们就可以开始考虑在语法分析时如何进行生成规则的选择. 得益于重写语法, 我们只需要在选择时从被分析的字符开始 &lt;strong&gt;向前看一位&lt;/strong&gt;, 就可以从重写后的规则中找到合适的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430160822.png&quot; alt=&quot;20220430160822&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;自底向上分析&quot;&gt;自底向上分析&lt;/h3&gt;

&lt;p&gt;与自顶向下分析不同, 自底向上分析生成语法树的方式是 &lt;strong&gt;从最底下的叶子节点开始反推&lt;/strong&gt;, 直到反向推出根节点 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goal&lt;/code&gt;, 这也就是从给定的输入字符串开始, 反推到起始符号的过程.&lt;/p&gt;

&lt;p&gt;回顾语法分析的目的是构造出一个生成序列, 使得从起始符号 $S$ 开始能够一步步构造出作为输入的被分析字符串 $\text{sentence}$:&lt;/p&gt;

\[S \rightarrow \delta_0 \rightarrow \delta_1 \rightarrow \cdots \rightarrow \cdots \rightarrow \delta_{n-1} \rightarrow \text{sentense}.\]

&lt;p&gt;要从后往前地, 基于中间字符串 $\delta_{i}$ 反向推导出 $\delta_{i-1}$, 我们需要选择 $\delta_{i}$ 中的某个字符 $x$, 利用语法中现存的分析规则&lt;/p&gt;

\[A\rightarrow x\]

&lt;p&gt;将 $x$ 替换为 $A$ 从而得到 $\delta_{i-1}$. 这一步骤也被称为 &lt;strong&gt;还原 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduction&lt;/code&gt;)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此, 自底向上分析中最为重要的步骤就是在每一步中进行 &lt;strong&gt;合适的还原&lt;/strong&gt;. 而寻找还原的实质是, 找到:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个匹配生成语法中某条规则右侧结果&lt;/strong&gt;, 而且在需要被处理的字符串中 &lt;strong&gt;出现&lt;/strong&gt; 的子串. 我们称这样的子串为一个 &lt;strong&gt;还原柄&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430171124.png&quot; alt=&quot;20220430171124&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;显然对于没有歧义的语法规则而言, 任何一条规则的右侧结果都 &lt;strong&gt;唯一对应&lt;/strong&gt; 一个还原柄.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在还原柄的形式化表示中, $k$ 代表的是 &lt;strong&gt;子串的最右侧元素在字符串中所处的位置&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430184943.png&quot; alt=&quot;20220430184943&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;举例而言, 在上图中, 尝试匹配 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a A bcde&lt;/code&gt; 时, 对应的子串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abc&lt;/code&gt; 在字符串中的 $k$ 就应该是 $4$.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在通过还原得到了这些还原柄后, 我们就可以相应地构建对字符串的推导过程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430171411.png&quot; alt=&quot;20220430171411&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面看一个例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430191708.png&quot; alt=&quot;20220430191708&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中, 我们手动地执行了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt; 入栈和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce&lt;/code&gt; 替换的操作, 最终得到了一个反向从字符串倒推回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goal&lt;/code&gt; 的构造序列.&lt;/p&gt;

&lt;p&gt;抽象地, 寻找还原柄和生成推导过程的逻辑可被表示为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce Parser&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430171522.png&quot; alt=&quot;20220430171522&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而自底向上分析仍然存在两个问题需要解决. 仅从上面处理 $x-2y$ 的例子就可看出, 在黄色行处, 需要作出正确的选择: 不直接从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Expr&lt;/code&gt; 反向匹配到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Goal&lt;/code&gt;, 而是继续 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shift&lt;/code&gt; 入栈才能得到正确的结果.&lt;/p&gt;

&lt;p&gt;这意味着在一些情况下存在这样的问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;语法分析器无法决定是执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt; 还是执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;语法分析器无法决定执行哪个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt; 规则&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前者可以通过修改语法或人为规定优先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt; 解决冲突, 而后者就很难通过简单的操作缓解.&lt;/p&gt;

&lt;p&gt;因此, 为了高效执行 &lt;strong&gt;自底向上分析&lt;/strong&gt;, 需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle-Finding Mechanism&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce Parsing&lt;/code&gt; 确定化和自动化, 需要我们确保给定的上下文无关语法具备 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 性质:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430192609.png&quot; alt=&quot;20220430192609&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意此处在确保上下文无关语法是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 的之后, 决定执行哪个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduce&lt;/code&gt; 规则时也只需要和自顶向下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LL(1)&lt;/code&gt; 一样向前多看一位即可.&lt;/p&gt;

&lt;p&gt;基于具备 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 性质的上下文无关语法下的, 自底向上的语法分析称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR Parsing&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;它除了和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce Parser&lt;/code&gt; 一样需要逐个从左向右, 自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input Buffer&lt;/code&gt; 读入语素 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;) 外, 还需要在入栈的每个符号后加入表示状态的额外信息.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430193235.png&quot; alt=&quot;20220430193235&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它需要使用两个额外的信息表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430193128.png&quot; alt=&quot;20220430193128&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GOTO&lt;/code&gt; 信息表包含了满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 条件的, 上下文无关语法的语法规则, 并且可以决定在什么情况下执行什么样的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift-Reduce&lt;/code&gt; 操作. 注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION&lt;/code&gt; 表的列数恰为终止符号的数量, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GOTO&lt;/code&gt; 表的列数为非终止符号的数量, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION-GOTO&lt;/code&gt; 联表的列数为二者列数之和 + 1, 因为还需要额外一列存储状态信息.&lt;/p&gt;

&lt;p&gt;自此, 我们可以利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR-Parsing&lt;/code&gt; 自动化地执行语法分析.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430193429.png&quot; alt=&quot;20220430193429&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面使用自测题中较为复杂的一道 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1)&lt;/code&gt; 查表题介绍如何解决这一类的题目:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430195453.png&quot; alt=&quot;20220430195453&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给定字符串 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(())()&lt;/code&gt;, 转换语法和对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACTION-GOTO&lt;/code&gt; 联表, 要求 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LR(1) Parser&lt;/code&gt; 基于给定信息生成的字符串构造顺序.&lt;/p&gt;

&lt;p&gt;求解这类题目时首先在草稿上画出三列联表: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack, Input, Action&lt;/code&gt;, 初始状态下栈内只有一个表示栈头的元素 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;, 以及初始状态 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input&lt;/code&gt; 行恰为给定字符串, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Action&lt;/code&gt; 栏为空.&lt;/p&gt;

&lt;p&gt;然后将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Input&lt;/code&gt; 中字符串的 &lt;strong&gt;左边第一个元素&lt;/strong&gt; 视为状态 $0$ 时的输入, 对应查表得到, 在状态 $0$ 下输入为 $($ 时需要执行的操作为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S3&lt;/code&gt;, 也就是: &lt;strong&gt;先 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;, 然后通过给推入栈的新元素右侧补上 $3$ 的方式表明状态转换到了 $3$&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;随后对应更新三列联表, 开始考虑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;())()&lt;/code&gt;. 由于此时处于状态 $3$, 输入为 $($, 查表可知需执行 $S6$, 也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt; + 通过在入栈的新元素右侧记录$6$ 表示转换状态到 $6$.&lt;/p&gt;

&lt;p&gt;然后考虑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;))()&lt;/code&gt;. 查表知状态 $6$ 下输入为 $)$, 需执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S10&lt;/code&gt;: 入栈, 记录新元素对应状态为 $10$, 状态转移到 $10$.&lt;/p&gt;

&lt;p&gt;随后考虑状态 $10$ 下输入 $)()$: 对应查表知需执行操作 $R5$ (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Replacement Rule 5&lt;/code&gt;): 也就是执行替换规则 $5$. 注意在该类情况下的状态转换问题:&lt;/p&gt;

&lt;p&gt;根据提示检查替换规则 $5$, 知需要反向将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt; 替换为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;. 此时将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(6)10&lt;/code&gt;连同字符 (括号) 后对应的状态标记 $6$ 和 $10$ 一起替换. 替换后此时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; 中只有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$0(3&lt;/code&gt;, 意味着状态转换到了 $3$.&lt;/p&gt;

&lt;p&gt;再查表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GOTO&lt;/code&gt;, 知状态 $3$ 下输入为 $P$, 状态需要对应转换到 $5$, 因此 $P$ 的状态标记就是 $5$, 此时栈内元素更新为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$0(3P5&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;以此类推可得:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430201412.png&quot; alt=&quot;20220430201412&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意推导过程必须直到查表对应 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Action&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accept&lt;/code&gt; 方能结束.&lt;/p&gt;

&lt;p&gt;最后我们总结如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430201517.png&quot; alt=&quot;20220430201517&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析-2&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224209.png&quot; alt=&quot;20220503224209&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224222.png&quot; alt=&quot;20220503224222&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224240.png&quot; alt=&quot;20220503224240&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-编译器中端-middle-end&quot;&gt;4. 编译器中端 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Middle-End&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;在上面一节中我们已知, 通过词法分析和语法分析, 编译器可以确定输入的源码是指定程序设计语言的一段合法的代码, 也就是说如果将输入的源码视为一段字符串, 则可知:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输入源码中语素的顺序满足语法规定, 是指定语言的合法句子.&lt;/li&gt;
  &lt;li&gt;并且通过语法分析, 可以得到基于语言的语法规则生成这个句子的流程.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般地, 语法分析的产物都是一棵 &lt;strong&gt;分析树&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse Tree&lt;/code&gt;), 以图形化的方式表示了如何从给定语言的起始符号开始使用不同生成规则构造出作为输入的句子 (字符串/源码) 的过程.&lt;/p&gt;

&lt;p&gt;因此, 分析树可以作为编译器生成 &lt;strong&gt;和源代码完全等价, 但相对更为高效&lt;/strong&gt; 的 &lt;strong&gt;中间表示&lt;/strong&gt; 的基础. 需要注意的是, 在完成语法分析后, 我们并未完全完成对代码中潜在的其他错误, 如变量类型错误, 变量声明和引用错误等 &lt;strong&gt;语法分析器无法检测出&lt;/strong&gt; 的 &lt;strong&gt;非语法错误&lt;/strong&gt;, 因此在生成中间表示之前还需要执行 &lt;strong&gt;非语法错误检查&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;非语法错误检查&quot;&gt;非语法错误检查&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430212422.png&quot; alt=&quot;20220430212422&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中, 虽然给定的程序代码不存在任何语法错误, 但我们可以明确看出变量声明存在错误, 函数调用中变量多于函数声明时指定的数目, 参数化输出中给定参数类型不匹配等 &lt;strong&gt;非语法问题&lt;/strong&gt;. 这些非语法问题常常是 &lt;strong&gt;上下文相关&lt;/strong&gt; 的, 即单独拎出一行来分析语法错误不存在任何问题, 但放在全文中则会将问题暴露. 由于上下文无关语法无法解决和处理这类问题, 我们需要提出针对性的策略.&lt;/p&gt;

&lt;p&gt;我们可以引入 &lt;strong&gt;类型系统&lt;/strong&gt; 检测源代码中变量类型不匹配的问题.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430212825.png&quot; alt=&quot;20220430212825&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相似地, 其他类型的上下文无关语法问题也需要有对应的解决方案. 我们可以通过定义上下文相关语法将检测形式化, 但这极其困难, 且在处理一些特殊情形 (如检查变量是否在使用前声明) 时会导致需要匹配的规则数量过大以至于无法完成检测.&lt;/p&gt;

&lt;p&gt;更为实际的做法是: 使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ad hoc techniques&lt;/code&gt;, 结合某个 &lt;strong&gt;符号表&lt;/strong&gt; 进行对应的检测.&lt;/p&gt;

&lt;p&gt;符号表就是存储 &lt;strong&gt;词法分析/语法分析/代码错误检查时所需&lt;/strong&gt; 的 &lt;strong&gt;全体事实&lt;/strong&gt; 的数据结构, 它在词法分析时生成, 并在后续的剩余编译过程中持续被频繁调用. 通过查询和更新符号表, 编译器就可完成诸如 “变量是否都在使用之前提前声明”, 以及 “数值运算和逻辑运算涉及变量的类型是否匹配” 一类的困难问题. 而符号表中可能存储的信息类型同样是非常复杂的, 以至于实际上编译器可能需要同时维护多个符号表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213426.png&quot; alt=&quot;20220430213426&quot; /&gt;&lt;/p&gt;

&lt;p&gt;符号表可以使用线性列表, 二叉树和哈希表实现, 契合实际的实现方式是哈希表.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213520.png&quot; alt=&quot;20220430213520&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而哈希表的相关知识在上学期的数据结构与算法课程中已经详细介绍过, 此处不再赘述.&lt;/p&gt;

&lt;p&gt;此外, 在非语法错误检查中还会涉及诸如哈希表中哈希函数的选择, 变量命名域等复杂问题, 这些问题不属于本课程的介绍重点, 因此不再赘述.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213719.png&quot; alt=&quot;20220430213719&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;中间表示生成&quot;&gt;中间表示生成&lt;/h3&gt;

&lt;p&gt;我们下面讨论实际的中间表示生成步骤. 合适的中间表示应该满足下列的要求:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430213828.png&quot; alt=&quot;20220430213828&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中间表示的类型包含:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图形 (结构可视化) 式, 一般形如树, 结构贴近源码但可能具有大量的边和节点, 导致其极其复杂.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性式, 一般为伪代码的形式, 更贴近目标代码.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;混合式, 结合了图形式和线性式的特征.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面分别介绍一种图形式和线性式的代表:&lt;/p&gt;

&lt;h4 id=&quot;抽象语法树-abstract-syntax-tree-ast&quot;&gt;抽象语法树 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abstract Syntax Tree, AST&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;抽象语法树基于分析树 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parse Tree&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214258.png&quot; alt=&quot;20220430214258&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;三地址码-three-address-code&quot;&gt;三地址码 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Three-Address Code&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214333.png&quot; alt=&quot;20220430214333&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, 一些辅助信息也会作为中间表示的一部分:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214416.png&quot; alt=&quot;20220430214416&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后介绍一些常用的代码优化方法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214510.png&quot; alt=&quot;20220430214510&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214644.png&quot; alt=&quot;20220430214644&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及另一种优化循环的方法:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220430214752.png&quot; alt=&quot;20220430214752&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Loop Unrolling&lt;/code&gt; 的目的是减少执行循环体的次数, 从而降低在执行循环条件判断和循环跳转过程中的各种开销.&lt;/p&gt;

&lt;p&gt;最后总结如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在编译器的中间表示生成步骤中有多种不同的中间表示类型可选, 本课程简要介绍了抽象语法树和三地址码两种.&lt;/li&gt;
  &lt;li&gt;在这一步中我们同样可见, 除了正确地表示源码的含义外, 检查源码中潜在的非语法错误同样是一件极其困难的任务, 现代编译器一般使用基于哈希表实现的符号表处理这一问题.&lt;/li&gt;
  &lt;li&gt;在本节中我们同样介绍了数种与硬件无关的中间表示代码优化方法, 但为了实现极致的优化, 实际的编译器往往还要在目标代码生成时执行更复杂的, 更底层的优化手段.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;相关题目解析-3&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224329.png&quot; alt=&quot;20220503224329&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224341.png&quot; alt=&quot;20220503224341&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-代码生成&quot;&gt;5. 代码生成&lt;/h2&gt;

&lt;p&gt;代码生成属于编译器后端需要完成的任务, 它接受编译器中端生成的中间表示, 并将其经过转换和优化后, 生成最后的目标代码.&lt;/p&gt;

&lt;p&gt;在这一过程中, 主要会涉及两个问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何使用 &lt;strong&gt;模式识别 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pattern Matching&lt;/code&gt;)&lt;/strong&gt; 选择合适的目标语言指令?&lt;/li&gt;
  &lt;li&gt;如何基于目标硬件平台的特性进行针对性的代码优化?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在本课程中, 我们将只关注下面的三个问题: 指令选择, 寄存器分配和指令调度.&lt;/p&gt;

&lt;h3 id=&quot;指令选择-instruction-selection&quot;&gt;指令选择 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction Selection&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;指令选择这一步中的主要任务是基于 &lt;strong&gt;模式识别&lt;/strong&gt; 将中间表示和目标代码相匹配. 在这一步中, 我们不进行任何优化, 且假设寄存器的数量完全足够.&lt;/p&gt;

&lt;p&gt;我们将在下面的讨论中使用如下图所示的, 形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC&lt;/code&gt; 汇编语言的伪机器语言:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501092510.png&quot; alt=&quot;20220501092510&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;数值运算表达式-arithmetic-expressions-的代码生成&quot;&gt;数值运算表达式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Arithmetic Expressions&lt;/code&gt;) 的代码生成&lt;/h4&gt;

&lt;p&gt;在生成数值运算表达式的代码时, 编译器采取的遍历策略是 &lt;strong&gt;类似遍历树一样的后序遍历&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501092726.png&quot; alt=&quot;20220501092726&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而针对相关的问题, 也有对应的处理策略:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501092808.png&quot; alt=&quot;20220501092808&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;优先遍历左子树的原因是我们总是需要优先考虑对寄存器有更高利用需求的子树.&lt;/li&gt;
  &lt;li&gt;将常规乘法转换为多个 &lt;strong&gt;可表为$2$的幂的数和变量相乘&lt;/strong&gt; 的形式后, 就可以使用 &lt;strong&gt;位运算&lt;/strong&gt; 提升计算速度, 降低资源开销.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;数组引用代码生成&quot;&gt;数组引用代码生成&lt;/h4&gt;

&lt;p&gt;程序设计语言定义数组的方式一般分为 &lt;strong&gt;行主导定义 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Row-Major Order&lt;/code&gt;)&lt;/strong&gt; 和 &lt;strong&gt;列主导定义 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Column-Major Order&lt;/code&gt;)&lt;/strong&gt;, 我们目前所学习的绝大多数程序设计语言所使用的都是行主导定义.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093208.png&quot; alt=&quot;20220501093208&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在明确了数组首元素的内存地址和需要引用的数组元素坐标后, 就可以结合数组的定义方式快速地计算出需要被引用元素的内存地址:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093158.png&quot; alt=&quot;20220501093158&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;控制语句代码生成&quot;&gt;控制语句代码生成&lt;/h4&gt;

&lt;p&gt;对于形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if...else...&lt;/code&gt; 的控制语句, 在生成其对应目标代码时, 首先需要生成条件判断部分的代码, 其次分别生成对应条件分支对应的代码.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093318.png&quot; alt=&quot;20220501093318&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while..., loop..., do loop...&lt;/code&gt; 的循环语句, 需要在循环开始前和循环结束后都生成条件判断语句对应的代码以控制循环.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093427.png&quot; alt=&quot;20220501093427&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时, 也可以通过类似树遍历的方式处理复杂的布尔表达式. 注意在此处可以利用短路特性 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Short-Circuit Evaluation&lt;/code&gt;) 简化表达式.&lt;/p&gt;

&lt;h4 id=&quot;程序函数方法代码生成&quot;&gt;程序/函数/方法代码生成&lt;/h4&gt;

&lt;p&gt;程序, 方法和函数的引入便于人类理解和编写复杂程序, 但它们对于编译器和计算机而言非但是完全不必要的, 反而会在编译过程中带来一定的困难. 由于计算机执行代码的过程实际上是顺序流式的, 因此编译器需要在编译过程中 “模拟” 出函数/方法, 如通过分支跳转等方式调用函数, 为不同的函数和方法划分单独的寄存器空间存储函数变量等.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501093951.png&quot; alt=&quot;20220501093951&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对函数/方法的模拟的代价是较大的资源开销. 因此, 包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; 在内的一些语言在编译时会尽可能地通过直接将对应的函数代码段插入过程流的方式减少在实际目标代码中涉及的, 所需要模拟的方法数量.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501094002.png&quot; alt=&quot;20220501094002&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;寄存器分配-register-allocation&quot;&gt;寄存器分配 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Register Allocation&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;在指令选择这一步中, 我们假设可供使用的寄存器数量是无限的, 这显然不符合事实. 因此, 代码生成的下一步就是通过执行寄存器分配优化目标代码中寄存器的使用数量, 使其满足实际物理机上寄存器数量的限制.&lt;/p&gt;

&lt;p&gt;下面首先给出一些定义:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt;: 最长的, 不含任何分支跳转 (限于控制流语句和循环语句) 的代码段.&lt;/li&gt;
  &lt;li&gt;局部寄存器分配: 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中执行的寄存器分配.&lt;/li&gt;
  &lt;li&gt;全局寄存器分配: 在程序全体中执行的寄存器分配.&lt;/li&gt;
  &lt;li&gt;寄存器分配: 决定将什么变量/数据存储到寄存器中的过程.&lt;/li&gt;
  &lt;li&gt;寄存器赋值: 选择特定寄存器存储数据的过程.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现代处理器包含多种, 大量寄存器, 因此寄存器分配问题是非常复杂的. 本小节只对寄存器分配的原理和规则进行极为简单的介绍.&lt;/p&gt;

&lt;h4 id=&quot;变量的生命概念和生命周期&quot;&gt;变量的生命概念和生命周期&lt;/h4&gt;

&lt;p&gt;引入这一概念的主要目的是解决 “在某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中最多需要多少个寄存器” 的问题, 通过引入生命周期, 我们就可以计算出 “同时有多少个变量正在被程序使用” 以及 “特定的变量何时不再被使用, 可被清除” 的问题.&lt;/p&gt;

&lt;p&gt;我们称变量的生命周期介于 &lt;strong&gt;变量被声明&lt;/strong&gt; 以及 &lt;strong&gt;变量最后一次被调用/使用&lt;/strong&gt; 之间, 可以表示为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中的一个分段 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interval&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;如果某个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 中的任何时间段里, 活跃的变量数超过了物理寄存器上限, 就需要基于一定的规则踢掉 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Spill&lt;/code&gt;) 某些变量, 为其他变量创造空间.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501102404.png&quot; alt=&quot;20220501102404&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501102632.png&quot; alt=&quot;20220501102632&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过估计踢掉特定变量的 &lt;strong&gt;成本&lt;/strong&gt; 决定在寄存器不足时需要踢掉哪个变量:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103904.png&quot; alt=&quot;20220501103904&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;寄存器分配原则&quot;&gt;寄存器分配原则&lt;/h4&gt;

&lt;p&gt;我们着重关注局部寄存器分配问题. 局部寄存器分配问题的解决方案分为 &lt;strong&gt;自顶向下寄存器分配&lt;/strong&gt; 和 &lt;strong&gt;自底向上寄存器分配&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;自顶向下寄存器分配原则为使用最频繁的值优先保留寄存器空间, 但这可能导致在上一段代码中频繁使用, 而在下一段代码中几乎不使用的变量挤占了下一段代码的寄存器空间, 因此不切实际.&lt;/p&gt;

&lt;p&gt;自底向上寄存器分配原则使用 “寄存器池” 的概念: 任何变量开始生命周期时都从池子里拿走一个寄存器, 而在生命周期结束时返还寄存器到池子里, 若池子里没有足够的寄存器, 就需要让 &lt;strong&gt;在最远的未来才会被调用的寄存器&lt;/strong&gt; 释放值, 这也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Best's Algorithm&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;使用图染色方法解决寄存器分配问题&quot;&gt;使用图染色方法解决寄存器分配问题&lt;/h4&gt;

&lt;p&gt;我们还可以使用图染色方法解决寄存器分配问题.&lt;/p&gt;

&lt;p&gt;其基本逻辑是: 生命周期不互相干涉 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interference&lt;/code&gt;) 的变量可以共享同一个寄存器.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103206.png&quot; alt=&quot;20220501103206&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图染色问题的定义在此不作说明. 下面给出 &lt;strong&gt;干涉&lt;/strong&gt; 的定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103248.png&quot; alt=&quot;20220501103248&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意如果在某时刻, 上一个变量的生命周期恰好结束而下一个变量的生命周期刚刚开始, 则我们 &lt;strong&gt;不认为&lt;/strong&gt; 这两个变量之间发生了干涉.&lt;/p&gt;

&lt;p&gt;而我们一般使用 &lt;strong&gt;自顶向下染色&lt;/strong&gt; 的方式构造 $k$-染色: 先排序, 然后从高到低依次为节点染色.&lt;/p&gt;

&lt;p&gt;回顾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lab3&lt;/code&gt;, 我们使用的排序策略是基于编号和邻居数量的复合策略.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103439.png&quot; alt=&quot;20220501103439&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, 自底向上染色的方式也很常见.&lt;/p&gt;

&lt;h4 id=&quot;使用控制流图检测全局生命周期&quot;&gt;使用控制流图检测全局生命周期&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501103626.png&quot; alt=&quot;20220501103626&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;指令调度-instruction-scheduling&quot;&gt;指令调度 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction Scheduling&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;我们最后讨论指令调度.&lt;/p&gt;

&lt;p&gt;由于任何指令从执行到返回结果都不可避免地需要耗费一定的时间, 因此通过合理的安排指令调度, 我们就可以优化指令执行所需要的时间, 这也是指令调度的主要目的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501104303.png&quot; alt=&quot;20220501104303&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在执行指令调度时, 编译器已经预先知道不同类型的指令对应的延迟数据.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501105857.png&quot; alt=&quot;20220501105857&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而由于现代计算机可以在同一个周期中执行多条指令, 且指令的结果必须在延迟后才能返回, 因此可以利用这一特性进行一些以提高寄存器利用率为代价的, 针对性的优化.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110114.png&quot; alt=&quot;20220501110114&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举例而言, 在下图所示的例子中, 右侧的优化通过增加了一个对寄存器的引用使得我们可以减少三个周期 (恰为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt; 的延迟长度) 的程序运行时间.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110216.png&quot; alt=&quot;20220501110216&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面介绍对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Basic Block&lt;/code&gt; 的指令调度的优化技术:&lt;/p&gt;

&lt;p&gt;其基本思想是构造 &lt;strong&gt;优先图&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Precedence Graph&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data Dependence Graph&lt;/code&gt;), 为图中的每个节点使用某个 &lt;strong&gt;优先函数 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Priority Funtion&lt;/code&gt;)&lt;/strong&gt; 计算优先权重, 然后使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List Scheduling&lt;/code&gt; 的手段构造指令调度.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110421.png&quot; alt=&quot;20220501110421&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意优先图考虑的是 &lt;strong&gt;每一条指令之间的依赖关系&lt;/strong&gt;, 而非 &lt;strong&gt;寄存器数据之间的依赖关系&lt;/strong&gt;. 如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110626.png&quot; alt=&quot;20220501110626&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在得到优先图后, 就需要对图中的每个节点进行优先权重的计算:&lt;/p&gt;

&lt;p&gt;在下面的例子中, 我们假定每个节点的权重都等于该节点代表指令本身的延迟 + 其所有子节点中最大权重的值. 因此, 优先图的构建是自底向上的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501110752.png&quot; alt=&quot;20220501110752&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随后我们就可以开始构建指令调度顺序. 首先考虑优先图中没有任何依赖的全体节点, 最先执行权重最大的, 在本例中为 $6$.&lt;/p&gt;

&lt;p&gt;随后, 将上一轮中被考虑的那些剩余节点以及 &lt;strong&gt;执行了 $6$ 之后满足依赖条件可以被执行的新节点&lt;/strong&gt; 放在一起按照权重排序, 仍然选择权重最高的优先执行 (在本例中, 因为 $7$ 需要同时满足 $2$ 和 $6$, 因此只执行了 $6$ 之后也不能执行任何新节点, 所以选择 $1$).&lt;/p&gt;

&lt;p&gt;依次判断推导, 可知第三步中需要考虑的节点为 $2, 4, 3$, 而在此之中 $2$ 权重最高.&lt;/p&gt;

&lt;p&gt;最后可得下图所示的调度顺序:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501111147.png&quot; alt=&quot;20220501111147&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List Scheduling&lt;/code&gt; 还可以结合多种优化手段. 此处不再详细介绍:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501111248.png&quot; alt=&quot;20220501111248&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后我们可以将编译器的完整结构总结如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501111349.png&quot; alt=&quot;20220501111349&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;相关题目解析-4&quot;&gt;相关题目解析&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224419.png&quot; alt=&quot;20220503224419&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224430.png&quot; alt=&quot;20220503224430&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 64x+16x-x)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220503224503.png&quot; alt=&quot;20220503224503&quot; /&gt;&lt;/p&gt;

&lt;p&gt;($\uparrow$ 函数调用不视为branching)&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/14/Ch3-COMP26020/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/14/Ch3-COMP26020/</guid>
        
        <category>课程笔记</category>
        
        <category>编译理论</category>
        
        
      </item>
    
      <item>
        <title>数据结构与算法： 单纯形法</title>
        <description>&lt;h1 id=&quot;单纯形法&quot;&gt;单纯形法&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;单纯形法&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Simplex Algorithm&lt;/code&gt;) 是一种用于 &lt;strong&gt;求解线性约束问题最优解&lt;/strong&gt; 的有效算法.&lt;/p&gt;

&lt;p&gt;本章介绍 &lt;strong&gt;单纯形法&lt;/strong&gt;. 我们首先通过介绍线性规划问题的图像化表示引入单纯形法的基本思路, 介绍单纯形法中的一些定义, 并通过例子说明使用它求解线性规划问题的操作流程.&lt;/p&gt;

&lt;h2 id=&quot;单纯形法的引子-线性规划问题的图像化表示&quot;&gt;单纯形法的引子: 线性规划问题的图像化表示&lt;/h2&gt;

&lt;p&gt;我们下面回顾 &lt;strong&gt;线性规划问题的图像化表示&lt;/strong&gt;. 考虑下列问题:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220321072245.png&quot; alt=&quot;20220321072245&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将约束式的边界条件视为一次函数并将其在平面直角坐标系上绘制出来, 不难看出各约束条件所限制的, 平面可取区域的重叠处:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220321072528.png&quot; alt=&quot;20220321072528&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此问题中的可取区域为 $x_1$ 的正方向, $x_2$ 轴和所有一次函数所围成的区域.&lt;/p&gt;

&lt;p&gt;显然, 可取区域包含了原点: $(0, 0)$. 我们将介绍适用于这种情形下的线性规划问题最优解计算方法, 而对 &lt;strong&gt;可取区域不包含原点&lt;/strong&gt; 的线性规划问题的求解问题则在下一周内容中讨论.&lt;/p&gt;

&lt;h2 id=&quot;解决原点为可行解的线性规划问题-简易单纯形法&quot;&gt;解决原点为可行解的线性规划问题: 简易单纯形法&lt;/h2&gt;

&lt;h3 id=&quot;单纯形法的基石-简易单纯形法的基本原理&quot;&gt;单纯形法的基石: 简易单纯形法的基本原理&lt;/h3&gt;

&lt;p&gt;简易单纯形法的基本原理是: 形如 &lt;strong&gt;凸超多边形&lt;/strong&gt; 的可行域的 &lt;strong&gt;顶点之一&lt;/strong&gt; 必为最优解. 因此:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为了确保可行域形为凸超多边形, 单纯形法要求被求解的线性规划问题在矩阵表示形式下满足&lt;/p&gt;

\[\mathbf{b} \geqslant 0\]

    &lt;p&gt;也就是说线性规划问题在被转换为标准形式前, 其表示中不会出现 $=$ 或 $\leqslant$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基于第一点的约束, 不难看出在满足上述条件的问题下 $0$ (零向量, 对应平面的原点) 必为该类问题的一个解.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于时间关系, 此处不再介绍详细推导过程.&lt;/p&gt;

&lt;h3 id=&quot;单纯形法中的重要定义-松弛形式和基础非基础变量&quot;&gt;单纯形法中的重要定义: 松弛形式和基础/非基础变量&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220321072245.png&quot; alt=&quot;20220321072245&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还是考虑上面的例子, 显然这是一个可被单纯形法解决的问题.&lt;/p&gt;

&lt;p&gt;在该问题中, 前三条规则 (也就是实际的约束规则) 约束了不等号左边的式子 &lt;strong&gt;最多取到某个数值&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因而, 我们可以认为实际上左边的式子和右边的数值之间 &lt;strong&gt;存在一定的空隙&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;所谓的 &lt;strong&gt;松弛形式&lt;/strong&gt; 就是指, 我们为每一个这样的式子额外引入一个表示空隙的变量, 称其为 &lt;strong&gt;松弛变量&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;因此, 上述问题的 &lt;strong&gt;松弛形式&lt;/strong&gt; 就是:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507194403.png&quot; alt=&quot;20220507194403&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于限制变量为非负的约束规则 (也就是途中从上往下数的第四条规则), &lt;strong&gt;不需要引入任何松弛变量&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;对于任何其他的约束规则, 都 &lt;strong&gt;只引入一个&lt;/strong&gt; 约束变量.&lt;/li&gt;
  &lt;li&gt;任何约束变量的系数 &lt;strong&gt;都是 $1$&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;随后补充 &lt;strong&gt;基础变量/非基础变量&lt;/strong&gt; 和 &lt;strong&gt;基础解&lt;/strong&gt; 的定义:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507194635.png&quot; alt=&quot;20220507194635&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;寻找线性约束问题的最优解-利用松弛形式-slack-form&quot;&gt;寻找线性约束问题的最优解: 利用松弛形式 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slack Form&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;在上一节中我们介绍了 &lt;strong&gt;基础变量&lt;/strong&gt; 的定义, 显然可知:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;所有的松弛变量&lt;/strong&gt; 都是 &lt;strong&gt;基础变量&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;约束问题中所有的原始变量&lt;/strong&gt; 都是 &lt;strong&gt;非基础变量&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进一步地, 可以观察到 &lt;strong&gt;若兑换某个基础变量和某个非基础变量&lt;/strong&gt; 时, 我们就可以在图形化表示上得到不同的相交点, 这些相交点如果是坐标系里表示问题可行域的多边形的顶点, 则它就是问题的其中一个解.&lt;/p&gt;

&lt;p&gt;由此, 理论上我们只需要不断地对换基础变量和非基础变量, 就可以尝试问题的全部可行解, 最后就能得出问题的最优解.&lt;/p&gt;

&lt;p&gt;在下面的单纯形法操作中, 我们会进一步了解它使用了什么样的启发式原则选择可能的最优解从而避免盲目遍历的.&lt;/p&gt;

&lt;p&gt;其次, 我们可以进一步思考一个问题: 如果将线性规划问题的松弛形式表示为线性方程组的话, 对换基础变量和非基础变量的过程和 &lt;strong&gt;高斯消元法&lt;/strong&gt; 是否有几分相似, 或者说它其实就是高斯消元法呢?&lt;/p&gt;

&lt;p&gt;下面讨论单纯形法的操作步骤:&lt;/p&gt;

&lt;h3 id=&quot;在单纯形法中遍历可行解-枢轴-pivoting&quot;&gt;在单纯形法中遍历可行解: 枢轴 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pivoting&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;所谓的 “枢轴”, 实际上就是在 &lt;strong&gt;用增广矩阵表示的&lt;/strong&gt;, &lt;strong&gt;松弛形式的线性约束问题&lt;/strong&gt; 中, &lt;strong&gt;在某一步中&lt;/strong&gt; 基于 &lt;strong&gt;某个启发式规则 (具体是什么规则马上会讲)&lt;/strong&gt; 选定的 &lt;strong&gt;某行&lt;/strong&gt; 和 &lt;strong&gt;某列&lt;/strong&gt; 上的一个元素, 目标是要用这个 “枢轴” 通过 &lt;strong&gt;高斯消元法&lt;/strong&gt; 消去同一列中 &lt;strong&gt;包含目标行在内的&lt;/strong&gt; 所有 &lt;strong&gt;非零元&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;而在执行这个步骤后, 这个 &lt;strong&gt;枢轴&lt;/strong&gt; 对应列的 &lt;strong&gt;非基础变量&lt;/strong&gt; 和它对应行的 &lt;strong&gt;基础变量&lt;/strong&gt; 之间发生了转换.&lt;/p&gt;

&lt;p&gt;下面考虑单纯形法中使用枢轴基于启发式规则快速遍历可行解的方法.&lt;/p&gt;

&lt;p&gt;首先启发式规则的定义看下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507210015.png&quot; alt=&quot;20220507210015&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述截图中的 $\theta$ 就是选择枢轴所在行的依据.&lt;/p&gt;

&lt;p&gt;然后以课上的例子结束:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507210335.png&quot; alt=&quot;20220507210335&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意在上面的例子中我犯了一个错误: 选定枢轴行后, 需要先使用基础行变换将枢轴的系数变为 $1$.&lt;/p&gt;

&lt;h3 id=&quot;相关习题解析&quot;&gt;相关习题解析&lt;/h3&gt;

&lt;p&gt;见笔记 “数据结构与算法： 复习”.&lt;/p&gt;

&lt;h2 id=&quot;处理原点不为可行解的线性规划问题-进阶单纯形法&quot;&gt;处理原点不为可行解的线性规划问题: 进阶单纯形法&lt;/h2&gt;

&lt;p&gt;在上面数节中我们已经知道, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Simplex&lt;/code&gt; 算法在 &lt;strong&gt;原点为线性规划问题的一个可行解&lt;/strong&gt; 时 &lt;strong&gt;必可解决这个线性规划问题&lt;/strong&gt;. 下面考虑 &lt;strong&gt;原点不为线性规划问题的一个可行解的情况&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;考虑下面的例子, 显然这个例子中原点不是可行解:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507220454.png&quot; alt=&quot;20220507220454&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将其转换为增广矩阵表示后也会发现, 在右侧常数列中存在非正数 $-12$, 因此无法使用前面介绍的简易单纯形法求解:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507220551.png&quot; alt=&quot;20220507220551&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;进阶单纯形法&lt;/strong&gt; 处理该问题的基本思路是: 注入 &lt;strong&gt;人工变量&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Artificial Variable&lt;/code&gt;) 将这个复杂问题转化为一个 &lt;strong&gt;接受原点为解的新问题&lt;/strong&gt;, 并同时 &lt;strong&gt;修改问题的优化目标&lt;/strong&gt; 使 &lt;strong&gt;这个人工变量值必须为 $0$&lt;/strong&gt;, 从而确保 &lt;strong&gt;新问题的解也就是原问题的解&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507220755.png&quot; alt=&quot;20220507220755&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意对原问题的转换原理:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为何这样注入 $a_1$?&lt;/p&gt;

    &lt;p&gt;“原问题中有个约束式子导致原点代进去值太小, 以至于不为解” -&amp;gt; “注入人工变量 $a_1$, 因为 $a_1&amp;gt;0$, 所以此时 $2 \cdot 0 + 1\cdot 0 + a_1 \geqslant 12$”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为何如此修改目标优化式?&lt;/p&gt;

    &lt;p&gt;目标优化: 最大化; 另一目标: 让 $a_1$ 为 $0$; =&amp;gt; 引入一个数值极大的惩罚参数 $M_1$, 如果 $a_1$ 不为 $0$ 则  经过修改的目标参数式 $3x_1 + x_2 - M_1 a_1$ 永为 $-\infty$ 得不到优化 =&amp;gt; 实现对 “最优解中 $a_1$ 必须为 $0$“ 的约束.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在引入人工变量和对目标约束作相应转换后, 就可以将得到的新问题转化为增广矩阵表示, 然后只需先选 $a$ 不为 $0$ 的行作为枢轴, 同时让负参数变为 $1$, 并 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pivot out M&lt;/code&gt;, 就把问题转换成了简易 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Simplex&lt;/code&gt; 问题, 然后就可以用原来的技术求解.&lt;/p&gt;

&lt;p&gt;注意此处有多少个约束式导致原点不为 $0$ 就需要相应引入多少个人工变量 $a$ 和惩罚参数 $M$, 后续也就要分别用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pivoting&lt;/code&gt; 干掉多少个 $M$. 至于为何任何式子中最多只能注入一个人工变量, 由于过于显然笔者拒绝解释.&lt;/p&gt;

&lt;p&gt;详细的注入/转换规则和对应的例子看下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220507220420.png&quot; alt=&quot;20220507220420&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;线性约束问题解空间无界-unbounded-的情形&quot;&gt;线性约束问题解空间无界 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unbounded&lt;/code&gt;) 的情形&lt;/h2&gt;

&lt;p&gt;下面讨论如何处理 &lt;strong&gt;解空间无上界&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Solution Space Unbonded&lt;/code&gt;) 的线性约束问题:&lt;/p&gt;

&lt;p&gt;考虑下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508143622.png&quot; alt=&quot;20220508143622&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示, 两个约束条件代表的可行域 (蓝色部分和红色部分) 虽然有相交区域但 &lt;strong&gt;并未和 $x$ 轴或 $y$ 轴形成封闭区域&lt;/strong&gt;, 问题的可行域并非是封闭图形, 因此不但解的数量没有上限, 还可以观察到变量 $x_1$ 和 $x_2$ 的取值可以是非常大的, &lt;strong&gt;没有上限&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;如果使用常规单纯形法尝试解决该问题的话, 会出现 &lt;strong&gt;所有的候选 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exiting variables&lt;/code&gt; 都有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;negative slack&lt;/code&gt;&lt;/strong&gt; 的情况:&lt;/p&gt;

&lt;p&gt;这实际上意味着, 在本问题中我们已经 &lt;strong&gt;遍历完了所有的可行域顶点&lt;/strong&gt;, 但因为我们尚未找到解 (优化目标行仍然有负系数), 因此我们还没有找到问题的最优可行解. 因此, 该问题是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unbounded&lt;/code&gt; 的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508145646.png&quot; alt=&quot;20220508145646&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上一般地, 如果我们发现问题的增广矩阵表示中某个候选变量的一整列系数都为负值的话, 往往就意味着这个问题是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unbounded Problem&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508145838.png&quot; alt=&quot;20220508145838&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;zero-slack-degeneracy-问题&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Zero Slack&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Degeneracy&lt;/code&gt; 问题&lt;/h2&gt;

&lt;p&gt;进一步地, 我们可能会遇到这样的问题:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220508153142.png&quot; alt=&quot;20220508153142&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示, 在计算备选的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit variables&lt;/code&gt; 时, 计算出有些 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slack&lt;/code&gt; 为 $0$, 注意此时需要 &lt;strong&gt;优先选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slack&lt;/code&gt; 为 $0$ 且变量系数非负, 而且更小的对应行&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;” Towards the end of this video I state that, in the case of a choice of leaving variables with zero slack and a positive coefficient in the column for the entering variable you should chose the variable with the largest positive coefficient - this should be &lt;strong&gt;smallest positive coefficent&lt;/strong&gt; (see the reading).”&lt;/p&gt;

&lt;p&gt;case1: 若无 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zero slack variable with positive coefficient&lt;/code&gt;, 选择 $\theta$ &lt;strong&gt;为正数&lt;/strong&gt; 最小的那个. (注意 $\theta$ 的计算方式: slack variable / coefficient,)
case2: 存在一些 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zero slack variable with positive coefficient&lt;/code&gt;, 此时选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entering variable&lt;/code&gt; 对应列系数 &lt;strong&gt;为正且最小的&lt;/strong&gt; 那一行.&lt;/p&gt;

&lt;h3 id=&quot;相关习题解析-1&quot;&gt;相关习题解析:&lt;/h3&gt;

&lt;p&gt;见笔记 “数据结构与算法： 复习”.&lt;/p&gt;

&lt;h3 id=&quot;補充問題-單純形法的時間複雜度&quot;&gt;補充問題: 單純形法的時間複雜度&lt;/h3&gt;

&lt;p&gt;在最壞情況下: $O(2^n)$ (此時 $n$ 為變量數量. 具體原因是: 在最壞情況下單純形法需要遍歷 “平面” (在高維情況下需要遍歷的是 “超立方體”) 的 &lt;strong&gt;所有節點&lt;/strong&gt;, 而由於 &lt;a href=&quot;https://en.wikipedia.org/wiki/Simplex_algorithm&quot;&gt;該原因&lt;/a&gt; 一個包含 $n$ 個 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base variable&lt;/code&gt; 的單純形法的可行域是 $n$ 維 的, 對應空間內的超立方體有 $2^n$ 個頂點), 因此需要遍歷所有的 $2^n$ 個節點.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220524170046.png&quot; alt=&quot;20220524170046&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Mar 2022 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2022/03/12/Ch6-COMP26120/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/03/12/Ch6-COMP26120/</guid>
        
        <category>课程笔记</category>
        
        <category>数据结构与算法</category>
        
        
      </item>
    
  </channel>
</rss>
