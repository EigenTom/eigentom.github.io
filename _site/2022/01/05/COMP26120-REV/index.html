<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="由于相关法律法规规定, 该内容无法显示.">
    <meta name="keywords" content="菜">
    <meta name="theme-color" content="#333">

    <!-- Open Graph -->
    <meta property="og:title"
        content="数据结构与算法 复习 - 某一般线性空间 | Ramdom Linear Space">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="COMP26120 REVISION
">
    
    <meta property="article:published_time" content=" 2022-01-05T00:00:00Z">
    
    
    <meta property="article:author" content="R1NG">
    
    
    <meta property="article:tag" content="2021">
    
    <meta property="article:tag" content="数据结构和算法">
    
    <meta property="article:tag" content="COMP26120">
    
    
    <meta property="og:image" content="http://localhost:4000https://github.com/KirisameR.png">
    <meta property="og:url" content="http://localhost:4000/2022/01/05/COMP26120-REV/">
    <meta property="og:site_name" content="某一般线性空间 | Ramdom Linear Space">

    <title>数据结构与算法 复习 - 某一般线性空间 | Ramdom Linear Space</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">

    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2022/01/05/COMP26120-REV/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href=" /css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href=" /css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>

    <!-- 数学公式 -->
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            showProcessingMessages: true, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code','a'], //避开某些标签
                ignoreClass:"comment-content" //避开含该Class的标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX","TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    </script>

    

    <!-- Google AdSense -->
    <script data-ad-client="ca-pub-6487568398225121" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">RANDOM LINEAR SPACE</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script>
    <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-chevron-down"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>

    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-algs4.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-algs4.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=2021" title="2021">2021</a>
                        
                        <a class="tag" href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95" title="数据结构和算法">数据结构和算法</a>
                        
                        <a class="tag" href="/archive/?tag=COMP26120" title="COMP26120">COMP26120</a>
                        
                    </div>
                    <h1>数据结构与算法 复习</h1>
                    
                    <h2 class="subheading">REVISION</h2>
                    <span class="meta">Posted by R1NG on January 5, 2022</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<h1 id="comp26120-revision">COMP26120 REVISION</h1>

<h2 id="1-算法设计与复杂度分析">1. 算法设计与复杂度分析</h2>

<p><strong>定义 1.1</strong> (算法)</p>
<blockquote>
  <p>称一系列精确定义地, 用于解决特定计算问题的步骤和流程为 <strong>算法</strong>.</p>
</blockquote>

<p><strong>定义 1.2</strong> (抽象数据类型, <code class="language-plaintext highlighter-rouge">Abstract Data Type</code>, <code class="language-plaintext highlighter-rouge">ADT</code>)</p>
<blockquote>
  <p>称一个对 <strong>抽象化的数据对象本身</strong> , <strong>数据对象之间的关系</strong> 和 <strong>可对数据对象进行的基本操作</strong> 的需求 (定义) 为 <strong>抽象数据类型</strong>, 本质上描述了一个数据模型与定义在这个模型上的一组运算.</p>
</blockquote>

<p><strong>定义 1.3</strong> (数据结构)</p>
<blockquote>
  <p>数据结构是对 <strong>某种抽象数据类型</strong> 的具体实现.</p>
</blockquote>

<p>举例来说, <strong>字典</strong>, <strong>数组</strong>, <strong>栈</strong>, <strong>队列</strong> 都是抽象数据类型, 而动态表 (<code class="language-plaintext highlighter-rouge">Dynamic Array</code>), 链表, 二叉树, 哈希表, 堆等都属于数据结构.</p>

<h3 id="11-算法时间复杂度分析的基本方法和基本定义">1.1 算法时间复杂度分析的基本方法和基本定义</h3>

<h4 id="1-算法时间复杂度的粗略分析-以冒泡排序为例">1. 算法时间复杂度的粗略分析: 以冒泡排序为例</h4>

<p>冒泡排序核心部分的伪代码如下:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>我们的任务是对这段代码片段进行粗略的复杂度分析. 可见在上述代码片段中, 共有 $2$ 个嵌套的循环, 每个循环执行 $n-1$ 次. 由此可以直接判断, 该代码片段的空间复杂度为 $O(n^2)$,</p>

<p>同时注意冒泡排序的核心逻辑: 内层循环的作用是将数组中的 <strong>最大</strong> (或第二大, 第三大,…) 元素从原始位置挨个和后面的元素比较, 将其对换 (“冒泡”) 到数组末尾, 而为了确保数组所有位置上的元素都能被这样检查一遍, 需要将内层循环执行 $n-1$ 次.</p>

<h4 id="2-算法的渐进性能-以线性查找和二分查找为例">2. 算法的渐进性能: 以线性查找和二分查找为例</h4>

<p>下面以 <strong>线性查找</strong> 与 <strong>二分查找</strong> 为例分析并对比两种查找算法的渐进性能:</p>

<p><strong>定义 1.4</strong> (渐进性能)</p>
<blockquote>
  <p>算法的 <strong>渐进性能</strong> 指在给定输入的大小无限逼近于无穷大时, 算法的 <strong>运行时间</strong>, <strong>存储和内存占用</strong> 等系统资源消耗情况等指示算法性能指标的变化情况.</p>
</blockquote>

<p>首先以 <strong>线性查找</strong> 为例:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>显然在最坏情况下, 循环需要执行 $n$ 次才能找到需要的元素, 在最好情况下只需要执行 $1$ 次, 而在一般情况下需要执行 $\frac{n}{2}$ 次. 考虑最坏情况, 线性查找的时间复杂度为 $O(n)$.</p>

<p>然后以 <strong>二分查找</strong> 为例:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>注意二分查找的前提是: 假设待查找的数组已经是经过排序的. 在这一情况下, 二分查找每次都会将数组内的搜索范围 <strong>折半</strong> , 结合一些简单的数学知识可知二分查找的时间复杂度为 $O(\log(n))$.</p>

<p>下面说明我们进行复杂度分析所依赖的计算机简化模型: 在该模型中我们认为:</p>

<ol>
  <li>对 <strong>任何内存地址的访问</strong> 消耗的时间和其他资源 <strong>相同</strong>.</li>
  <li>不考虑指令并行执行的情况.</li>
  <li>除了对函数的调用以外, 所有的指令执行时间 <strong>相同</strong>.</li>
  <li>除非特殊指定, 否则规定字长 (<code class="language-plaintext highlighter-rouge">word size</code>) 为某个常数.</li>
</ol>

<p>换言之, 在计算运行时间时, 我们本质上进行的是对 <strong>基础指令条数</strong> (<code class="language-plaintext highlighter-rouge">Number of primitive steps</code>) 的计数.</p>

<p>而我们所得出的, 表示 <strong>最坏情形</strong> 的结果提供了一个清晰明确的, 对算法运行可能消耗的时间的 <strong>上界</strong>, 它相当于某种 <strong>绝对保证</strong>: 不存在任何情况, 使得算法的运行时间超过它.</p>

<p>而表示 <strong>一般情形</strong> 的结果所提供的是 <strong>算法运行时间的数学期望</strong>, 但需要注意, 随着我们对 “一般” 概念定义的变化, 所得到的结果也会有所不同, 它并不一定能满足真实的情况.</p>

<h4 id="3-研究算法的时间复杂度-以插入排序为例">3. 研究算法的时间复杂度: 以插入排序为例</h4>

<p>我们首先给出插入排序的伪代码:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="n">InsertionSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>插入排序的循环不变量是: 始终认为数组片段 $A[0:i-1]$ 是 <strong>顺序排列</strong> 的, 而每次循环都是一次将新元素 $A[i]$ 插入到这个子数组中同时维护子数组顺序的过程.</p>

<p>我们对插入排序资源消耗的分析如下:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106173409.png" alt="20220106173409" /></p>

<p>其中 $t_i$ 就是在第 $i$ 次循环中, 内层 <code class="language-plaintext highlighter-rouge">while</code> 的执行次数, 本质上就是 $A[j]$ 和 <code class="language-plaintext highlighter-rouge">key</code> 的比较次数.</p>

<p>在最好情况下, 内层循环无需执行; 而在最坏情况下, 所有的内层循环都需要执行. 此时可知:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106173705.png" alt="20220106173705" /></p>

<p>也就是说, 插入排序的时间复杂度为 $O(n^2)$.</p>

<h4 id="4-对基本记号和概念的定义">4. 对基本记号和概念的定义</h4>

<p>最后给出复杂度分析中基本记号和概念的定义:</p>

<p><strong>定义 1.5</strong> (<code class="language-plaintext highlighter-rouge">Big-O</code>)</p>
<blockquote>
  <p>记 $O$ 表示函数具有 <strong>渐进上界</strong> (<code class="language-plaintext highlighter-rouge">Asymptotic upper-bound</code>):</p>

\[O(g(n)) = \{f(n) ~:~ \exists c &gt; 0, n_0 &gt; 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant f(n) \leqslant c \cdot g(n)\}.\]
</blockquote>

<p><strong>定义 1.6</strong> (<code class="language-plaintext highlighter-rouge">Big-Omega</code>)</p>
<blockquote>
  <p>记 $\Omega$ 表示函数具有 <strong>渐进下界</strong> (<code class="language-plaintext highlighter-rouge">Asymptotic lower-bound</code>):</p>

\[\Omega(g(n)) = \{f(n) ~:~ \exists c &gt; 0, n_0 &gt; 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant c \cdot g(n) \leqslant f(n)\}.\]
</blockquote>

<p><strong>定义 1.7</strong> (<code class="language-plaintext highlighter-rouge">Big-Theta</code>)</p>
<blockquote>
  <p>记 $\Theta$ 表示函数具有 <strong>渐进紧确界</strong> (<code class="language-plaintext highlighter-rouge">Asymptotic tight-bound</code>):</p>

\[\Theta(g(n)) = \{f(n) ~:~ \exists c_1, c_2 &gt; 0, n_0 &gt; 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant c_1 \cdot g(n) \leqslant f(n) \leqslant c_2 \cdot g(n)\}.\]
</blockquote>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106174441.png" alt="20220106174441" /></p>

<p>若 $f(n)$ 以 $g(n)$ 为 <strong>渐进紧确界</strong>, 当且仅当 $f(n)$ 同时以 $g(n)$ 为 <strong>渐进上界</strong> 和 <strong>渐进下界</strong>.</p>

<p>我们再给出其他的一些不常用的渐进符号定义:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106174603.png" alt="20220106174603" /></p>

<p>需要注意, 在遇到类似于 “求证某个函数具有渐进上/下界或具有渐进紧确界” 的问题时, 解决问题的基本流程是基于求证假设构建不等式, 通过代数变型求得常数 $c$ (或 $c_1, c_2$) 的取值范围. 若的确可以找到这样的常数, 则说明假设得证. 比如:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116111702.png" alt="20220116111702" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116111911.png" alt="20220116111911" /></p>

<h3 id="12-分治">1.2 分治</h3>

<p><strong>定义 1.8</strong> (分治法)</p>
<blockquote>
  <p>分治法是一种通过将给定问题递归地分划为规模更小的子问题, 并逐一解决这些子问题从而解决给定问题的算法设计思想. 使用分治法思想设计的算法包含三个部分:<br /></p>

  <ol>
    <li>分划 (<code class="language-plaintext highlighter-rouge">Divide</code>): 将原问题拆分成规模更小的子问题.</li>
    <li>解决 (<code class="language-plaintext highlighter-rouge">Conquer</code>): 递归地解决这些拆分出来的小问题.</li>
    <li>联合 (<code class="language-plaintext highlighter-rouge">Combine</code>): 将解决的小问题联合从而形成对原问题的一个解.</li>
  </ol>
</blockquote>

<p>分治问题的复杂度表达式一般形如:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106175014.png" alt="20220106175014" /></p>

<p>其中 <code class="language-plaintext highlighter-rouge">D(n)</code> 为 <strong>问题分划消耗的时间</strong>, <code class="language-plaintext highlighter-rouge">aT(b/b)</code> 为 <strong>划分的 $a$ 个子问题</strong>, <code class="language-plaintext highlighter-rouge">C(n)</code> 为 <strong>将解决的子问题重新组合消耗的时间</strong>.</p>

<p>我们下面以 <strong>归并排序</strong> (<code class="language-plaintext highlighter-rouge">Merge Sort</code>) 为例探讨分治法的运作过程. 归并排序的伪代码如下:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// take 2 sorted subarrays of A and merge them into 1 single sorted array</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">mid</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">infty</span><span class="p">;</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">l</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>可见归并排序的原理是递归地将给定的数组拆分成大小相同的左右两个子数组, 然后对这两个子数组递归地调用自身 (实际上就是对子数组再次进行拆分), 直到将数组拆成只由一个元素组成, 无法再拆为止. 然后再使用 <code class="language-plaintext highlighter-rouge">Merge()</code> 方法, 将这些被拆分的数组两两结合成较大的, 保持顺序的数组, 同样递归地最终合成为原数组的已排序形式.</p>

<p>对归并排序资源消耗的分析如下:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106175936.png" alt="20220106175936" /></p>

<p>显然有:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106180024.png" alt="20220106180024" /></p>

<p>这是一个 <strong>递归表达式</strong>. 我们再举一个例子: <strong>二分查找算法</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="n">BinarySearch</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">BinarySearch</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span> <span class="o">:</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">BinarySearch</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span> <span class="o">:</span><span class="p">],</span> <span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>显然二分查找的递归表达式可以记为:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106180412.png" alt="20220106180412" /></p>

<p>我们将在下一节中介绍求解递归表达式的一般方法: <strong>替代法</strong> (<code class="language-plaintext highlighter-rouge">Substitution Method</code>), <strong>递归法</strong> (<code class="language-plaintext highlighter-rouge">Iteration Method</code>) 和 <strong>主方法</strong> (<code class="language-plaintext highlighter-rouge">Master Method</code>).</p>

<h3 id="13-求解递归表达式">1.3 求解递归表达式</h3>

<ol>
  <li>
    <p>替代法 (<code class="language-plaintext highlighter-rouge">Substitution Method</code>):
 基本原理是 <strong>猜测正确答案的形式 (猜测给定递归表达式的时间复杂度)</strong>, 然后使用 <strong>数学归纳法</strong> (<code class="language-plaintext highlighter-rouge">Induction</code>) 证明这个猜测成立.</p>

    <p>值得注意的是, 在替换法中, 有时我们可以使用适当的技巧简化问题. 如:</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106185458.png" alt="20220106185458" /></p>

    <p>在上面的例子中, 我们 <strong>通过将递归表达式右侧式子中的函数项和加号右侧的代数项替换为正常形式, 成功地将问题转换为我们可以解决的形式.</strong></p>

    <p>而在考虑 “将什么变量替换成什么形式” 的问题时, 可以优先考虑将等号右侧加号右边的项替换为一个 <strong>一次项</strong>, 如将 $\log(n)$ 替换为 $m$. 在此基础上, 再检查经过这样替换后的递归公式是不是被简化成了我们已知的一些常见形式. 如果是的话, 就可以使用替代法求解.</p>

    <p>我们再附上一些指数, 对数, 阶乘和级数的常用性质:</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222251.png" alt="20220106222251" /></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222324.png" alt="20220106222324" /></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116122943.png" alt="20220116122943" /></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222414.png" alt="20220106222414" /></p>

    <p>此外, 我们还可使用定积分近似某个求和表达式:</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116123240.png" alt="20220116123240" /></p>
  </li>
  <li>
    <p>递归法 (<code class="language-plaintext highlighter-rouge">Iteration Method</code>)
递归法的基本原理是: 给定某个算法的递归表达式, 利用表达式自身循环定义的特性, 不断地将等式右侧的表达式使用递归定义 “解压缩”, 直到展现出某个明显的规律为止.</p>

    <p>然后, 尝试将等号右侧已经表现出一定规律的式子中左边函数定义的那部分中的变量进行替换或变形, 从而使该变量等于函数递归表达式定义中 <code class="language-plaintext highlighter-rouge">Base Case</code> 对应的变量值. 这样, 我们就可以将函数定义的那部分直接替换为 <code class="language-plaintext highlighter-rouge">Base Case</code> 对应的式子 (但一般都是个数值), 从而可以直接看出表达式的时间复杂度.</p>

    <p>举例:</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223637.png" alt="20220106223637" /></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223647.png" alt="20220106223647" /></p>
  </li>
  <li>
    <p>使用主定理 <code class="language-plaintext highlighter-rouge">Master Theorem</code></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116123655.png" alt="20220116123655" /></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223856.png" alt="20220106223856" /></p>

    <p>下面给出一些常用结论:</p>

\[\begin{aligned} T(n) &amp;= T(n-1) + O(1) ~~~ \rightarrow \Theta(n) \\ 

 T(n) &amp;= 2T(\frac{n}{2}) + O(1) ~~~~~~~\rightarrow \Theta(n)  \\
 T(n) &amp;= T(\frac{n}{2}) + O(1) ~~~~~~~~~\rightarrow \Theta(\log(n)) \\ 
 T(n) &amp;= T(\frac{n}{2}) + O(n) ~~~~~~~~~\rightarrow \Theta(n\log(n))
 \end{aligned}\]
  </li>
</ol>

<h3 id="14-算法性能的均摊分析">1.4 算法性能的均摊分析</h3>

<p>考虑算法在 <strong>最坏情况下的时间复杂度</strong> 可以给我们算法运行耗时的 <strong>上限</strong>, 但在实际情况下这样的分析往往会 <strong>低谷算法在平均状态下的性能</strong>. 为了从另一个角度对算法的时间复杂度进行评估, 我们引入了 <strong>均摊分析</strong> 的概念.</p>

<p>在 <strong>均摊分析</strong> (<code class="language-plaintext highlighter-rouge">Amortised Analysis</code>) 中, 我们根据具体要求 <strong>构造出一个由一系列操作组成的指令序列</strong> (<code class="language-plaintext highlighter-rouge">sequence</code>), 然后通过计算和讨论这个序列执行耗时的方式研究给定算法在这种情况下的性能.</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116125032.png" alt="20220116125032" /></p>

<p>常用的均摊分析方法有三种:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Aggregate Method</code> 聚合法.</li>
  <li><code class="language-plaintext highlighter-rouge">Accounting Method</code> 审计法.</li>
  <li><code class="language-plaintext highlighter-rouge">Potential Method</code> 势能法.</li>
</ol>

<p>在本课程中, 我们只介绍第一种方法. 聚合法单纯计算序列中每个操作消耗的平均时间, 忽视操作之间可能存在的区别.</p>

<p>(后面提到的, 关于动态增删数组, 栈操作和二进制加减法的例子建议直接看 <code class="language-plaintext highlighter-rouge">Slides</code>, 此处省略)</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220116125609.png" alt="20220116125609" /></p>

<h2 id="2-基本数据结构">2. 基本数据结构</h2>

<p>从本节开始我们将讨论一系列的基本数据结构. 首先回顾 <strong>抽象数据类型</strong> 的基本概念:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155651.png" alt="20220107155651" /></p>

<p>而 <strong>数据结构</strong> 是对 <strong>抽象数据类型</strong> 的 <strong>具体实现</strong>:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155739.png" alt="20220107155739" /></p>

<p>基于这个定义, 动态数组 (<code class="language-plaintext highlighter-rouge">Dynamic Array</code>) 可被定义为由以下的 <code class="language-plaintext highlighter-rouge">API</code> 组成的抽象数据类型:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155919.png" alt="20220107155919" /></p>

<p>链表 (<code class="language-plaintext highlighter-rouge">Linked List</code>) 可被定义为由以下的 <code class="language-plaintext highlighter-rouge">API</code> 组成的抽象数据类型:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155948.png" alt="20220107155948" /></p>

<h3 id="21-哈希表">2.1 哈希表</h3>

<p>哈希表本质上是称为 <strong>字典</strong> 的 <code class="language-plaintext highlighter-rouge">ADT</code> 的一种实现, 是 <strong>数据结构</strong>. 我们首先阐述哈希表数据结构需要满足的 <code class="language-plaintext highlighter-rouge">API</code>:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107160749.png" alt="20220107160749" /></p>

<p>哈希表的基本工作原理是:</p>
<ol>
  <li>在将数据插入表中时, 使用经过精心设计的 <strong>哈希函数</strong>, 基于被插入数据本身的特性得到一个索引, 然后将数据存到实际负责数据存储的数组的索引位置上.</li>
  <li>如果数组的索引位置上已经有数据存储, 也就是发生了 “数据碰撞” (<code class="language-plaintext highlighter-rouge">Collision</code>), 则需要再基于某些规则重新生成一个新的索引, 把数据存到别的位置上去从而避免碰撞.</li>
  <li>在从表中提取数据时, 同样需要使用哈希函数算出索引, 然后按图索骥从数组中找到所需要的数据.</li>
  <li>在实际负责数据存储的数组剩余空间不足时, 需要将其扩容并将原数组中存放的所有元素全部重哈希到更大的新表中.</li>
</ol>

<p>哈希表在理想状态下的读/写性能均为 $O(1)$, 这样的性能优化得益于哈希函数. 在最好情况下, 数据碰撞不会发生, 因而只要计算一次哈希函数就可得到索引.</p>

<p>下面讨论几个哈希表实现中的问题:</p>

<ol>
  <li>
    <p>什么是合理的哈希函数?</p>

    <p>合理的哈希函数应当具有以下性质:</p>

    <p>给定一个映射范围 $n$ 和被映射元素集合 $U$, 哈希函数 $f$ 应该能将 $U$ 中的每个元素 <strong>均匀地</strong> 映射到 $[0, n)$ 的范围上.</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107164137.png" alt="20220107164137" /></p>

    <p>能够正确区分性质相似的数据, 如包含相同元素而排列顺序不同的字符串.</p>
  </li>
  <li>我们无法避免数据碰撞的发生. 一旦发生数据碰撞, 有哪些可行的方法解除数据碰撞?
    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">Separate Chaining</code>: 若多个数据被哈希函数映射到数组的同一个位置上, 则在数组的该位置上存储一个链表, 将这些数据按照插入的先后顺序挂到链表上.</p>

        <p>在实际应用中, 只要哈希函数的选取和重哈希策略得当, 在数组中即使存在数据碰撞, 该位置上的链表也不会很长.</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">Open Addressing</code>: 开放寻址, 在确定出现数据碰撞后使用预定义的规则再生成新的位置, 直到生成的新位置上不存在数据碰撞为止.</p>

        <p>在实际应用中, 如果规则定义不当, 就容易在哈希表中出现数据堆积的情况.</p>

        <p>开放寻址的实现方式一般又有三种:</p>

        <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107172951.png" alt="20220107172951" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>重哈希的策略是什么? 何时需要重哈希?</p>

    <p>重哈希的策略是: 首先调整在哈希函数中涉及到的变量: <strong>存储数组的预期大小</strong>, 然后新建一个大小为预期尺寸的, 比原数组更大的空数组.</p>

    <p>然后, 基于这个 <strong>修改过的哈希函数</strong> (哈希函数中取模时依赖的, 存储数组的预期大小变大了) 将原数组中的所有元素全部重哈希到新数组中.</p>

    <p>丢掉原数组, 将更大的新数组视为哈希表的存储数组.</p>

    <p>我们使用反映哈希表的存储数组的利用率的变量 <strong>负载常数</strong> (<code class="language-plaintext highlighter-rouge">Load Factor</code>) 检测哈希表的使用率, 从而控制何时执行重哈希.</p>

    <p>一般而言, 我们会选定重哈希阈值为 $0.75$.</p>

    <p>如果阈值选定不当, 会导致哈希表的存储数组中可用的剩余空间过少, 以至于在查询和插入数据时哈希函数的数据碰撞次数显著增大, 在最坏情况下对哈希表的搜索操作会退化为线性搜索, 而在一般情况下搜索的时间复杂度仅为 $O(1)$.</p>
  </li>
</ol>

<h3 id="22-搜索树">2.2 搜索树</h3>

<p>我们称形如现实生活中的树木的, 由某一个单一的 (根) 结点向下扩展的, 具有树状拓扑结构的数据结构为 <strong>树</strong>.</p>

<p>一棵 (抽象的) 树由一个 <strong>根结点</strong> , 数个 <strong>叶子结点</strong> 和在此之间的 <strong>内部节点</strong> 构成, 除了根结点外, 每个节点都有一个与之对应的 <strong>父节点</strong>; 而除了叶子结点外, 每个节点都有至少一个 <strong>子节点</strong>.</p>

<p>常见的树有:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107203637.png" alt="20220107203637" /></p>

<p>注意:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Proper Binary Tree</code>/<code class="language-plaintext highlighter-rouge">Full Binary Tree</code> (满二叉树) $\Rightarrow$ 每个节点的度或为 $0$ 或为 $2$.</li>
  <li><code class="language-plaintext highlighter-rouge">Complete Binary Tree</code> (完全二叉树) $\Rightarrow$ 叶子结点只出现在 <strong>最下层或次下层</strong>, 且 <strong>最下层的叶子结点集中出现在树的左部</strong> (除了最后一层外, 其他各层节点数都达到最大, 且最后一层的节点都连续集中在最左边).</li>
  <li><code class="language-plaintext highlighter-rouge">Perfect Binary Tree</code> (完美二叉树) $\Rightarrow$ 在满二叉树的基础上, 所有叶子结点深度均相同.</li>
</ol>

<p>而 <strong>二叉树</strong> 的 <code class="language-plaintext highlighter-rouge">API</code> 表示如下:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107203725.png" alt="20220107203725" /></p>

<p>我们可以使用数组和链表来表示二叉树:</p>

<p>若用数组的形式来构建二叉树, 则节点存在数组中, 节点在数组中的位置对应它在树中的位置, 下标为 $0$ 的节点为根节点, 下标为 $1$ 是根的左节点, $2$ 为根节点的右节点, 依次类推, 从左到右的顺序存储树的每一层, <strong>包括空节点</strong>.</p>

<p>给定某个 <strong>节点</strong> 的索引值为 $x$, 则其左子节点和右子节点的索引值分别为 $2 \cdot x + 1$ 和 $2 \cdot x + 2$, 而其父节点的索引为 $(x-1)/2$.</p>

<p>这种表示方法只有在存储 <strong>完全二叉树</strong> 时效率才会达到最高, 如果用于存储普通二叉树, 由于数组中会包含大量空节点, 因此实际上浪费了存储空间.</p>

<p>若用链表的形式来构建二叉树, 则树的每个节点都是一个链表节点, 依据树中的连接关系而相互链接. 链表法确保不存在任何空节点, 同时在执行插入和删除操作时也有很高的效率, 但是在树中检索的困难度相比数组法高了很多.</p>

<p>注意:</p>

<ol>
  <li>二叉树的 <strong>外部节点</strong> (<code class="language-plaintext highlighter-rouge">Exterior Node</code>) 指他的叶子结点.</li>
  <li>二叉树中结点所拥有的子树个数称为结点的 <strong>度</strong> (<code class="language-plaintext highlighter-rouge">Degree</code>).</li>
  <li>二叉树的 <strong>高度</strong> 为树中所有节点深度的最大值, 也就是从叶子结点到根节点所需要经过的边的 <strong>最大值</strong>, 从 $0$ 起算.</li>
  <li>二叉树中节点的深度为从该节点到树的根节点所需经过边的数量, 也是从 $0$ 起算.</li>
</ol>

<p>再来看二叉树的插入和删除规则:</p>

<ol>
  <li>
    <p>二叉树节点的插入: 只需基于给定的被插入值大小沿着树遍历, 直到在保持不变量基础上, 左子节点 (或对应的, 右子节点) 为空的节点, 然后将新节点作为该节点的左子节点/右子节点插入即可.</p>
  </li>
  <li>
    <p>二叉树节点的删除:</p>
    <ul>
      <li>case 1: 若要被删除的结点为叶子结点或左右子节点均为空, 则直接删除节点的父节点中, 对应指向该节点的指针.</li>
      <li>case 2: 若要被删除的节点有一个子节点 (左子节点或右子节点), 则将该节点的父节点中, 对应的指针指向它的子节点即可.</li>
      <li>
        <p>case 3: 若要被删除的节点有两个子节点, 就需要从这个被删除节点开始执行 <strong>中序遍历</strong> 来找到它的 <strong>后继节点 $p$</strong> (一般是左子树中的最大值所在的节点或右子树的最小值所在的节点).</p>

        <p>然后将被删除节点和 $p$ 的值调换, 递归地执行对节点 $p$ 的删除操作, <strong>这也是删除根节点所对应的状况</strong>:</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>   <span class="nc">TreeNode</span> <span class="nf">delNode</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            
       <span class="c1">// 先遍历到目标节点位置上, 若找不到目标节点则直接返回当前所在节点不改动树</span>
       <span class="k">if</span> <span class="o">(!</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
       <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">delNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
       <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
           <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
       <span class="o">}</span> 
            
       <span class="c1">// 定位到节点后开始删除</span>
       <span class="k">else</span> <span class="o">{</span>
           <span class="c1">// case 1, 2: 直接删除, 子树提升一级</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">root</span> <span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">?</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">:</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
           <span class="c1">// case 3: 找到右子树中被删除节点的后继, 交换值后递归删除后继</span>
               <span class="nc">TreeNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
               <span class="c1">// 中序遍历找后继</span>
               <span class="k">while</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">{</span>
                   <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
               <span class="o">}</span>
               <span class="c1">// 交换节点值</span>
               <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
               <span class="c1">// (递归) 删除后继, 或者后继的后继, ....</span>
               <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delNode</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
           <span class="o">}</span>
       <span class="o">}</span>
       <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
   <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<p>一般对二叉树的检索 (遍历) 方法有三种: 前序, 中序与后序遍历:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204458.png" alt="20220107204458" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204519.png" alt="20220107204519" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204530.png" alt="20220107204530" /></p>

<p>而对树的搜索方式也有两种: <strong>优先沿着子节点检索每一条路径的深度优先搜索</strong> 和 <strong>优先检索同深度下的其他节点, 然后再检索更高深度下子节点的广度优先搜索</strong>.</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204700.png" alt="20220107204700" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107204717.png" alt="20220107204717" /></p>

<p>二叉搜索树相比二叉树, 限定了每个节点和其子节点之间, 节点值大小的相对关系, 使其可以用于表示经过排序的数组, 在二叉搜索树中搜索任意数据在一般情况下可以获得 $O(\log(n))$ 的时间复杂度.</p>

<p>二叉搜索树中的不变量为: 对任何节点, <strong>左子节点的值小于等于父节点的值小于右子节点的值</strong>. 在二叉搜索树中检索某个变量的值, 实际上等价于在一个经过排序的数组中执行二分查找.</p>

<p>但是二叉搜索树的性能受其结构的影响很大. 在一般情况下, 其插入, 检索和删除操作的时间复杂度均为 $O(\log(n))$, 若树是 <strong>不平衡的</strong>, 如: 每个节点的左子树大小远大于右子树, 则在遍历每个节点时都无法有效地剪枝, 因而搜索次数增加, 搜索操作消耗的时间也相应增加. 在最坏情况下, 二叉搜索树的性能可能退化到和线性搜索相当的地步, 三种操作的时间复杂度全部退化为 $O(n)$.</p>

<p><code class="language-plaintext highlighter-rouge">AVL</code> 树 (自平衡二叉树) 是为了解决这一问题而设计出的数据结构. 其主要特征 (也是解决二叉树不平衡导致的性能衰减问题的手段) 是, 它维护了另一个不变量: <strong>节点的平衡度</strong>.</p>

<p><strong>在</strong> <code class="language-plaintext highlighter-rouge">AVL</code> 树中, 节点的平衡度 被定义为: <strong>该节点左右子树高度差的绝对值</strong>, 而 <code class="language-plaintext highlighter-rouge">AVL</code> 树相比二叉搜索树, 所维护的第二个不变量就是, 对树中的任何节点而言, 它的平衡度必须 <strong>小于等于 $1$</strong>, 该属性也被称为 <strong>高度平衡属性</strong> (<code class="language-plaintext highlighter-rouge">Height-Balance Property</code>).</p>

<p>对平衡度的维护确保在 <code class="language-plaintext highlighter-rouge">AVL</code> 树中, 每个节点的所有子树都基本平衡, 而维护平衡度的方式为: 在对 <code class="language-plaintext highlighter-rouge">AVL</code> 树执行每一次插入和删除操作时, 都需要执行 <strong>旋转操作</strong> 以维护该节点的平衡度.</p>

<p>下面考虑 <code class="language-plaintext highlighter-rouge">AVL</code> 树中对节点的旋转操作:</p>

<p><code class="language-plaintext highlighter-rouge">AVL</code> 树的旋转分为 <strong>单旋转</strong> 和 <strong>双旋转</strong>, 任何旋转操作都有两个属性: <strong>旋转轴</strong> 和 <strong>旋转方向</strong>. 旋转轴本质就是 <strong>旋转之后的子树的节点</strong>.</p>

<p>在单旋转中, 旋转轴为 <strong>不满足高度平衡属性的最小树</strong> 的 <strong>根节点对应的子节点</strong> (儿子节点).</p>

<p>在双旋转中, 旋转轴为 <strong>不满足高度平衡属性的最小树</strong> 的 <strong>根节点对应的子节点的子节点</strong> (孙子节点).</p>

<ol>
  <li>
    <p>左旋</p>

    <p>如果观察到某个节点 <strong>不满足高度平衡属性</strong> 且它的 <strong>右子树</strong> 高于左子树, 则需要对该节点执行 <strong>左旋操作</strong>:</p>

    <ol>
      <li>将指向该节点的指针改为指向它的右子树.</li>
      <li>
        <p>将该节点右子树改为它的 <strong>右子树的左子树</strong>:</p>

        <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108113003.png" alt="20220108113003" /></p>
      </li>
    </ol>

    <p>在完成旋转操作后:</p>
    <ol>
      <li>根节点从原节点变为它的右子节点.</li>
      <li>原节点从根节点变为根节点的左子节点.</li>
      <li>根节点的右子节点的左子节点变为根节点的左子节点的右子节点.</li>
    </ol>
  </li>
  <li>
    <p>右旋</p>

    <p>如果观察到某个节点 <strong>不满足高度平衡属性</strong> 且它的 <strong>左子树</strong>高于右子树, 则需要对该节点执行 <strong>右旋操作</strong>:</p>

    <ol>
      <li>将指向该节点的指针改为指向它的左子树.</li>
      <li>
        <p>将该节点左子树改为它的 <strong>左子树的右子树</strong>:</p>

        <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108112733.png" alt="20220108112733" /></p>
      </li>
    </ol>

    <p>在完成旋转操作后:</p>
    <ol>
      <li>根节点从原节点变为它的左子节点.</li>
      <li>原节点从根节点变为根节点的右子节点.</li>
      <li>根节点的左子节点的右子节点变为根节点的右子节点的左子节点.</li>
    </ol>
  </li>
  <li>
    <p>左-右旋</p>

    <p>如果观察到某个节点 <strong>不满足高度平衡属性</strong> 且它的右子节点呈现出 “左重右轻” 的特点, 也就是该节点有一个 <code class="language-plaintext highlighter-rouge">Left-heavy Right subtree</code>, 则需要执行左-右旋: 先以右子节点为轴执行一次右旋让右子结点从 “左重右轻” 变成 “左轻右重”, 然后以原节点为轴执行一次左旋.</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108113803.png" alt="20220108113803" /></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220112094950.png" alt="20220112094950" /></p>
  </li>
  <li>
    <p>右-左旋</p>

    <p>如果观察到某个节点 <strong>不满足高度平衡属性</strong> 且它的左子节点呈现出 “右重左轻” 的特点, 也就是该节点有一个 <code class="language-plaintext highlighter-rouge">Right-heavy Left subtree</code>, 则需要执行右-左旋: 先以左子节点为轴执行一次左旋让左子结点从 “右重左轻” 变成 “左重右轻”, 然后以原节点为轴执行一次右旋.</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108113929.png" alt="20220108113929" /></p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220112095236.png" alt="20220112095236" /></p>
  </li>
</ol>

<p>需要注意的是, 具有 $n$ 个节点的 <code class="language-plaintext highlighter-rouge">AVL</code> 树高度为 $O(\log(n))$.</p>

<h3 id="23-二叉堆-优先序列-跳跃表和并查集">2.3 二叉堆, 优先序列, 跳跃表和并查集</h3>

<p><strong>二叉堆</strong> 是一种特殊的完全二叉树 (注意它不是二叉搜索树), 它在 <strong>作为完全二叉树</strong> 的基础上保持了另一个不变量: <strong>堆序性质</strong>:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108132915.png" alt="20220108132915" /></p>

<p>在构造二叉堆时, 由于二叉堆本身是完全二叉树, 因此可以使用数组实现它而 <strong>基本忽略空间浪费</strong>, 因为完全二叉树的定义决定它除了最后一层以外, 其余的所有节点度或为 $0$ 或为 $2$, 不构成空间浪费. 二叉堆的构造的时间复杂度最坏情况下为 $O(n\log(n))$.</p>

<p>下面考虑最大堆的 <strong>插入</strong>, <strong>删除</strong> 和 <strong>创建</strong>:</p>

<ol>
  <li>
    <p>向堆中插入元素 (本质是新节点的上浮)</p>

    <p>在向现存的二叉堆插入元素时, 我们需要 <strong>将元素添加到表示堆的数组的末尾</strong>, 形式上就是: 将新节点 <strong>作为倒数第二层中, 从左往右数第一个度不为 $2$ 的节点的子节点</strong>.</p>

    <p>在将元素插入后, 我们需要对 <strong>整个堆</strong> 都重新维护它的 <strong>堆序性质</strong>:我们需要 <strong>自底向上</strong> 地依次检查子树的堆序, 直到检查指针上浮到根节点为止.</p>

    <p>记堆包含 $n$ 个元素, 则它是一棵高为 $\log(n)$ 的二叉树, 因此插入函数的时间复杂度为 $O(\log(n))$.</p>
  </li>
  <li>
    <p>从堆中删除元素 (本质是最大堆的最后一个节点的下沉)</p>

    <p>我们只能 <strong>从最大堆中移除最大值</strong>. 在删除根节点后, 堆被拆分成了两棵树. 此时我们需要取 <strong>子树的最后一个节点</strong> 充当树的根节点. 在此之后, <strong>自顶向下</strong> 地递归维护树的 <strong>堆序性质</strong>, 不难看出删除函数的时间复杂度也为 $O(\log(n))$.</p>
  </li>
  <li>
    <p>创建最大堆的本质就是 <strong>自底向上</strong> 地维护某棵二叉树.</p>
  </li>
</ol>

<p><strong>优先序列</strong> 可以表示为某个最大堆, 我们人为规定 <strong>堆中值最大的元素即为优先级最高的元素</strong>. 而 <strong>向优先序列中插入数据</strong> 或 <strong>从优先序列中删除数据</strong> 的方法与 <strong>最大堆中对数据的插入和删除</strong> 是一致的.</p>

<p>优先序列 / 最大堆是基于完全二叉树基础上改进而来的数据结构, 而跳跃表则基于链表 (<code class="language-plaintext highlighter-rouge">Linked List</code>) 基础上改进而来的, 其本质是可以快速查找的 <strong>有序链表</strong>.</p>

<p>对于普通的链表而言, 我们只能从表头开始一个个地遍历查找. 而 <strong>有序链表</strong> 在 <strong>链表</strong> 基础上做的改进就是给链表加上了不同层级的 <strong>索引</strong>, 使我们可以沿着不同层级的索引基于要搜索的值和当前索引节点的值, 快速地跳过中间节点从而接近目标节点. 在存储的数据够多的情况下, 还可以继续构造第二层, 第三层, 甚至更高层的节点, 确保 <strong>每一层节点数是上一层节点数的一半</strong>.</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220108192116.png" alt="20220108192116" /></p>

<p>向跳跃表中插入节点的流程有以下几步:</p>

<ol>
  <li>将新节点插入到原链表中.</li>
  <li>对这个新节点, 使用 <strong>抛硬币</strong> (<code class="language-plaintext highlighter-rouge">Coin Flipping</code>) 的方式决定它将被提升为哪一级的索引:连续 “抛硬币” (模拟抛硬币), 直到抛出 $0$ 为止, 在此之前抛出了多少个 $1$ 就将这个节点提升为哪一级的索引.</li>
</ol>

<p>而从跳跃表中删除节点的流程就相对简单: 从最高级别的索引开始, 依次查找要被删除的目标节点, 并 <strong>逐层找到每一层对应的节点</strong>, 删除每一层中查找到的目标节点. 若该层没有目标节点则在下一层寻找, 若该层只剩下这一个节点则删除这一整层 (除非这一层已经是链表层了).</p>

<p>注意:</p>

<ol>
  <li>
    <p>跳跃表的索引是在 <strong>每一次插入新数据和删除旧数据时</strong> 都被维护的.</p>
  </li>
  <li>
    <p>在一般情况下, 跳跃表的插入与删除的时间复杂度均为 $O(\log(n))$, 而跳跃表的空间复杂度 (所占空间) 为 $O(N)$ (实际上由于每个元素的期望高度为 $2$, 其实际占用空间应该是2N).</p>
  </li>
</ol>

<p>并查集是一种 <strong>树状</strong> 的数据结构, 用于处理一系列 <strong>不相交集合</strong> 的查询与合并问题.</p>

<p>并查集可以用 <code class="language-plaintext highlighter-rouge">AVL</code> 树与哈希表实现, 但唯一切合实际的实现方式是构造两个大小相同的数组: 第一个数组存储实际的数据, 而第二个数组存储每个索引对应的父节点, 拥有相同父节点的所有索引被视为属于同一个集合中, 这个集合用父节点表示. 这样可以在执行 <strong>查询操作</strong> 和 <strong>插入操作</strong> 时提供最高的效率.</p>

<p>并查集的 <code class="language-plaintext highlighter-rouge">API</code> 表 (<code class="language-plaintext highlighter-rouge">ADT</code> 定义) 如下:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109190712.png" alt="20220109190712" /></p>

<p>由于并查集本质是是 <strong>树状结构</strong> 的, 因此若在结构中出现某棵子树过高的情况时, 就有可能明显增加查询时间从而降低数据结构的性能. 这一问题有两种常见的解决方案:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Path Splitting</code>:</p>

    <p>对某并查集的某个元素执行 <code class="language-plaintext highlighter-rouge">Path Splitting</code> 时, 我们将无差别地将 <strong>从该元素到根节点的路径上每个节点的父节点都替换为它的祖父节点</strong>.</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109191754.png" alt="20220109191754" /></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Path Halving</code>:</p>

    <p>对某并查集的某个元素执行 <code class="language-plaintext highlighter-rouge">Path Halving</code> 时, 我们只考虑 <strong>从该元素到根节点的路径上</strong> 以该元素起算的第 $1, 3, 5, …$ 个节点 (也就是该元素, 该元素的祖父节点, 该元素祖父节点的祖父节点, …), 只将它们的父节点都替换为它们的祖父节点.</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109191811.png" alt="20220109191811" /></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Path Compression</code>:</p>

    <p>对某并查集的某个元素执行 <code class="language-plaintext highlighter-rouge">Path Compression</code> 时, 我们将 <strong>从该元素到根节点的路径上经过的每个节点</strong> 的父节点都替换为根节点.</p>

    <p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220109191716.png" alt="20220109191716" /></p>
  </li>
</ol>

<h2 id="3-算法设计技术">3. 算法设计技术</h2>

<p>算法的存在意义是用于解决各种现实问题. 一般而言, 我们需要解决的问题可以被划分为下列五类:</p>

<ol>
  <li>决策性问题: 给定输入, 算法需要给出非黑即白的答案.</li>
  <li>功能性问题: 给定输入, 算法需要给出一个解, 但解的结构按照具体问题不同而变化.</li>
  <li>搜索问题: 给定输入或条件, 算法需要从某个解空间中找出适合的答案.</li>
  <li>计数问题: 算法需要统计解空间中有多少个可行解.</li>
  <li>优化问题: 算法需要从解空间中找出相对最好的解.</li>
</ol>

<h3 id="1-问题分解-动态规划与分治">1. 问题分解: 动态规划与分治</h3>

<p>分治法的定义已经在前文中描述过, 其典例即为二分查找问题.</p>

<p>动态规划和分治算法类似, 也是通过将原问题拆分为多个子问题来将其解决的, 但区别在于, 分治算法的子问题 <strong>彼此无关</strong>, 而动态规划拆分的子问题之间彼此又有共同部分. 其核心即为: 通过将子问题之间共通部分的计算结果存储起来, 在下一次需要的时候直接调用而无需重复计算, 由此 “用空间换时间”.</p>

<p>分治和动态规划都可通过 (或者就是通过) 存储已被解决的子问题实现性能优化的. 而二者的最大差异在于, 分治对子问题的划分是 <strong>自顶向下</strong> 的, 而动规是 <strong>自底向上</strong> 的.</p>

<p>一般而言, 能够使用动态规划求解的问题具有下列的三个性质:</p>

<ol>
  <li>若问题的最优解包含的子问题的解也是最优的, 也就是说该问题具有 <strong>最优子结构</strong>.</li>
  <li>在问题中, 任何状态下的决策都不会影响之前的状态.</li>
  <li>子问题之间相互重叠, 一个子问题在下一阶段的决策中也可能被用到.</li>
</ol>

<h3 id="2-解空间搜索-深度优先-分支定界-贪心搜索和启发式搜索">2. 解空间搜索: 深度优先, 分支定界, 贪心搜索和启发式搜索</h3>

<p>称 <strong>需要在问题的解空间内对问题的解进行搜索</strong> 的问题为 <strong>解空间搜索问题</strong>, 例如 <code class="language-plaintext highlighter-rouge">SAT</code> 问题: 找出某个形为一系列子句的合取的谓词公式的一个解释.</p>

<p>若问题的解是可以通过某种逻辑或顺序依次生成 (<code class="language-plaintext highlighter-rouge">generate</code>) 的, 则也称这样的问题为列举 (<code class="language-plaintext highlighter-rouge">enumeration</code>). 一般地, 在解空间中对问题可行解的列举流程/路径会自然地形成树状结构, 每个叶子结点代表一个可行解, 而不同的路径对应不同解的生成过程. 因此, 对问题的求解就可被理解为在这个搜索树/决策树上的搜索问题.</p>

<p>需要注意: 若给定问题总共有 $n$ 个可能解, 则求解这个问题的列举操作的时间复杂度为 $O(n)$, 因为在最坏情况下使用列举法可能需要将它们全部遍历一遍才能最后找到唯一的可行解.</p>

<p>此外, 单纯的列举操作不需要对部分解进行判断 (这是回溯法的优化方向), 也不存在 “无需考虑全部解” 的情况 (这是分支定界的优化方向).</p>

<p>我们可以使用下列的任一种方式优化求解算法的性能:</p>

<ol>
  <li>回溯算法: 从根节点开始按照某种顺序一步步地构造可行解, 若使用某种组合构造出的解不可行则回退到上一步尝试其他方案, 并继续检查生成的新解. 重复这一过程, 最终只要原问题有解, 就必然可以得到一个可行解.</li>
  <li>分支定界算法: 在回溯算法的基础上, 维护一个 “当前最优解” 并在作出分支选择 (构造解) 时不断比较, 舍弃那些确定无法得到更优解的决策分支 (也就是剪枝 <code class="language-plaintext highlighter-rouge">Pruning</code>).</li>
</ol>

<p>上述的两种算法都具备相同的特征:</p>

<p><img src="https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220110014159.png" alt="20220110014159" /></p>

<p><strong>贪心算法</strong> 的显著特征是, 它在构造可行解时永远会选择 <strong>当前最优</strong> 的决策路径. 在一般情况下, 显然这样的策略不能保证算法一定可以找到 <strong>全局最优解</strong>, 但若我们需要解决的问题具有下列的属性, 则贪心算法是一个很好的选择:</p>

<ol>
  <li>该问题的全局最优解可以表示为多个局部最优解的组合.</li>
  <li>或者该问题解的前部分不能被后部分所影响. (<code class="language-plaintext highlighter-rouge">We can make a series of choices such that we never need to go back and change the choice later</code>)</li>
</ol>

<p><br /></p>

<p>REFERENCE:</p>

<p><a href="https://www.cnblogs.com/cherryljr/p/6669489.html">AVL树的旋转操作详解</a></p>

<p><a href="https://www.jianshu.com/p/21bef3fc3030">最大堆（创建、删除、插入和堆排序）</a></p>

<p><a href="https://www.cs.cornell.edu/courses/cs3110/2012sp/lectures/lec21-amortized/lec21.html">Lecture 21: Amortized Analysis</a></p>

<p><a href="https://algocoding.wordpress.com/2015/05/13/simple-union-find-techniques/">Simple union-find techniques</a></p>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2021/12/31/COMP24011-Ch8/" data-toggle="tooltip" data-placement="top" title="人工智能导论 用于通讯的自然语言">
                        Previous<br>
                        <span>人工智能导论 用于通讯的自然语言</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2022/01/11/COMP23111-REV-Ch1/" data-toggle="tooltip" data-placement="top" title="数据库导论 关系数据库理论">
                        Next<br>
                        <span>数据库导论 关系数据库理论</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
        
                <a data-sort="0109" 
                    href="/archive/?tag=COMP12111"
                    title="COMP12111"
                    rel="10">COMP12111</a>
        
                <a data-sort="0027" 
                    href="/archive/?tag=2021"
                    title="2021"
                    rel="92">2021</a>
        
                <a data-sort="0073" 
                    href="/archive/?tag=%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0"
                    title="课程笔记"
                    rel="46">课程笔记</a>
        
                <a data-sort="0079" 
                    href="/archive/?tag=%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0"
                    title="前端学习"
                    rel="40">前端学习</a>
        
                <a data-sort="0079" 
                    href="/archive/?tag=50P50D"
                    title="50P50D"
                    rel="40">50P50D</a>
        
                <a data-sort="0094" 
                    href="/archive/?tag=2020"
                    title="2020"
                    rel="25">2020</a>
        
                <a data-sort="0104" 
                    href="/archive/?tag=COMP24011"
                    title="COMP24011"
                    rel="15">COMP24011</a>
        
                <a data-sort="0107" 
                    href="/archive/?tag=%E9%80%BB%E8%BE%91%E5%AD%A6"
                    title="逻辑学"
                    rel="12">逻辑学</a>
        
                <a data-sort="0109" 
                    href="/archive/?tag=COMP15111"
                    title="COMP15111"
                    rel="10">COMP15111</a>
        
                <a data-sort="0110" 
                    href="/archive/?tag=%E6%89%A9%E5%B1%95%E8%87%AA%E4%B9%A0"
                    title="扩展自习"
                    rel="9">扩展自习</a>
        
                <a data-sort="0110" 
                    href="/archive/?tag=COMP21111"
                    title="COMP21111"
                    rel="9">COMP21111</a>
        
                <a data-sort="0112" 
                    href="/archive/?tag=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"
                    title="机器学习"
                    rel="7">机器学习</a>
        
                <a data-sort="0112" 
                    href="/archive/?tag=COMP11212"
                    title="COMP11212"
                    rel="7">COMP11212</a>
        
                <a data-sort="0115" 
                    href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"
                    title="数据结构和算法"
                    rel="4">数据结构和算法</a>
        
                <a data-sort="0115" 
                    href="/archive/?tag=COMP15212"
                    title="COMP15212"
                    rel="4">COMP15212</a>
        
                <a data-sort="0115" 
                    href="/archive/?tag=COMP23111"
                    title="COMP23111"
                    rel="4">COMP23111</a>
        
                <a data-sort="0116" 
                    href="/archive/?tag=%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7"
                    title="奇技淫巧"
                    rel="3">奇技淫巧</a>
        
                <a data-sort="0117" 
                    href="/archive/?tag=%E7%99%BD%E6%9E%9C%E5%9B%AD"
                    title="白果园"
                    rel="2">白果园</a>
        
                <a data-sort="0117" 
                    href="/archive/?tag=%E7%AE%97%E6%B3%95"
                    title="算法"
                    rel="2">算法</a>
        
                <a data-sort="0117" 
                    href="/archive/?tag=Lab"
                    title="Lab"
                    rel="2">Lab</a>
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="http://ryanxin.cn">Ryan Xin</a></li>
  
  <li><a href="https://flyhigher.top">Axton.Gay</a></li>
  
  <li><a href="https://graynekocafe.net">GrayNekoBean</a></li>
  
  <li><a href="Gnefil.github.io">Gnefil</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "KirisameR";
    var disqus_identifier = "/2022/01/05/COMP26120 REV";
    var disqus_url = "http://localhost:4000/2022/01/05/COMP26120-REV/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/KirisameR">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; 某一般线性空间 2022
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '/search.json',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>


<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
