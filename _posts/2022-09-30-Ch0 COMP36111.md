---
layout:     post
title:      高级算法设计:基础图算法
subtitle:   Basic Graph Algorithms
date:       2022-09-30
author:     R1NG
header-img: img/post-bg-algs4.jpg
description: 本章将介绍一系列基础图算法.
catalog: true
tags:
    - 课程笔记
    - 数据结构与算法
---

# 图论算法初步

在本章中, 我们将介绍一系列图论相关的基本概念, 并介绍数个图论相关算法.

## 1. 图论相关的基本概念

首先回顾与图论相关的一系列基本概念:

**定义 1.1** (`Directed Graph` 有向图)
> **有向图** 由 **顶点集 $V$** 和 **边集 $E$** 组成, 记为 $(V, E)$. 

**定义 1.2** (`Edges` 边)
> 有向图的 **边** 由两个顶点组成. 若记这两个顶点为 $u, v$, 则这条边可记为 $\{u, v\}$ 或 $(u, v)$. 注意这是对有向图的表示, 因此该表示同时说明: **这是一条从 $u$ 指向 $v$ 的边**.

**定义 1.3** (`Neighbor` 邻居)
> 若边 $e = (u, v)$ 在图 $G$ 中, 称 $u$ 和 $v$ **为邻居**. 

![20220930181906](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930181906.png)

需要注意, 在 **有向图** 中 **不存在从某个顶点指向自身的边**, 也不存在 **起点和终点重合的边**, 更不存在 **没有方向** 的边. 

![20220930182133](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930182133.png)

**定义 1.4** (`in | out degree` 有向图的如度和出度)
> 考虑图中的任意顶点 $v$, 称图中 **以 $v$ 为目标顶点的边的数量** 为该顶点的 **入度**, 而 **以 $v$ 为起始顶点的边的数量** 为它的 **出度**.

![20220930182548](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930182548.png)

**定义 1.5** (`Path` 路径)
> 称图 $G$ 中的 **路径** 为一系列 **不同的顶点 $v_0, \cdots, v_k$ 组成的序列**, 其中 $(v_0, v_1), \cdots, (v_{k-1}, v_k)$ 等 **都是图 $G$ 中的边**. 
>
> 换言之, 路径就是图中一系列依次首尾相连的边的顶点依次组成的序列. 

**定义 1.6** (`Reachability` 可达性)
> 考虑图 $G$ 中的一对顶点 $s, t$, 称 **从 $s$ 到 $t$ 是可达的**, 若在图中存在一条 **从 $s$ 到 $t$ 的路径**.

**定义 1.7** (`Strongly Connected` 强连通)
> 称某个有向图是 **强连通** 的, 若它的 **任意一对顶点** 都是 **互相可达** 的.

![20220930183359](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930183359.png)

在了解了上述概念后, 我们不难关于有向图提出下列的两个问题:

1. `st-CON`:
   
   `给定某个有向图 $(V, E)$ 和图中的两个顶点 $s, t \in V$, 确定从 $s$ 到 $t$ 是否是 **可达的**. 它可以通过深度优先算法解决.
   
   ![20220930183631](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930183631.png)

2. `STRONG CONNECTIVITY`:
   
   给定某个有向图 $(V, E)$, 确定它是否是强连通的.

   ![20220930183809](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930183809.png)

    
## 2. 拓扑排序

下面我们讨论 **拓扑排序**.

首先需要继续定义图中 **环** 的概念:

**定义 2.1** (`Cycle` 环)
> 称有向图 $G$ 中的 **环** 为一个 **首尾相连的路径**. 即: 
> 
> 该路径可被表示为 $v_0, \cdots, v_k, ~~ k \geqslant 1$ 的形式, 且 $(v_k, v_0)$ 同样为一条边. 
> 
> 若图 $G$ 中存在 **至少一个环**, 则称其是 **有环图** (`Cyclic`), 反之称其为 **无环图** (`Acyclic`).

![20220930184436](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930184436.png)

自然地我们想要解决下列的问题:

给定一个 **有向图 $G$**, 确定它是 **有环的** 还是 **无环的**.

![20220930184455](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930184455.png)

结合第一节中介绍的定义 **度**, 不难得出下面的引理:

**引理 2.1**
> 若有向图 $G$ 是 **无环** 的, 则在图中 **必存在某个入度为 $0$ 的顶点**.

**证明**:
不难考虑有向图的对立: **树**. 显然树的 **根节点** 就是入度为 $0$ 的. $\blacksquare$

下面引入 **拓扑排序** 的定义:

**定义 2.2** (`Topological Sort` 拓扑排序)
> 称 **拓扑排序** 为某个 **有向图 $G$** 上 **对它顶点的排序** 
> 
> $$u_0, \cdots, u_{n-1}$$ 
> 
> 使得对任何边
> 
> $$(u_i, u_j)$$
> 
> 都有 $i < j$.

![20220930185409](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930185409.png)

我们可将拓扑排序定义为下列的算法问题:

![20220930185523](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220930185523.png)

可知: 任何有环图都不存在拓扑排序, 且任何无环图都必有一个拓扑排序.

拓扑排序的伪代码如下:

~~~python
def topSort(G):
    # 计算图中每个顶点的入度
    G.inDeg = handleIndegreeComputation(G)
    
    # 栈 S 用于存储所有已发现但尚未使用深度优先遍历到的顶点
    S = []
    
    # i 在此处作为索引
    i = 0

    # sort 存储拓扑排序的最终结果
    sort = [None for _ in range(len(G.vertices))]

    # 使用深度优先搜索, 首先考虑所有起始点 (即入度为 0 的点)
    for v in G.vertices:
        if G.inDeg(v) == 0: S.push(v)
    
    while len(S) != 0:
        # 依次考虑栈首的点 (深度优先)
        v = S.pop()
        sort[i] = v
        i += 1
        
        # 遍历点 v 的每一个子节点, 在子节点的入度为 0 时再去遍历它, 确保排序的顺序性
        for w in G.edges(v):
            G.inDeg(w) -= 1
            if G.inDeg(w) == 0:
                S.push(w)
    
    # 在全部遍历后, 若所有节点的入度都可变为 0 则说明该图是无环的
    if i == n:
        return sort
    else:
        return "Impossible"
~~~











## 3. `Kosaraju` 算法

## 4. 无向图的基本概念

## 5. 


