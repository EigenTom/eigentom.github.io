---
layout:     post
title:      数据结构与算法 复习
subtitle:   REVISION
date:       2022-01-05
author:     R1NG
header-img: img/post-bg-algs4.jpg
description: 数据结构与算法期末复习
catalog: true
tags:
    - 2021
    - 数据结构和算法
    - COMP26120
---

# COMP26120 REVISION

## 1. 算法设计与复杂度分析

**定义 1.1** (算法) 
> 称一系列精确定义地, 用于解决特定计算问题的步骤和流程为 **算法**.

**定义 1.2** (抽象数据类型)
> 称一个对 **抽象化的数据对象本身** , **数据对象之间的关系** 和 **可对数据对象进行的基本操作** 的需求 (定义) 为 **抽象数据类型**, 本质上描述了一个数据模型与定义在这个模型上的一组运算. 

**定义 1.3** (数据结构)
> 数据结构是对 **某种抽象数据类型** 的具体实现.

### 1.1 算法时间复杂度分析的基本方法和基本定义


#### 1. 算法时间复杂度的粗略分析: 以冒泡排序为例

冒泡排序核心部分的伪代码如下:

~~~c
for(i=0; i<N-1; i++) {
    for(j=0; j<N-1; j++) {
        if (a[j] > a[j+1]) {
            t = a[j];
            a[j] = a[j+1];
            a[j+1] = t;
        }
    }
}
~~~

我们的任务是对这段代码片段进行粗略的复杂度分析. 可见在上述代码片段中, 共有 $2$ 个嵌套的循环, 每个循环执行 $n-1$ 次. 由此可以直接判断, 该代码片段的空间复杂度为 $O(n^2)$.

#### 2. 算法的渐进性能: 以线性查找和二分查找为例

下面以 **线性查找** 与 **二分查找** 为例分析并对比两种查找算法的渐进性能: 

**定义 1.4** (渐进性能)
> 算法的 **渐进性能** 指在给定输入的大小无限逼近于无穷大时, 算法的 **运行时间**, **存储和内存占用** 等系统资源消耗情况等指示算法性能指标的变化情况.

首先以 **线性查找** 为例:

~~~c
j=1;

while (j <= A.length && A[j] != q) {
    j++;
}

if (j < length(A)) {
    return j;
} else {
    return null;
}
~~~

显然在最坏情况下, 循环需要执行 $n$ 次才能找到需要的元素, 在最好情况下只需要执行 $1$ 次, 而在一般情况下需要执行 $\frac{n}{2}$ 次. 考虑最坏情况, 线性查找的时间复杂度为 $O(n)$.

然后以 **二分查找** 为例:

~~~c
l = 1;
r = A.length;
while (l <= r) {
    j = l + (r - l)/2;
    if (A[j] == target) {
        return j;
    } else if (A[j] > target) {
        r = j - 1;
    } else {
        l = j + 1;
    }
}
return null;
~~~

注意二分查找的前提是: 假设待查找的数组已经是经过排序的. 在这一情况下, 二分查找每次都会将数组内的搜索范围 **折半** , 结合一些简单的数学知识可知二分查找的时间复杂度为 $O(\log(n))$.

下面说明我们进行复杂度分析所依赖的计算机简化模型: 在该模型中我们认为:

1. 对任何内存地址的访问消耗的时间和其他资源 **相同**.
2. 不考虑指令并行执行的情况.
3. 除了对函数的调用以外, 所有的指令执行时间 **相同**.


#### 3. 研究算法的时间复杂度: 以插入排序为例

我们首先给出插入排序的伪代码:

~~~c
InsertionSort(A, n) {
    for (i=2; i<n; i++) {
        key = A[i];
        j = i-1;
        while (j>0 && A[j] > key) {
            A[j+1] = A[j];
            j -= 1;
        }
        A[j+1] = key;
    }
}
~~~

插入排序的循环不变量是: 始终认为数组片段 $A[0:i-1]$ 是 **顺序排列** 的, 而每次循环都是一次将新元素 $A[i]$ 插入到这个子数组中同时维护子数组顺序的过程.

我们对插入排序资源消耗的分析如下:

![20220106173409](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106173409.png)

其中 $t_i$ 就是在第 $i$ 次循环中, 内层 `while` 的执行次数, 本质上就是 $A[j]$ 和 `key` 的比较次数.

在最好情况下, 内层循环无需执行; 而在最坏情况下, 所有的内层循环都需要执行. 此时可知:

![20220106173705](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106173705.png)

也就是说, 插入排序的时间复杂度为 $O(n^2)$.

#### 4. 对基本记号和概念的定义

最后给出复杂度分析中基本记号和概念的定义:

**定义 1.5** (`Big-O`)
> 记 $O$ 表示函数具有 **渐进上界** (`Asymptotic upper-bound`):
> 
> $$O(g(n)) = \{f(n) ~:~ \exists c > 0, n_0 > 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant f(n) \leqslant c \cdot g(n)\}.$$

**定义 1.6** (`Big-Omega`)
> 记 $\Omega$ 表示函数具有 **渐进下界** (`Asymptotic lower-bound`):
> 
> $$\Omega(g(n)) = \{f(n) ~:~ \exists c > 0, n_0 > 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant c \cdot g(n) \leqslant f(n)\}.$$

**定义 1.7** (`Big-Theta`)
> 记 $\Theta$ 表示函数具有 **渐进紧确界** (`Asymptotic tight-bound`):
> 
> $$\Theta(g(n)) = \{f(n) ~:~ \exists c_1, c_2 > 0, n_0 > 0, ~\text{s.t.} ~ \forall n \geqslant n_0; 0 \leqslant c_1 \cdot g(n) \leqslant f(n) \leqslant c_2 \cdot g(n)\}.$$

![20220106174441](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106174441.png)

我们再给出其他的一些不常用的渐进符号定义:

![20220106174603](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106174603.png)

### 1.2 分治

**定义 1.8** (分治法)
> 分治法是一种通过将给定问题递归地分划为规模更小的子问题, 并逐一解决这些子问题从而解决给定问题的算法设计思想. 使用分治法思想设计的算法包含三个部分:<br>
> 
> 1. 分划 (`Divide`): 将原问题拆分成规模更小的子问题.
> 2. 解决 (`Conquer`): 递归地解决这些拆分出来的小问题.
> 3. 联合 (`Combine`): 将解决的小问题联合从而形成对原问题的一个解.

分治问题的复杂度表达式一般形如:

![20220106175014](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106175014.png)

我们下面以 **归并排序** (`Merge Sort`) 为例探讨分治法的运作过程. 归并排序的伪代码如下:

~~~c
MergeSort(A, l, r) {
    if (l < r) {
        mid = l + (r-l)/2;
        MergeSort(A, l, mid);
        MergeSort(A, mid+1, r);
        Merge(A, l, r, mid);
    }
}

Merge(A, l, r, mid) {
    // take 2 sorted subarrays of A and merge them into 1 single sorted array
    n1 = mid-l+1
    n2 = r-mid

    for (i=0; i<n1; i++) {
        L[i] = A[l+i];
    }
    for (j=0; j<n2; j++) {
        R[j] = A[mid+1+j];
    }
    L[n1], R[n2] = +infty;
    i, j=0;
    for (k=l; k<r+1; k++) {
        if (L[i] <= R[i]) {
            A[k] = L[i++];
        } else {
            A[k] = R[j++];
        }
    }

}
~~~

可见归并排序的原理是递归地将给定的数组拆分成大小相同的左右两个子数组, 然后对这两个子数组递归地调用自身 (实际上就是对子数组再次进行拆分), 直到将数组拆成只由一个元素组成, 无法再拆为止. 然后再使用 `Merge()` 方法, 将这些被拆分的数组两两结合成较大的, 保持顺序的数组, 同样递归地最终合成为原数组的已排序形式.

对归并排序资源消耗的分析如下:

![20220106175936](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106175936.png)

显然有:

![20220106180024](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106180024.png)

这是一个 **递归表达式**. 我们再举一个例子: **二分查找算法**:

~~~c
BinarySearch(A, target) {
    if (A.length == 1) {
        return A[0] == target;
    }

    mid = A.length/2;
    if (target < A[mid]) {
        BinarySearch(A[0 : mid-1], q);
    } else {
        BinarySearch(A[mid :], q);
    }
}
~~~

显然二分查找的递归表达式可以记为:

![20220106180412](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106180412.png)

我们将在下一节中介绍求解递归表达式的一般方法.

### 1.3 求解递归表达式

1. 替代法 (`Substitution Method`):
    基本原理是 **猜测正确答案的形式 (猜测给定递归表达式的时间复杂度)**, 然后使用 **数学归纳法** (`Induction`) 证明这个猜测成立

    值得注意的是, 在替换法中, 有时我们可以使用适当的技巧简化问题. 如:

    ![20220106185458](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106185458.png)

    在上面的例子中, 我们 **通过将递归表达式右侧式子中的函数项和加号右侧的代数项替换为正常形式, 成功地将问题转换为我们可以解决的形式.**

    而在考虑 “将什么变量替换成什么形式” 的问题时, 可以优先考虑将等号右侧加号右边的项替换为一个 **一次项**, 如将 $\log(n)$ 替换为 $m$. 在此基础上, 再检查经过这样替换后的递归公式是不是被简化成了我们已知的一些常见形式. 如果是的话, 就可以使用替代法求解.

    我们再附上一些指数, 对数和级数的常用性质:

    ![20220106222251](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222251.png)

    ![20220106222324](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222324.png)

    ![20220106222414](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106222414.png)

2. 递归法 (`Iteration Method`)
   递归法的基本原理是: 给定某个算法的递归表达式, 利用表达式自身循环定义的特性, 不断地将等式右侧的表达式使用递归定义 “解压缩”, 直到展现出某个明显的规律为止.

   然后, 尝试将等号右侧已经表现出一定规律的式子中左边函数定义的那部分中的变量进行替换或变形, 从而使该变量等于函数递归表达式定义中 `Base Case` 对应的变量值. 这样, 我们就可以将函数定义的那部分直接替换为 `Base Case` 对应的式子 (但一般都是个数值), 从而可以直接看出表达式的时间复杂度.

   举例:

   ![20220106223637](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223637.png)

   ![20220106223647](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223647.png)

3. 使用主定理 `Master Theorem`
   
    ![20220106223856](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220106223856.png)

## 2. 基本数据结构

从本节开始我们将讨论一系列的基本数据结构. 首先回顾 **抽象数据类型** 的基本概念:

![20220107155651](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155651.png)

而 **数据结构** 是对 **抽象数据类型** 的 **具体实现**:

![20220107155739](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155739.png)

基于这个定义, 动态数组 (`Dynamic Array`) 可被定义为由以下的 `API` 组成的抽象数据类型:

![20220107155919](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155919.png)

链表 (`Linked List`) 可被定义为由以下的 `API` 组成的抽象数据类型:

![20220107155948](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107155948.png)

### 2.1 哈希表

首先阐述哈希表数据结构需要满足的 `API`:

![20220107160749](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107160749.png)

哈希表的基本工作原理是: 
1. 在将数据插入表中时, 使用经过精心设计的 **哈希函数**, 基于被插入数据本身的特性得到一个索引, 然后将数据存到实际负责数据存储的数组的索引位置上.
2. 如果数组的索引位置上已经有数据存储, 也就是发生了 “数据碰撞” (`Collision`), 则需要再基于某些规则重新生成一个新的索引, 把数据存到别的位置上去从而避免碰撞.
3. 在从表中提取数据时, 同样需要使用哈希函数算出索引, 然后按图索骥从数组中找到所需要的数据.
4. 在实际负责数据存储的数组剩余空间不足时, 需要将其扩容并将原数组中存放的所有元素全部重哈希到更大的新表中.

哈希表在理想状态下的读/写性能均为 $O(1)$, 这样的性能优化得益于哈希函数. 在最好情况下, 数据碰撞不会发生, 因而只要计算一次哈希函数就可得到索引.

下面讨论几个哈希表实现中的问题:

1. 什么是合理的哈希函数?

    合理的哈希函数应当具有以下性质:
    
    给定一个映射范围 $n$ 和被映射元素集合 $U$, 哈希函数 $f$ 应该能将 $U$ 中的每个元素 **均匀地** 映射到 $[0, n)$ 的范围上.

    ![20220107164137](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107164137.png)

    能够正确区分性质相似的数据, 如包含相同元素而排列顺序不同的字符串.

2. 我们无法避免数据碰撞的发生. 一旦发生数据碰撞, 有哪些可行的方法解除数据碰撞?
    * `Separate Chaining`: 若多个数据被哈希函数映射到数组的同一个位置上, 则在数组的该位置上存储一个链表, 将这些数据按照插入的先后顺序挂到链表上.

        在实际应用中, 只要哈希函数的选取和重哈希策略得当, 在数组中即使存在数据碰撞, 该位置上的链表也不会很长.

    * `Open Addressing`: 开放寻址, 在确定出现数据碰撞后使用预定义的规则再生成新的位置, 直到生成的新位置上不存在数据碰撞为止. 

        在实际应用中, 如果规则定义不当, 就容易在哈希表中出现数据堆积的情况.

        开放寻址的实现方式一般又有三种:

        ![20220107172951](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220107172951.png)

3. 重哈希的策略是什么? 何时需要重哈希?

    重哈希的策略是: 首先调整在哈希函数中涉及到的变量: **存储数组的预期大小**, 然后新建一个大小为预期尺寸的, 比原数组更大的空数组. 

    然后, 基于这个 **修改过的哈希函数** (哈希函数中取模时依赖的, 存储数组的预期大小变大了) 将原数组中的所有元素全部重哈希到新数组中.

    丢掉原数组, 将更大的新数组视为哈希表的存储数组.

    我们使用反映哈希表的存储数组的利用率的变量 **负载常数** (`Load Factor`) 检测哈希表的使用率, 从而控制何时执行重哈希.

    一般而言, 我们会选定重哈希阈值为 $0.75$. 

    如果阈值选定不当, 会导致哈希表的存储数组中可用的剩余空间过少, 以至于在查询和插入数据时哈希函数的数据碰撞次数显著增大, 在最坏情况下对哈希表的搜索操作会退化为线性搜索, 而在一般情况下搜索的时间复杂度仅为 $O(1)$.

### 2.2 搜索树



### 2.3 优先序列

### 2.4 并查集


## 3. 算法设计技术

### 3.1 暴力求解

### 3.2 贪心算法

### 3.3 动态规划


