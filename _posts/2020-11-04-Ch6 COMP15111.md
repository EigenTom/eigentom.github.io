---
layout:     post
title:      Ch6 线性数据结构和位运算 
subtitle:   Addressing the addresses
date:       2020-11-04
author:     R1NG
header-img: img/test-bg.png
description: 本章简介基于汇编语言的线性数据结构构造与访问, 以及位运算. 
catalog: true
tags:
    - COMP15111
    - 课程笔记
    - 2020
---


# Ch6 线性数据结构和位运算

Motivation: 
1. 使用合适的寻址模式访问线性数据结构
2. 类 `C` 语言的字符串
3. 转换表
4. 位运算和旋转


## 1. 字符串和寻址模式

### 1.1 字符串
首先, 简介 `Python` 型字符串和 `C` 型字符串. 

`Python` 型字符串中包含字符和一些额外信息, 如字符串长度, 字符串哈希值等. 

`C` 型字符串包含字符, 每个字符长为一个字节 ($8$ 位), 并且最后以 **数字 $0$**结尾. (注意: 不是字符 $'0'$!)

对于字符串, 我们有一系列的基本操作:
1. `String.length`

    计算某个字符串的长度: 


    For Python: 
    ```
    len = len(message)
    ```
    For C:
    ```
    len = 0;
    for (i = 0; len[i] != 0; i++);
    len = i;
    ```
    For ARM Assembly (NOT Optimised):
    ```
            ADRL    R1, message
            MOV     R2, #0          // R2 used as the loop counter i
    again   LDRB    R0, [R1,R2]    // Register offset addressing
            ADD     R2, R2, #1
            CMP     R0, #0
            BNE     again
            SUB     R2, R2, #1      // Why? Can this be avoided? 
            STR     R2, length
    ```
    For ARM Assembly (Optimized):
    ```
            ADRL    R1, message
            MOV     R2, #0          // R2 = i
    again   LDRB    R0, [R1, R2]    // Register offset
            CMP     R0, #0
            ADDNE   R2, R2, #1
            BNE     again
            STR     R2, length
    ```

    For ARM Assembly (Optimized for register use)
    ```
    // Use Post-Indexed and save a register
            ADDRL   R1, message       // Pointer to a char
    again   LDRB    R0, [R1], #1      // Post Increment
            CMP     R0, #0            // Look for 0
            BNE again
            ADRL    R0, message
            SUB     R0, R1, R0
            SUB     R0, R0, #1
            STR     R0, length
    // Saved a register, but less concise or readable...
    ```

2. `String.indexOf`
    在给定字符串中寻找给定字符第一次出现的位置:

    For Python:
    ```
    msg.find(‘e’)
    ```

    For ARM Assembly:
    ```
            ADRL    R1, message
    again   LDRB    R0, [R1], #1
            CMP     R0, #’e’          //look for ’e’ instead of 0 
            BNE     again
            ADRL    R0, message
            SUB     R0, R1, R0
            SUB     R0, R0, #1
            STR     R0, find
    ```

<br>

### 1.2 列表
我们以颜色表为例介绍列表: 

显示设备可以输出大量不同的颜色. 广泛普及的显示屏的色彩输出范围至少都是数百万种颜色以上. 对于采用了位映射模式 (`Bit-Mapped`) 的显示设备而言, 它的每一个像素都可以显示一种不同的颜色. 

考虑一个由三原色组成的像素点. 对于这样的一个像素点, 它的三原色输出强度均可被分别控制 (如: 每种颜色的强度可分为 `256` 级), 因而表示这样的一个像素点需要一个字节, 也就是八个位的存储空间. 

用于查表的 `ARM` 代码: 

![20201107212755](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201107212755.png)


在内存中, 指令和数据是这样存储的: 
![20201107215236](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201107215236.png)

需要注意的是: 由于在该程序中我们使用 `DEFB` 定义变量, 为该变量分配的存储空间固定为 `32位`, 也就是 $4$ 个字节, 转换为 $16$ 位无符号整数后, 它的位数就是 $8$ ($2^{32} = 4 * (16)^2$). 而对于三通道的颜色表示法, 每一个通道的表示需要占用长为 $2$ 的十六进制位, 因此不管是什么颜色, 表示为十六进制无符号整数都是 `0x00??????`. 而众所周知, `ARM` 架构采用小端序, 因此在该表中, 所有的数据化为 `16` 进制无符号整数后, 其最高两位均空置为 `0`. 

<br>
<br>

## 2. 位运算

位运算是对以二进制形式, 存储在计算机内存中的整数的二进制位进行的操作. 位运算通过对内存数据直接进行操作, 而无需转换为十进制后再运算, 因此运算速度极快. 通过使用合适的位运算, 我们可以对程序进行有效的优化. 

### 2.1 位运算-逻辑运算
1. `and` 按位与运算<br>
   运算规则和逻辑与运算相同, 用于二进制取位操作:<br>
   [例] 对一个二进制整数 `and 1` 的结果就是取该二进制整数的最末位. 所有的二进制奇数最低位均为 $1$, 而二进制偶数的最低位均为 $0$. 通过取某个二进制整数的最低位, 我们可以立即判断该数字的奇偶性. 


2. `or` 按位或运算<br>
   运算规则和逻辑或运算相同. <br>
   [例] `or` 运算通常用于对二进制整数的特定位进行无条件赋值. 如, 对一个二进制整数 `or 1` 的结果即为将其末位强行变为 $1$. 利用这一原理, 我们可以使用 `or` 运算, 通过对其和 $1$ 执行一次 `or` 运算后再减去 $1$, 即可将一个二进制整数变为最接近它的偶数. 

3. `not` 按位非运算<br>
   运算规则和逻辑非运算相同. 由于其定义即为将被操作数的每个位全部取反, 因此在进行按位非运算时需要注意被操作数是否为含符号整数. 若被执行数为一个无符号二进制整数, 则得到的结果即为该数和该类型上界的差. 

4. `xor` 按位异或运算<br>
   运算规则和逻辑异或运算相同. <br>
   [例] 按位异或运算常用于对二进制整数的特定位进行取反操作. 并且, 取反运算与其本身互为逆运算, 亦即以任何一个二进制整数和另一个整数作为操作符, 连续执行两次异或运算的结果为其本身. 因此, 异或运算可用于简单的加密:
   ```
   114514 ^ 1919810 = 1897488
   1897488 ^ 114514 = 1919810
   1897488 ^ 1919810 = 114514
   ```    
   此外, 我们还可以使用异或运算进行变量的交换:
   ```
   def swap(x, y)
       x = x ^ y
       y = x ^ y
       x = x ^ y
   ```

5. `LSL` 逻辑左移位运算<br>
   该运算由两个操作符组成: `a LSL b` 即为: 将二进制整数 $a$ 左移 $b$ 位. 我们常用逻辑左移代替涉及 $2^n$ 的乘法运算. <br>
   [例] `11011111101010010 (bin) = 114514 (dec)`, `114514 LSL 2 = 458056`, 亦即: `a LSL b = a * 2^b`. 


6. `LSR` 逻辑右移位运算<br>
   和逻辑左移位运算相似, 逻辑右移位运算表示将二进制整数向右移位, 相当于将二进制整数除以 $2$ 的幂, 常用于代替特定的除法运算. 
   
### 2.2 快速无符号二进制整数乘法/除法
见 “逻辑左移位运算” 和 "逻辑右移位运算". 


### 2.3 旋转操作

旋转操作就是循环移位运算. 

### 2.4 `ARM` 移位指令

|助记符|实际含义|行为|
|-|-|-|
|`LSL #n`| 逻辑左移 $n$ 位|将有符号或无符号二进制整数乘以 $2^n$|
|`LSR #n`| 逻辑右移 $n$ 位 | 将无符号二进制整数除以 $2^n$|
|`ROR #n`|右旋转 $n$ 位|旋转位: `lsb` $\rightarrow$ `Carry`|
|`RRX #n`|右旋转并扩展 $n$ 位|围绕 `Carry` 位旋转位|

<br>

参考:

[位运算简介及实用技巧（一）：基础篇](http://www.matrix67.com/blog/archives/263)<br>
[人造奇迹——二进制位运算的运用](https://www.cnblogs.com/oyking/p/3701936.html)