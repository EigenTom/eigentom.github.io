---
layout:     post
title:      Ch6 线性数据结构和位运算 
subtitle:   Addressing the addresses
date:       2020-11-04
author:     R1NG
header-img: img/test-bg.png
description: 本章简介基于汇编语言的线性数据结构构造与访问, 以及位运算. 
catalog: true
tags:
    - COMP15111
    - 课程笔记
    - 2020
---


# Ch6 线性数据结构和位运算

Motivation: 
1. 使用合适的寻址模式访问线性数据结构
2. 类 `C` 语言的字符串
3. 转换表
4. 位运算和旋转


## 1. 字符串和寻址模式

### 1.1 字符串
首先, 简介 `Python` 型字符串和 `C` 型字符串. 

`Python` 型字符串中包含字符和一些额外信息, 如字符串长度, 字符串哈希值等. 

`C` 型字符串包含字符, 每个字符长为一个字节 ($8$ 位), 并且最后以 **数字 $0$**结尾. (注意: 不是字符 $'0'$!)

对于字符串, 我们有一系列的基本操作:
1. `String.length`

    计算某个字符串的长度: 


    For Python: 
    ```
    len = len(message)
    ```
    For C:
    ```
    len = 0;
    for (i = 0; len[i] != 0; i++);
    len = i;
    ```
    For ARM Assembly (NOT Optimised):
    ```
            ADRL    R1, message
            MOV     R2, #0          // R2 used as the loop counter i
    again   LDRB    R0, [R1,R2]    // Register offset addressing
            ADD     R2, R2, #1
            CMP     R0, #0
            BNE     again
            SUB     R2, R2, #1      // Why? Can this be avoided? 
            STR     R2, length
    ```
    For ARM Assembly (Optimized):
    ```
            ADRL    R1, message
            MOV     R2, #0          // R2 = i
    again   LDRB    R0, [R1, R2]    // Register offset
            CMP     R0, #0
            ADDNE   R2, R2, #1
            BNE     again
            STR     R2, length
    ```

    For ARM Assembly (Optimized for register use)
    ```
    // Use Post-Indexed and save a register
            ADDRL   R1, message       // Pointer to a char
    again   LDRB    R0, [R1], #1      // Post Increment
            CMP     R0, #0            // Look for 0
            BNE again
            ADRL    R0, message
            SUB     R0, R1, R0
            SUB     R0, R0, #1
            STR     R0, length
    // Saved a register, but less concise or readable...
    ```

2. `String.indexOf`
    在给定字符串中寻找给定字符第一次出现的位置:

    For Python:
    ```
    msg.find(‘e’)
    ```

    For ARM Assembly:
    ```
            ADRL    R1, message
    again   LDRB    R0, [R1], #1
            CMP     R0, #’e’          //look for ’e’ instead of 0 
            BNE     again
            ADRL    R0, message
            SUB     R0, R1, R0
            SUB     R0, R0, #1
            STR     R0, find
    ```

<br>

### 1.2 列表
我们以颜色表为例介绍列表: 

显示设备可以输出大量不同的颜色. 广泛普及的显示屏的色彩输出范围至少都是数百万种颜色以上. 对于采用了位映射模式 (`Bit-Mapped`) 的显示设备而言, 它的每一个像素都可以显示一种不同的颜色. 

考虑一个由三原色组成的像素点. 对于这样的一个像素点, 它的三原色输出强度均可被分别控制 (如: 每种颜色的强度可分为 `256` 级), 因而表示这样的一个像素点需要一个字节, 也就是八个位的存储空间. 

用于查表的 `ARM` 代码: 

![20201107212755](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201107212755.png)


在内存中, 指令和数据是这样存储的: 
![20201107215236](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201107215236.png)

需要注意的是: 由于在该程序中我们使用 `DEFB` 定义变量, 为该变量分配的存储空间固定为 `32位`, 也就是 $4$ 个字节, 转换为 $16$ 位无符号整数后, 它的位数就是 $8$ ($2^{32} = 4 * (16)^2$). 而对于三通道的颜色表示法, 每一个通道的表示需要占用长为 $2$ 的十六进制位, 因此不管是什么颜色, 表示为十六进制无符号整数都是 `0x00??????`. 而众所周知, `ARM` 架构采用小端序, 因此在该表中, 所有的数据化为 `16` 进制无符号整数后, 其最高两位均空置为 `0`. 

<br>
<br>

## 2. 位运算

### 2.1 快速无符号二进制整数乘法/除法

### 2.2 有符号二进制整数乘法

### 2.3 旋转操作

### 2.4 `ARM` 移位指令

|助记符|实际含义|行为|
|-|-|-|
|`LSL #n`| 逻辑左移 $n$ 位|将有符号或无符号二进制整数乘以 $2^n$|
|`LSR #n`| 逻辑右移 $n$ 位 | 将无符号二进制整数除以 $2^n$|
|`ROR #n`|右旋转 $n$ 位|旋转位: `lsb` $\rightarrow$ `Carry`|
|`RRX #n`|右旋转并扩展 $n$ 位|围绕 `Carry` 位旋转位|

