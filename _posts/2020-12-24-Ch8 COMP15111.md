---
layout:     post
title:      Ch8 I ⁄ O设备：汇编语言视角
subtitle:   I ⁄ O device：from the prespective of assembly language
date:       2020-12-24
author:     R1NG
header-img: img/post-bg-comp15111.jpg
description: 本章从ARM汇编语言的角度介绍I/O设备的控制和通讯.
catalog: true
tags:
    - COMP15111
    - 课程笔记
    - 2020
---

# Ch8 `I/O` 设备: 汇编语言视角

Motivation:
1. 了解程序与外设通讯的主要方式: 轮询和中断
2. 明确中断发生时程序所需要进行的操作


## 1. 外设与轮询通讯方式
### 1.1 内存映射

一种使计算机和外设能够实现双向通讯的方式是内存映射 `Memory Mapping`:
1. 将外设本身通过某种方式映射到一个不被占用的内存地址上, 而处理器从外设读取数据或传输数据到外设的行为被抽象为对这个内存地址上的内存位置的读取
2. 由于该方法将外设抽象为了一个内存位置, 因此对该外设的操作理论上速度等同于对内存读写的速度
下面以键盘上的一个按键为例:
我们将键盘上的某个特定按键和一个不被占用的内存地址所绑定, 并且将键盘编程为: 当它检测到地址总线上出现了这个内存地址时, 就将按键输出连接到数据总线中传递给处理器:

![20210106151550](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210106151550.png)

在上图所示的例子中, 我们将键盘按键 `q` 和内存地址 $10100000_{2}$ 绑定. 当这个内存地址出现在内存总线上时, 逻辑电路就会将数据总线和键盘的数据链路链接; 而当这个按键被按下时, 开关闭合, 接地链路的电位被拉高, 因此在数据总线上传输 $01110001_{2}$. 

从物理上说, 这样的电路和通讯方式完全是可行的. 但如果采取这样的通讯方式的话, 即使对键盘而言, 我们也需要为每一个按键甚至每一种组合键分配一个单独的内存地址; 并且每一次对键盘的 “检查” 都需要依次在内存总线上传输这些被分配的内存地址. 

我们不难发现: 实际上, 为每一个按键分配一个单独的内存地址是毫无必要的, 我们只需要为键盘这一个外设分配内存地址, 并且让键盘在响应每一个按键按下 (物理) 事件时向数据总线传输一个不同的值, 比如具有唯一性的 `ASCII` 码值, 通过检测这个传入的码值判断按下了哪一个按键即可. 

<br>

### 1.2 轮询和握手
在基于处理器主动定时检查键盘上的按键是否被按下 (即采用 **轮询** 的方法收集外设数据) 的前提下, 处理器将会执行以下的操作:
```
loop    ADR     R1, Status_Reg     ;load R1 to Status_Reg
        LDRB    R0, [R1]           ;read status
        TST     R0, #0x80          ;test the ready bit (bit7) 
        BEQ     loop               ;try again if not ready

        ADR     R1, Data_Reg       ;if ready, store R1 to Data_Reg
        LDRB    R0, [R1]           ;ready for reading the key code

...
; then do what needs to be done
...
        B       loop                ;and branch back to check again...
```

这一方法即称为 **轮询方法**: 
1. 处理器定期检查外设
2. 若在检查时检测到外设传入了数据或某种状态发生了变化, 则依照实际情况执行响应的操作

然而, 处理器的运行速度比人们使用键盘输入信息的速度快得多, 并且还存在着键盘不被使用的情况. 也就是说, 在处理器对键盘进行轮询时, 实际上有大量的检测是被浪费的, 而每一次轮询中对外设的检测都会消耗本可以被用于执行其他程序的处理器时间, 这些处理器时间在大量无意义的轮询中被浪费了. 要避免这些无意义的浪费, 我们有两个方法:

1. 握手: 为外设专门分配一个状态寄存器用于告知处理器是否有必要执行轮询操作: <br>
   还是基于键盘的例子. 我们可以为键盘分配一个寄存器用来存储按键按下的状态, 该状态寄存器的值将会在键盘按键被按下时存储被按下按键的编码, 而在处理器读取完成后清零. 

然而, 在这一方法中, 外设需要被分配一个独立的状态寄存器, 并且要具有和处理器进行双向数据传输的能力. 一般来说, 这样的设备需要具备多个寄存器, 比如一个数据寄存器 (基于具体情况, 这个数据寄存器还可以是双向的), 一个控制寄存器用于控制数据传输方向, 外设行为和设备界面, 一个状态寄存器. 尽管用于和这样的设备交互的程序相对简单, 但这样的交互方式对硬件提出了不小的要求. 

总的来说, 轮询的交互方式具有以下特点:
1. 轮询消耗和浪费大量的处理器时间
2. 基于轮询的交互方式在软件实现方面要求很低, 程序简单
3. 轮询用于一些构造简易的系统中
4. 轮询不适用于较复杂和现代化的系统

握手方法并不能真正解决轮询的局限性. 要彻底解决处理器时间浪费的问题, 处理器需要使用不同的方法和外设进行交互, 这就是 **中断**. 

<br>

## 2. 中断
### 2.1 中断及其原理
在轮询交互方式中, 检测事件发生的主动权在处理器一方, 这正是处理器时间浪费的原因由来. 在中断交互方式中, 处理器只负责接收和处理事件, 而事件的发生与否由外设本身负责. 在没有任何事件发生时, 处理器持续执行当前的任务而不去主动检测外设; 而当事件发生时, 外设将会向处理器发送中断信号. 处理器在接收到中断信号后, 在暂停手头的任务之后对这一事件进行处理, 在处理完事件后继续回头处理之前的任务. 只要事件不发生, 处理器就不会消耗时间在任何一个外设上. 

<br>

### 2.2 中断执行流程和状态保护
在本文中, 我们主要讨论硬件中断. 这样的中断由用户和外部世界发起, 具有不确定性. 下面我们讨论处理器和程序在接收中断/被中断时, 所需要执行的操作是什么:

下面我们来看一个简单的例子: 

![20210106154414](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210106154414.png)

从软件执行的层面上看, 中断的全过程可以被视为发生了一次函数跳转. 因此, 在执行函数跳转时, 就需要进行状态保护 (包括状态保存和状态恢复):
1. 在完成中断处理后, 处理器必须返回执行原来的程序, 并且确保中断处理的流程对原程序的执行不造成任何影响
2. 和 `BL` 指令所产生的效果不同, 中断造成的跳转必须保护和恢复包括状态寄存器 `CPSR`, 程序计数器 `PC` 在内的所有寄存器状态. 这一步骤一般交由处理器和中断服务进程执行. 

下面, 我们讨论外设是如何从硬件层面 "发起" 中断的:<br>
在中断交互方式下, 处理器不能主动向设备发起检测, 外设是通过发送 `IRQ` (`Interrupt ReQuest`) 信号来 "引起处理器的注意" 的:

![20210106160931](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210106160931.png)

<br>

### 2.3 其余的 `ARM` 硬件特征
`ARM` 架构规定, 当处理器重置时, 状态寄存器 `CPSR` 的 `IRQ` 中断禁止位 `<7>`被设为 $1$:

![20210106161143](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20210106161143.png)

这意味着, 处理器在满足相关条件, 进入可以接收中断的状态前, 所有传入的中断请求都会被忽略. 

中断禁止位的存在非常重要. 一方面, 一些操作可能会无条件地收到传入的中断请求的影响而无法完成, 因此在这一情形下必须忽略一切可能传入的中断; 从另一角度看, 由于计算机往往会外接大量不同的外设, 中断静止位提供了一种避免外设间产生冲突的方法. 不过在本文中, 我们只考虑简化的情况: 计算机只外接一个设备. 

总的来说, 当中断发生时, 处理器将会执行以下的操作:
1. 完成当前进行的这条指令
2. 将链接寄存器內的值 $+4$, 保证在处理完中断操作跳转回来时程序执行无缝衔接
3. 将状态寄存器 `CPSR` 的值存储至它的物理备份寄存器 `SPSR` 中
4. 将 `CPSR` 的 `IRQ` 中断禁止位设为 $1$, 忽略一切中断请求
5. 将程序计数器指向 $00000018$. 

[注]<br>
1. 中断请求被视为一种 "异常" (`Exception`), 在这一异常发生时

<br>

## 3. 直接内存访问 `DMA`
