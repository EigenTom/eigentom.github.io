---
layout:     post
title:      函数式编程
subtitle:   Introduction to Functional Programming
date:       2021-12-14
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: 本章介绍函数式编程.
catalog: true
tags:
    - 课程笔记
    - 函数式编程
---

# 函数式编程导论

在本节中, 我们将以 `Haskell` 为例了解 **函数式编程** 的思想, 基本特征和方法. 

下面首先粗略地给出 **函数式编程** 的基本特征:

1. 将 **所有的函数 (`Function`)** 视为 **变量** 处理: 允许 **匿名函数** 的声明, 允许将函数 **作为其他函数的输入或输出**.
2. 将 **程序中的函数** 视为 **数学中函数 (映射)**: 其输出 **只和它的输入有关**, 如果两个函数的输入输出相同则 (在 `Haskell` 中) 它们 **等价且可被彼此替换**; 由此函数还不能执行任何意义上的 **副作用**.

## 1. `Haskell` 中的基本定义

首先考虑 `Haskell` 中对变量/表达式/算式, 以及函数的基本定义:

### 对变量, 表达式和算式的基本定义方法
`Haskell` 中 **任何表达式和函数** 都被统一视为 **变量**.

~~~haskell
b = False || (False && True)

n = 1 + 7

b2 = n /= 8

b3 = (0,0) == (0,0)

v = 7 * (if b then 5 else 6)
~~~
上面例子中的 `v` 实际上是一个表达式, 但在理解时需要将其理解为整数类型的变量, 只不过该变量的实际值随另一个 (布尔型) 变量 `b` 而定.

### 对函数的基本定义方法

在 `Haskell` 中, 基本的 **函数定义方法** 包括 **使用等式定义函数** 和 **使用模式匹配 (实际上也就是不同的) 定义函数**:

~~~haskell
-- defining a function by an equation
add7 n = n + 7


-- defining a function by pattern matching
-- change the order and see what happens!

small 0 = True
small 1 = True
small n = False

-- defining a function on pairs by pattern matching 
-- gives us more interresting examples

addUp (0,n) = n
addUp (m,0) = m
addUp (m,n) = m + n

-- we can also use _ to denote we don't care this input
first (e,_) = e
~~~

注意, 虽然 `addUp` 函数看上去是一个 **接收了两个输入的二元函数**, 但实际上应当将其视为一个 **接受单个参数的一元函数**, 只不过其唯一的输入恰好是一个包含了两个子元素的元组.

我们可以进一步地利用类型匹配 **递归地** 定义函数, 如下面例子中分别定义了 **计算斐波那契数列的递归规则中的 `Base Case` 和 `Step Case`**.

~~~haskell
-- defining a reursive function

fib 0 = 0     -- base case
fib 1 = 1     -- base case
fib n = fib(n-2) + fib(n-1)     -- step case
~~~

### 对高阶函数的定义

回顾高阶函数概念本身的定义: 我们称至少输入和输出中有一项是函数的函数为 **高阶函数**. 

我们首先考察 `Haskell` 中一个 **隐式定义高阶函数** 的例子:

~~~haskell
-- this function takes a number and returns
-- the function which adds that number to
-- its input
addConst n m = n + m

-- we can test it by evaluating it at 3
-- and seeing what function we get
addThree = addConst 3
~~~

实际上它等同于下面所示的 `addConstB`:

~~~haskell
-- we can use anonymous functions to make it
-- obvious that this returns a function
addConstB n = \m -> n + m
~~~

进一步地, 我们可以使用 **匿名函数** 更清晰地定义高阶函数:

~~~haskell
-- indeed, we can define a function explicitly
-- using anonymous functions, rather than equations
addConstC = \n -> (\m -> n + m)
~~~

注意 `Haskell` 中的 `Shadowing`:

~~~haskell
-- note: when a variable is used, it refers to
-- the definition closest  to the usage, so
-- the following returns the identity function, not
-- a constant function. This is called 'shadowing'
h n = (\n -> n)

-- but the following expression defines a function
-- which returns a constant function.
h2 n = (\m -> n)
~~~

和其他常规函数一样, 我们也可以递归地定义高阶函数:

~~~haskell
-- we can define recursive higher-order functions
-- just like any other functions

repFromZero 0 f = 0
repFromZero n f = f(repFromZero (n-1) f)
~~~

### 其他有用的变量定义方式

#### `case` 语句

我们可以使用 `case` 定义不同条件下函数的输出, 可以立即注意到, 它可被用于定义函数的 **递归规则**:

~~~haskell
-- recall the definition of small above:
small 0 = True
small 1 = True
small n = False

-- we define a function which returns
-- True when it's argument plus one is small
-- using a case expression:
smallB n = case n + 1 of
    0 -> True
    1 -> True
    n -> False
~~~

#### `guard` 语句

我们也可以使用下面展示的 `guard expression` 语法定义条件语句:

~~~haskell
-- a guard expression lets you define a value
-- differently in different situations, defined
-- by boolean expressions.
-- It can also contain a 'where' clause to define
-- a repeated part of the boolean conditions.

sideOfFive n
 
 | d > 0 = 1
 | d < 0 = -1
 | otherwise = 0    -- represent final/default case

 where d = n - 5
~~~

注意我们用变量 `d` 代替了表达式 `n-5`.

#### `let` 关键字

我们可以使用 `let` 关键字在表达式 **行间** 定义变量值且应用在表达式中:

~~~haskell
-- a 'let' expression allows us to name
-- a value and use it in an expression
-- it is useful for making long formulas
-- more readable

y = let x = 10 + 10     -- just a local definition of x 
    in x + x

-- the let expression also **exhibits shadowing**:
-- the innermost let below is the one used for the
-- meaning of x.
-- Note that the below is not an intruction to 
-- 'change' x from 10 to 20. In Haskell nothing
-- ever changes! We are just saying that locally
-- we want x to be defined in various ways.

z = let x = 10
 in
 let x = 20
 in x
~~~

注意在 `z` 的例子中, 实际上 `x` 先被定义为了 $10$, 然后在 **内层的表达式** 中被暂时改为了 $20$, 此处体现了 `shadowing`: 最内层表达式中的 `x` 优先和离自己最近的赋值语句匹配. 

最后考虑一个更复杂的例子:

~~~haskell
-- now we can see that functions do behave just like
-- ordinary values in at least one way:
-- at the point the definition of f below, the local
-- definition of x is 5, so f is defined to be the
-- constant function 5.
-- We don't need to worry about local definitions
-- of x in other parts of the code to understand
-- what f does.

w = let x = 5 in
    let f = \n -> x in
    let x = 6 in
    f 0
~~~

注意此处 `f` 中对 `x` 的定义取 $5$ 不取 $6$ 的主要原因其实不是 `shadowing`, 而是由于在定义了 `f` 内层里对 `x` 的重新定义不会对外层中 `f` 里 `x` 的定义产生任何影响.

#### 其他的一些常见错误

下面讨论一些在定义变量时常见的错误.

1. 模式匹配中不定义默认情形:
    ~~~haskell
    -- not defined for all inputs
    -- this causes a runtime error

    oops True = True
    --try running main = print (oops False)
    ~~~

2. 递归定义函数时构造用不终止的循环或不构造有效的 `Base Case`:
   
   ~~~haskell
    -- this recursive function is badly defined and will
    -- run forever on inputs other than 0
    eep 0 = 0
    eep n = 1 + eep n

    -- printing yikes will cause Haskell to run forever
    -- searching for a number x such that x = x + 1
    yikes = let x = 5 in
    let x = x + 1

    -- the following will also run forever:
    -- even though there are plenty of values equal
    -- to themselves, the defintion gives us no clue
    -- about which one the programmer wanted

    yikesB = let x = x in x
   ~~~~

## 2. `Haskell`: 类型系统




## 3. 严格性

## 4. `Haskell`: 更多类型

## 5. `Haskell`: 输入输出