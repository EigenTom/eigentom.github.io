---
layout:     post
title:      函数式编程
subtitle:   Introduction to Functional Programming
date:       2021-12-14
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: 本章介绍函数式编程.
catalog: true
tags:
    - 课程笔记
    - 函数式编程
---

# 函数式编程导论

在本节中, 我们将以 `Haskell` 为例了解 **函数式编程** 的思想, 基本特征和方法. 

下面首先粗略地给出 **函数式编程** 的基本特征:

1. 将 **所有的函数 (`Function`)** 视为 **变量** 处理: 允许 **匿名函数** 的声明, 允许将函数 **作为其他函数的输入或输出**.
2. 将 **程序中的函数** 视为 **数学中函数 (映射)**: 其输出 **只和它的输入有关**, 如果两个函数的输入输出相同则 (在 `Haskell` 中) 它们 **等价且可被彼此替换**; 由此函数还不能执行任何意义上的 **副作用**.

## 1. `Haskell` 中的基本定义

首先考虑 `Haskell` 中对变量/表达式/算式, 以及函数的基本定义:

### 对变量, 表达式和算式的基本定义方法
`Haskell` 中 **任何表达式和函数** 都被统一视为 **变量**.

~~~haskell
b = False || (False && True)

n = 1 + 7

b2 = n /= 8

b3 = (0,0) == (0,0)

v = 7 * (if b then 5 else 6)
~~~
上面例子中的 `v` 实际上是一个表达式, 但在理解时需要将其理解为整数类型的变量, 只不过该变量的实际值随另一个 (布尔型) 变量 `b` 而定.

### 对函数的基本定义方法

在 `Haskell` 中, 基本的 **函数定义方法** 包括 **使用等式定义函数** 和 **使用模式匹配 (实际上也就是不同的) 定义函数**:

~~~haskell
-- defining a function by an equation
add7 n = n + 7


-- defining a function by pattern matching
-- change the order and see what happens!

small 0 = True
small 1 = True
small n = False

-- defining a function on pairs by pattern matching 
-- gives us more interresting examples

addUp (0,n) = n
addUp (m,0) = m
addUp (m,n) = m + n

-- we can also use _ to denote we don't care this input
first (e,_) = e
~~~

注意, 虽然 `addUp` 函数看上去是一个 **接收了两个输入的二元函数**, 但实际上应当将其视为一个 **接受单个参数的一元函数**, 只不过其唯一的输入恰好是一个包含了两个子元素的元组.

我们可以进一步地利用类型匹配 **递归地** 定义函数, 如下面例子中分别定义了 **计算斐波那契数列的递归规则中的 `Base Case` 和 `Step Case`**.

~~~haskell
-- defining a reursive function

fib 0 = 0     -- base case
fib 1 = 1     -- base case
fib n = fib(n-2) + fib(n-1)     -- step case
~~~

### 对高阶函数的定义

回顾高阶函数概念本身的定义: 我们称至少输入和输出中有一项是函数的函数为 **高阶函数**. 

我们首先考察 `Haskell` 中一个 **隐式定义高阶函数** 的例子:

~~~haskell
-- this function takes a number and returns
-- the function which adds that number to
-- its input
addConst n m = n + m

-- we can test it by evaluating it at 3
-- and seeing what function we get
addThree = addConst 3
~~~

实际上它等同于下面所示的 `addConstB`:

~~~haskell
-- we can use anonymous functions to make it
-- obvious that this returns a function
addConstB n = \m -> n + m
~~~

进一步地, 我们可以使用 **匿名函数** 更清晰地定义高阶函数:

~~~haskell
-- indeed, we can define a function explicitly
-- using anonymous functions, rather than equations
addConstC = \n -> (\m -> n + m)
~~~

注意 `Haskell` 中的 `Shadowing`:

~~~haskell
-- note: when a variable is used, it refers to
-- the definition closest  to the usage, so
-- the following returns the identity function, not
-- a constant function. This is called 'shadowing'
h n = (\n -> n)

-- but the following expression defines a function
-- which returns a constant function.
h2 n = (\m -> n)
~~~

和其他常规函数一样, 我们也可以递归地定义高阶函数:

~~~haskell
-- we can define recursive higher-order functions
-- just like any other functions

repFromZero 0 f = 0
repFromZero n f = f(repFromZero (n-1) f)
~~~

### 其他有用的变量定义方式

#### `case` 语句

我们可以使用 `case` 定义不同条件下函数的输出, 可以立即注意到, 它可被用于定义函数的 **递归规则**:

~~~haskell
-- recall the definition of small above:
small 0 = True
small 1 = True
small n = False

-- we define a function which returns
-- True when it's argument plus one is small
-- using a case expression:
smallB n = case n + 1 of
    0 -> True
    1 -> True
    n -> False
~~~

#### `guard` 语句

我们也可以使用下面展示的 `guard expression` 语法定义条件语句:

~~~haskell
-- a guard expression lets you define a value
-- differently in different situations, defined
-- by boolean expressions.
-- It can also contain a 'where' clause to define
-- a repeated part of the boolean conditions.

sideOfFive n
 
 | d > 0 = 1
 | d < 0 = -1
 | otherwise = 0    -- represent final/default case

 where d = n - 5
~~~

注意我们用变量 `d` 代替了表达式 `n-5`.

#### `let` 关键字

我们可以使用 `let` 关键字在表达式 **行间** 定义变量值且应用在表达式中:

~~~haskell
-- a 'let' expression allows us to name
-- a value and use it in an expression
-- it is useful for making long formulas
-- more readable

y = let x = 10 + 10     -- just a local definition of x 
    in x + x

-- the let expression also **exhibits shadowing**:
-- the innermost let below is the one used for the
-- meaning of x.
-- Note that the below is not an intruction to 
-- 'change' x from 10 to 20. In Haskell nothing
-- ever changes! We are just saying that locally
-- we want x to be defined in various ways.

z = let x = 10
 in
 let x = 20
 in x
~~~

注意在 `z` 的例子中, 实际上 `x` 先被定义为了 $10$, 然后在 **内层的表达式** 中被暂时改为了 $20$, 此处体现了 `shadowing`: 最内层表达式中的 `x` 优先和离自己最近的赋值语句匹配. 

最后考虑一个更复杂的例子:

~~~haskell
-- now we can see that functions do behave just like
-- ordinary values in at least one way:
-- at the point the definition of f below, the local
-- definition of x is 5, so f is defined to be the
-- constant function 5.
-- We don't need to worry about local definitions
-- of x in other parts of the code to understand
-- what f does.

w = let x = 5 in
    let f = \n -> x in
    let x = 6 in
    f 0
~~~

注意此处 `f` 中对 `x` 的定义取 $5$ 不取 $6$ 的主要原因其实不是 `shadowing`, 而是由于在定义了 `f` 内层里对 `x` 的重新定义不会对外层中 `f` 里 `x` 的定义产生任何影响.

#### 其他的一些常见错误

下面讨论一些在定义变量时常见的错误.

1. 模式匹配中不定义默认情形:
    ~~~haskell
    -- not defined for all inputs
    -- this causes a runtime error

    oops True = True
    --try running main = print (oops False)
    ~~~

2. 递归定义函数时构造用不终止的循环或不构造有效的 `Base Case`:
   
   ~~~haskell
    -- this recursive function is badly defined and will
    -- run forever on inputs other than 0
    eep 0 = 0
    eep n = 1 + eep n

    -- printing yikes will cause Haskell to run forever
    -- searching for a number x such that x = x + 1
    yikes = let x = 5 in
    let x = x + 1

    -- the following will also run forever:
    -- even though there are plenty of values equal
    -- to themselves, the defintion gives us no clue
    -- about which one the programmer wanted

    yikesB = let x = x in x
   ~~~~

### 相关题目解析

![20220506201957](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220506201957.png)

此题中唯一重要的问题是: 函数 `f = \x -> (\x -> x)` 的实质. 
回顾此前讲过的, `shadowing` 的规则, 我们知道在函数 `f` 内层真正作为输出的 `x` 实际上 **是和内层的 `x` 相匹配的**, 因此它应该等价于 **选项 `E`**: `f = \z -> (\y -> y)`. 

![20220506202156](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220506202156.png)

## 2. `Haskell`: 类型系统

在 `Haskell` 中, **任何表达式均具备类型**, 且对类型的检查发生在 **编译阶段**. 

### `Haskell` 中的类型限制和自动类型推断

~~~haskell
-- we can explicitly give the type of a function
f :: Int -> Int
f x = x + 1

-- Note: Int is fixed precision, Integer unbounded
-- We also have Float, Double
fd :: Double -> Double
fd x = x + 1
~~~

如上面的例子, 在指定函数输入输出的数据类型后, 如果提供了类型不正确的变量, 就会因为和数据类型规定冲突而无法编译.

若我们 **不明确提供变量的数据类型**, 则它们的数据类型会由 **编译器推断得出**.

~~~haskell
-- In Haskell, every expression has a type
-- How come last week we didn't have to
-- delcare them? Haskell infers types
-- we don't give explicitly E.g.
j x = True

-- What is the type of j?
-- We can give it several types, like
j :: Bool -> Bool
j :: Int -> Bool

-- Note we can't give it type Bool -> Int!
-- But the original has a strange feature:
main = print(j 1 && j True)

-- Is this 'dynamic typing'? No it is called
-- 'parametic polymorphism'. We can use
-- type variables to indicate that something
-- works for all types!
j :: a -> Bool
~~~

在上面的例子中, 实际上函数 `j` 在未经声明输入类型, 并在两个地方分别应用了 **以整数为类型的输入** 和 **以布尔型为类型的输入** 时, 会触发 **通用类型** (`General Type`) 机制, 编译器通过 **自动类型推断** 得出该函数的输入可能具有至少两种不同类型, 因此将其输入的类型设为 **动态类型**: 该函数接收 **任何类型的输入**, 并输出布尔型数据. 

### `Haskell` 中的类型构造器 (`Type Constructor`)

此前我们介绍过可以使用 `Haskell` 中的 **二元元组/变量对** 向函数中 “同时传递两个变量”, 而这也是在 `Haskell` 中构造 **自定义数据类型** 的方式之一: `pair of types => type of pairs`.

~~~haskell
-- We can use type constructors to make
-- more complicated types out of other types!
-- e.g. the type of pairs
sumPair :: (Int, Int) -> Int
sumPair (x,y) = x + y
~~~

进一步地, 我们可以定义 **接受函数作为输入, 并以函数作为输出的高阶函数** 的, **输入输出的数据类型**:

在下面的例子中, 首先定义的是一个 **接受类型为: “输入整数, 输出布尔型的函数”, 输出类型为 “布尔型”** 的高阶函数:

~~~haskell
-- Similarly, given two types we can construct
-- the type of functions from one to the other
atTen :: (Int -> Bool) -> Bool
atTen f = f 10
main = print(atTen (\x -> True))

-- note this is an example of type inference!
-- we could write explicitly
main = print(atTen ((\x -> True):: Int -> Bool))
~~~

其次定义的是一个以 **相同类型的函数作为输入/输出的, 通用类型的高阶函数**;

~~~haskell
-- We can use more than one type variable to indicate 
-- which inputs have to have matching types
myApp :: (a -> b) -> a -> b
myApp f x = f x
main = print(myApp (\x -> True) 10)

-- note that it would also be correct
-- to give myApp a less general type e.g.
myApp :: (Int -> Bool) -> Int -> Bool

-- which still lets the example work:
main = print(myApp (\x -> True) 10)

-- but also
-- myApp :: (a -> a) -> a -> a
-- which doesn't! But it works for e.g.
-- main = print(myApp (\x -> 11) 10)
-- where the types are all the same

-- Note that we can't have
-- myApp :: (a -> b) -> b -> a
-- because this doesn't match what happens
-- in the definition: we can't apply a funtion
-- of type (a -> b) to an input of type b!
~~~

### `Haskell` 中的代数数据类型 (`Algebraic Datatypes`)

所谓的 **代数数据类型** 是指通过形如 **代数运算** 的方式从基本数据类型或更简单的自定义数据类型 **组合而成** 的数据类型:

1. 认为 “选择型数据类型” (如 `A|B`型, 表示 “`A` 或 `B`”, 以及枚举) 对应 **代数和** (`Sum`)
2. 认为 “组合型数据类型” (如 `AB`型, 表示 “`A` 和 `B`”), 对应 **代数积** (`Product`).

参考 [`Haskell` 官方Wiki](https://wiki.haskell.org/Algebraic_data_type)


`Haskell` 允许我们使用 `data` 关键字构造 **用户自定义数据类型**. 

首先我们可以构造 **枚举数据类型**: 

~~~haskell
-- ALGEBRAIC DATA TYPES
-- we can make our own types by using the 'data'
-- keyword. The simplest are enumerations, which

data SwitchState = On | Off
~~~

利用自定义的枚举数据类型, 我们可以利用 **模式匹配** 定义函数:

~~~haskell
-- we can define functions by pattern matching
toggle On = Off
toggle Off = On

isOn On = True
isOn Off = False

-- main = print(isOn (toggle On))
-- Note we can't do `main = print(toggle Off)`
-- because we haven't told Haskell how to print
-- a value of this type. (How to print "on"?) 
~~~

自然地, 我们还可以基于现存的基本类型构造出新的自定义数据类型:

~~~haskell
-- we can also attach data from existing types
data MyIntPair = IntPair Int Int

mySumPair (IntPair x y) = x + y
main = print(mySumPair(IntPair 3 6))

-- we can also ignore some fields of a constructor
myfst (IntPair x _) = x
main = print(myfst (IntPair 1 2))
~~~

我们可以基于现存的基本数据类型构造代数数据类型:

~~~haskell
-- we can combine the ideas of enums and data
-- fields
data BoolOrInt = Abool Bool | Anint Int

-- This is called an 'algebraic datatype'
intval :: BoolOrInt -> Int
intval (Abool True) = 1
intval (Abool False) = 0
intval (Anint x) = x

opposite :: BoolOrInt -> BoolOrInt
opposite (Abool True) = (Abool False)
opposite (Abool False)= (Abool True)
opposite (Anint x) = (Anint (-x))
main = print(intval(opposite (Abool False)))
~~~

补充: `Maybe` [StackOverflow](https://stackoverflow.com/questions/18808258/what-does-the-just-syntax-mean-in-haskell)

还可以用 **递归的方式** 定义代数数据类型:

~~~haskell
-- Algebraic datatypes can be recursive. This
-- is useful for recursively defined data structures
data MyList a = Empty | Append a (MyList a)

myHead Empty = Nothing
myHead (Append x l) = Just x
main = print(myHead (Append 10 (Append 11 Empty)))
~~~

### `Haskell` 中的列表语法

下面讨论 `Haskell` 内置的列表数据类型的语法:

我们通过在变量左右加入中括号 `[]` 声明列表:

一般表示 `List` 变量的方式形如 `1:2:3:[]`, 而 `Haskell` 当然支持更阳间的列表语法糖, 因此我们可以用这样的方式表示列表: `[1, 2, 3]`.

~~~haskell
-- define a function take an integer list as input type
myIntHead :: [Int] -> Maybe Int
myIntHead [] = Nothing
myIntHead (x:xs) = Just x

main = print(myIntHead ([1, 2, 3])))
~~~

下面考虑更复杂的例子:

~~~haskell
myHead :: [a] -> Maybe a
myHead [] = Nothing
myHead (x:xs) = Just x

-- String is defined as a list containing chars
main = print(myHead ("Hi!"::[Char]))
~~~

同时, `Haskell` 提供了一系列对于 **数值列表** 的简易语法:

~~~haskell
-- quick defining numeric list:
[1, 3..10] <=> [1, 3, 5, 7, 9]

-- construct new list containing data from two disjunct lists, combination:
l = [(w, n) | w <- ""Hi!, n <- [1..3]]
-- result is: [('H', 1), ('H', 2), ('H', 3), ('i', 1), ..., ('!', 3)]
~~~


### 相关题目解析

![20220506203740](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220506203740.png)

![20220506203721](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220506203721.png)

## 3. 严格性

在本节中我们讨论 **如何在 `Haskell` 中定义函数**.

### `Haskell` 中的错误




## 4. `Haskell`: 更多类型

## 5. `Haskell`: 输入输出

我们在最后一节中讨论如何使用 `Haskell` 编写 **可交互式程序**:

