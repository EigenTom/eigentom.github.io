---
layout:     post
title:      普林斯顿算法4-Ch2 排序
subtitle:   Sorting Algorithms
date:       2021-09-03
author:     R1NG
header-img: img/post-bg-algs4.jpg
description: 
catalog: true
tags:
    - 2021
    - 数据结构和算法
    - 扩展自习
---

# Ch2 排序

在本章中, 我们将学习数种经典的排序算法, 并实现 **优先队列** 这一基础数据类型, 讨论比较排序算法的理论基础并最后总结若干排序算法和优先队列的应用.

<br>

## 2.1 初级排序算法

我们首先研究两种 **初级的排序算法** 和其中一种的一个变体. 在此, 我们关注的主要对象是 **重新排列数组元素** 的算法, 其中 **每个元素都有一个主键**. 排序算法的目的就是将 **所有元素的主键** 按照某种方式排列, 在经过排序后索引较大的主键大于等于索引较小的. 

下面, 我们规定排序代码的结构和模板:

我们会将排序代码放在类的 `sort()` 方法中, 该类还包含辅助函数 `less()`, `exch()` 和示例用例 `main()`, 其中 `less()` 方法对元素进行比较, 而 `exch()` 方法将元素交换位置. 为了区分不同的算法, 我们还可以为相应的类取不同的名字, 用例可以按照名字调用不同的实现. 

为了确保数组的初始状态是不影响排序算法的成功与否的, 我们会在测试代码 `main()` 中添加语句 `assert isSorted(a)` 来确认经过排序后的数组元素都是有序的. 

在确认算法的有效性后, 我们还需要对其性能进行评估. 首先, 我们需要计算各个排序算法在 **不同的随机输入下的基本操作的次数** (包括比较和交换的数量. 对于不交换元素的算法, 我们需要计算访问数组的次数). 随后, 我们用这些数据来估计算法的性能. 

除此以外, 我们也需要关注排序算法的 **额外内存开销**. **原地排序算法** 是 **除了函数调用所需的栈和固定数目的实例变量之外无需额外内存** 的算法, 而需要额外内存空间来存储一份数组副本的则被列为 **其他排序算法**. 

~~~java
public class Example {
    public static void sort(Comparable[] a) {
        // see each sorting algorithms
    }

    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private static void show(Comparable[] a) {
        for (int i=0; i<a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }

    public static boolean isSorted(Comparable[] a) {
        for (int i=1; i<a.length; i++) {
            if (less(a[i], a[i-1])) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        String[] a = In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
~~~

<br>

### 选择排序

选择排序是最简单的排序算法之一. 它的工作原理如下:

首先在数组的 $n$ 个元素中找到 **最小的元素**, 将其和 **数组的第一个元素** 交换位置, 无论数组的第一个元素是否为数组中最小的元素. 

随后, 在剩下的 $n-1$ 个元素中再找到最小的, 并和整个数组中的第二位交换位置, 如此往复直到只剩下 $1$ 个待排序元素, 此时整个数组显然已经被完全排序. 我们称这种排序方法为 **选择排序**, 因为它 **不断地在选择剩余元素中的最小者**.

选择排序的内循环仅仅在比较 **当前元素** 和 **目前已知的最小元素**, 而交换元素的代码在内循环之外. 由于每次交换必能排定一个元素, 故交换的总次数为 $N$, 算法的时间效率取决于 **比较的次数**.

~~~java
public class Selection {
    public static void sort(Comparable[] a) {
        int N = a.length;   // length of the array a
        // then we exchange a[i] with the smallest elem in a[i+1, ..., N]
        for (int i=0; i<N; i++) {   
            int min=i;  // index of the min element
            for (int j=i+1; j<N; j++) {
                if (less(a[j], a[min])) {
                    min = j;
                }
            }
            exch(a, i, min);
        }
    }
}
~~~

**命题**
> 对于长度为 $N$ 的数组, 选择排序大约需要 $\frac{N^2}{2}$ 次比较和 $N$ 次交换.

**证明**
> 基于算法的 **排序轨迹** 和 **工作原理** 可知, 由于每次交换只会对 $1$ 个元素进行排序, 因此对于长度为 $N$ 的数组总共交换次数也为 $N$.<br>
> 由于数组索引 $i \in [N-1]$ 的元素都会进行 $N-1-i$ 次比较, 因此将整个数组进行排列共需要 $\sum_{i=1}^{N-1}i = \frac{N(N-1)}{2} \sim \frac{N^2}{2}$ 次比较. $\blacksquare$

总结: <br>

选择排序是一种简单的排序算法, 其具备两个显著特征:

1. **运行时间和输入无关**:<br>
    选择排序无法利用输入数组的 **初始状态**, 它对一个已经有序或者元素全部相等的数组进行排序所耗费的时间和对一个乱序数组而言是 **完全相同的**, 因为它在对任何一个元素进行排序时执行的每一次全数组扫描都不能为下一次排序提供任何有效信息, 这一性质在某些情况下是制约运行速度的缺点.

2. **数据移动最少**: <br>
   由于每次交换均会改变 **两个数组元素的值**, 因此选择排序对数组的交换次数和数组大小是 **线性关系**, 而我们即将讨论的其他任何算法都不具备该特征.

<br>

### 插入排序

要理解插入排序的原理, 我们可以从扑克牌的整理方式中获得启发. 和理牌时我们需要将一张牌插入到其他 **已经有序** 的牌中的适当位置一样, 在插入排序的实现中, 为了给要插入的元素腾出空间, 需要将 **其余所有元素** 在插入之前都 **右移一位**.

与选择排序相同, 当前索引左侧的所有元素都是有序的, 只不过它们的最终位置还不确定, 但当 **索引到达数组右端** 时, 数组排序就完成了. 不同于选择排序, 插入排序的耗时受输入中元素初始顺序的影响. 

**命题**
> 对于随机排列的长为 $N$ 且 **主键不重复** 的数组, 平均情况下插入排序需要约 $\frac{N^2}{4}$ 次比较和交换. 最坏情况下需要约 $\frac{N^2}{2}$ 次比较和交换, 最好情况下需要 $N-1$ 次比较和 $0$ 次交换. 

**证明**
> 通过一个 $N \times N$ 的 **排序轨迹表** 可以很容易地得到交换和比较的次数. 最坏情况下, 轨迹表 **对角线之下** 的所有元素都需要移动位置, 而最好情况下都不需要; 对于 **随机排列** 的数组, 在平均情况下每个元素都可能向后移动 **半个数组的长度**, 故交换总数总是对角线之下元素总数的 $\frac{1}{2}$. 
>
> 比较的总次数为交换的次数 **减去一个额外项** 再加上 $N$. 这个额外项是, 在所有的插入操作中, 将被插入的元素恰好是数组中位于索引前的那部分中的最小元素这种情况总共出现的次数. 在最坏情况下, 这一项相比交换总数可以 **忽略不计**, 而在最好情况下, 这一项等于 $1$. $\blacksquare$

(注: 为了方便理解此处的额外项恰好是原书描述的额外项取 **相反数再加 $N$**, 原文为 “an additional term equal to N minus the number of times the item inserted is the smallest so far”.)

对于实际应用中常见的某些类型的 **非随机数组**, 插入排序是很有效的: 当我们使用插入排序尝试对一个有序数组或所有主键均相同的数组进行排序时, 插入排序能够立即识别每个元素都在合适的位置之上 (因为其执行交换操作的内层循环判断条件就是元素是否依序排列), 此时 **其运行时间是线性的**, 而选择排序就需要 $n^2$ 级别的运行时间. 

~~~java
public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i=1; i<N; i++) {
            // insert element a[i] into the already-sorted sub-arrray:
            // [a[0], ..., a[n-2], a[n-1]]
            for (int j=i; j>0 && less(a[j], a[j-1]); j--) {
                // less(a[j], a[j-1]) == "a[j]<a[j-1]? true : false"
                // it means we only proceed the iteration iff a[j] is not being 
                // placed into the right place yet
                exch(a, j, j-1)
            }
        }
    }
}
~~~

我们下面考虑 **部分有序数组**: 

**定义**: 倒置
> 数组中两个 **顺序颠倒** 的元素称为 **倒置**.

**定义**: 部分有序数组
> 如果数组中 **倒置的数量** 小于 **数组大小的某个倍数**, 则称这个数组是 **部分有序** 的.

一些典型的部分有序数组是:
1. 数组中每个元素距离其正确位置都不远.
2. 一个有序的大数组接一个小数组.
3. 只有几个元素的位置不正确的数组.

**命题**
> 插入排序所需要的交换操作和数组中 **倒置的数量** 相同, 且有:<br>
> 倒置数量 $+$ 数组大小 $-1 \geqslant$ 需要的比较次数 $\geqslant$ 倒置的数量.

**证明**
> 插入排序执行的每一次交换都改变了 **一对顺序颠倒的元素位置**, 等价于 **减少了一对倒置**. 而当 **倒置数量为 $0$** 时, 排序就完成了, 而每次交换都和一次比较对应, 因此 (需要的比较次数 $\geqslant$ 倒置的数量); 而 $1$ 到 $N-1$ 之间的每个 $i$ 都可能需要一次 **额外的比较**, 故 (倒置数量 $+$ 数组大小 $-1 \geqslant$ 需要的比较次数). $\blacksquare$

<br>

### 对插入排序和选择排序算法的比较

下面我们讨论插入排序和选择排序的性能孰优孰劣. 比对算法的速度这个问题会在我们今后对算法的学习中反复出现. 根据 `Ch 1.4` 所介绍的方法, 我们将通过以下的步骤对比两个算法:

1. 实现并调试它们.
2. 分析它们的基本性质.
3. 对它们的相对性能作出猜想.
4. 设计并进行实验对猜想进行验证. 

在前两个小节中我们已经给出了选择排序和插入排序算法的实现, 因此我们已经完成了第一步. 而上两个小节中所描述和证明的三个命题组成了流程的第二步. 我们下面将依次完成第三步和第四步. 

在实现了算法后, 我们需要确定一个适当的输入模型. 对排序而言, 上两个小节中的三个命题使用的自然输入模型假设数组中的元素 **随机排序**, 且 **主键值不会重复**. 而对于有 **很多重复主键** 的应用而言, 我们需要一个更复杂的模型. 

我们已经知道, 对于随机排序数组, 两个算法的运行时间都是 $n^2$ 级别. 我们可由此得到下列猜想:

**性质**
> 对于 **随机排序的无重复主键的数组**, 插入排序和选择排序的运行时间是 **$n^2$ 级别** 的, 两者之比应该是一个较小的常数.

对于性能实验的设计和猜想的验证, 详见原书翻译版 $\text{P}254-257$ 页, 此处不做摘录和笔记.

<br>

### 希尔排序




