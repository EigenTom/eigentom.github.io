---
layout:     post
title:      普林斯顿算法4-Ch2 排序
subtitle:   Sorting Algorithms
date:       2021-09-03
author:     R1NG
header-img: img/post-bg-algs4.jpg
description: 
catalog: true
tags:
    - 2021
    - 数据结构和算法
    - 扩展自习
---

# Ch2 排序

在本章中, 我们将学习数种经典的排序算法, 并实现 **优先队列** 这一基础数据类型, 讨论比较排序算法的理论基础并最后总结若干排序算法和优先队列的应用.

<br>

## 2.1 初级排序算法

我们首先研究两种 **初级的排序算法** 和其中一种的一个变体. 在此, 我们关注的主要对象是 **重新排列数组元素** 的算法, 其中 **每个元素都有一个主键**. 排序算法的目的就是将 **所有元素的主键** 按照某种方式排列, 在经过排序后索引较大的主键大于等于索引较小的. 

下面, 我们规定排序代码的结构和模板:

我们会将排序代码放在类的 `sort()` 方法中, 该类还包含辅助函数 `less()`, `exch()` 和示例用例 `main()`, 其中 `less()` 方法对元素进行比较, 而 `exch()` 方法将元素交换位置. 为了区分不同的算法, 我们还可以为相应的类取不同的名字, 用例可以按照名字调用不同的实现. 

为了确保数组的初始状态是不影响排序算法的成功与否的, 我们会在测试代码 `main()` 中添加语句 `assert isSorted(a)` 来确认经过排序后的数组元素都是有序的. 

在确认算法的有效性后, 我们还需要对其性能进行评估. 首先, 我们需要计算各个排序算法在 **不同的随机输入下的基本操作的次数** (包括比较和交换的数量. 对于不交换元素的算法, 我们需要计算访问数组的次数). 随后, 我们用这些数据来估计算法的性能. 

除此以外, 我们也需要关注排序算法的 **额外内存开销**. **原地排序算法** 是 **除了函数调用所需的栈和固定数目的实例变量之外无需额外内存** 的算法, 而需要额外内存空间来存储一份数组副本的则被列为 **其他排序算法**. 

~~~java
public class Example {
    public static void sort(Comparable[] a) {
        // see each sorting algorithms
    }

    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private static void show(Comparable[] a) {
        for (int i=0; i<a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }

    public static boolean isSorted(Comparable[] a) {
        for (int i=1; i<a.length; i++) {
            if (less(a[i], a[i-1])) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        String[] a = In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
~~~

<br>

### 选择排序

选择排序是最简单的排序算法之一. 它的工作原理如下:

首先在数组的 $n$ 个元素中找到 **最小的元素**, 将其和 **数组的第一个元素** 交换位置, 无论数组的第一个元素是否为数组中最小的元素. 

随后, 在剩下的 $n-1$ 个元素中再找到最小的, 并和整个数组中的第二位交换位置, 如此往复直到只剩下 $1$ 个待排序元素, 此时整个数组显然已经被完全排序. 我们称这种排序方法为 **选择排序**, 因为它 **不断地在选择剩余元素中的最小者**.

选择排序的内循环仅仅在比较 **当前元素** 和 **目前已知的最小元素**, 而交换元素的代码在内循环之外. 由于每次交换必能排定一个元素, 故交换的总次数为 $N$, 算法的时间效率取决于 **比较的次数**.

~~~java
public class Selection {
    public static void sort(Comparable[] a) {
        int N = a.length;   // length of the array a
        // then we exchange a[i] with the smallest elem in a[i+1, ..., N]
        for (int i=0; i<N; i++) {   
            int min=i;  // index of the min element
            for (int j=i+1; j<N; j++) {
                if (less(a[j], a[min])) {
                    min = j;
                }
            }
            exch(a, i, min);
        }
    }
}
~~~

**命题**
> 对于长度为 $N$ 的数组, 选择排序大约需要 $\frac{N^2}{2}$ 次比较和 $N$ 次交换.

**证明**
> 基于算法的 **排序轨迹** 和 **工作原理** 可知, 由于每次交换只会对 $1$ 个元素进行排序, 因此对于长度为 $N$ 的数组总共交换次数也为 $N$.<br>
> 由于数组索引 $i \in [N-1]$ 的元素都会进行 $N-1-i$ 次比较, 因此将整个数组进行排列共需要 $\sum_{i=1}^{N-1}i = \frac{N(N-1)}{2} \sim \frac{N^2}{2}$ 次比较. $\blacksquare$

总结: <br>

选择排序是一种简单的排序算法, 其具备两个显著特征:

1. **运行时间和输入无关**:<br>
    选择排序无法利用输入数组的 **初始状态**, 它对一个已经有序或者元素全部相等的数组进行排序所耗费的时间和对一个乱序数组而言是 **完全相同的**, 因为它在对任何一个元素进行排序时执行的每一次全数组扫描都不能为下一次排序提供任何有效信息, 这一性质在某些情况下是制约运行速度的缺点.

2. **数据移动最少**: <br>
   由于每次交换均会改变 **两个数组元素的值**, 因此选择排序对数组的交换次数和数组大小是 **线性关系**, 而我们即将讨论的其他任何算法都不具备该特征.

<br>

### 插入排序

要理解插入排序的原理, 我们可以从扑克牌的整理方式中获得启发. 和理牌时我们需要将一张牌插入到其他 **已经有序** 的牌中的适当位置一样, 在插入排序的实现中, 为了给要插入的元素腾出空间, 需要将 **其余所有元素** 在插入之前都 **右移一位**.

与选择排序相同, 当前索引左侧的所有元素都是有序的, 只不过它们的最终位置还不确定, 但当 **索引到达数组右端** 时, 数组排序就完成了. 不同于选择排序, 插入排序的耗时受输入中元素初始顺序的影响. 

**命题**
> 对于随机排列的长为 $N$ 且 **主键不重复** 的数组, 平均情况下插入排序需要约 $\frac{N^2}{4}$ 次比较和交换. 最坏情况下需要约 $\frac{N^2}{2}$ 次比较和交换, 最好情况下需要 $N-1$ 次比较和 $0$ 次交换. 

**证明**
> 通过一个 $N \times N$ 的 **排序轨迹表** 可以很容易地得到交换和比较的次数. 最坏情况下, 轨迹表 **对角线之下** 的所有元素都需要移动位置, 而最好情况下都不需要; 对于 **随机排列** 的数组, 在平均情况下每个元素都可能向后移动 **半个数组的长度**, 故交换总数总是对角线之下元素总数的 $\frac{1}{2}$. 
>
> 比较的总次数为交换的次数 **减去一个额外项** 再加上 $N$. 这个额外项是, 在所有的插入操作中, 将被插入的元素恰好是数组中位于索引前的那部分中的最小元素这种情况总共出现的次数. 在最坏情况下, 这一项相比交换总数可以 **忽略不计**, 而在最好情况下, 这一项等于 $1$. $\blacksquare$

(注: 为了方便理解此处的额外项恰好是原书描述的额外项取 **相反数再加 $N$**, 原文为 “an additional term equal to N minus the number of times the item inserted is the smallest so far”.)

对于实际应用中常见的某些类型的 **非随机数组**, 插入排序是很有效的: 当我们使用插入排序尝试对一个有序数组或所有主键均相同的数组进行排序时, 插入排序能够立即识别每个元素都在合适的位置之上 (因为其执行交换操作的内层循环判断条件就是元素是否依序排列), 此时 **其运行时间是线性的**, 而选择排序就需要 $n^2$ 级别的运行时间. 

~~~java
public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i=1; i<N; i++) {
            // insert element a[i] into the already-sorted sub-arrray:
            // [a[0], ..., a[n-2], a[n-1]]
            for (int j=i; j>0 && less(a[j], a[j-1]); j--) {
                // less(a[j], a[j-1]) == "a[j]<a[j-1]? true : false"
                // it means we only proceed the iteration iff a[j] is not being 
                // placed into the right place yet
                exch(a, j, j-1)
            }
        }
    }
}
~~~

我们下面考虑 **部分有序数组**: 

**定义**: 倒置
> 数组中两个 **顺序颠倒** 的元素称为 **倒置**.

**定义**: 部分有序数组
> 如果数组中 **倒置的数量** 小于 **数组大小的某个倍数**, 则称这个数组是 **部分有序** 的.

一些典型的部分有序数组是:
1. 数组中每个元素距离其正确位置都不远.
2. 一个有序的大数组接一个小数组.
3. 只有几个元素的位置不正确的数组.

**命题**
> 插入排序所需要的交换操作和数组中 **倒置的数量** 相同, 且有:<br>
> 倒置数量 $+$ 数组大小 $-1 \geqslant$ 需要的比较次数 $\geqslant$ 倒置的数量.

**证明**
> 插入排序执行的每一次交换都改变了 **一对顺序颠倒的元素位置**, 等价于 **减少了一对倒置**. 而当 **倒置数量为 $0$** 时, 排序就完成了, 而每次交换都和一次比较对应, 因此 (需要的比较次数 $\geqslant$ 倒置的数量); 而 $1$ 到 $N-1$ 之间的每个 $i$ 都可能需要一次 **额外的比较**, 故 (倒置数量 $+$ 数组大小 $-1 \geqslant$ 需要的比较次数). $\blacksquare$

<br>

### 对插入排序和选择排序算法的比较

下面我们讨论插入排序和选择排序的性能孰优孰劣. 比对算法的速度这个问题会在我们今后对算法的学习中反复出现. 根据 `Ch 1.4` 所介绍的方法, 我们将通过以下的步骤对比两个算法:

1. 实现并调试它们.
2. 分析它们的基本性质.
3. 对它们的相对性能作出猜想.
4. 设计并进行实验对猜想进行验证. 

在前两个小节中我们已经给出了选择排序和插入排序算法的实现, 因此我们已经完成了第一步. 而上两个小节中所描述和证明的三个命题组成了流程的第二步. 我们下面将依次完成第三步和第四步. 

在实现了算法后, 我们需要确定一个适当的输入模型. 对排序而言, 上两个小节中的三个命题使用的自然输入模型假设数组中的元素 **随机排序**, 且 **主键值不会重复**. 而对于有 **很多重复主键** 的应用而言, 我们需要一个更复杂的模型. 

我们已经知道, 对于随机排序数组, 两个算法的运行时间都是 $n^2$ 级别. 我们可由此得到下列猜想:

**性质**
> 对于 **随机排序的无重复主键的数组**, 插入排序和选择排序的运行时间是 **$n^2$ 级别** 的, 两者之比应该是一个较小的常数.

对于性能实验的设计和猜想的验证, 详见原书翻译版 $\text{P}254-257$ 页, 此处不做摘录和笔记.

<br>

### 希尔排序

下面我们讨论一种 **基于插入排序** 的快速的排序算法. 插入排序对于 **大规模乱序数组表现不佳**, 因为它只会 **交换相邻的元素**, 因为元素只能一点点的 **从数组的一端移动到另一端**. 

为了加快速度, 希尔排序通过 **交换不相邻的元素对数组的局部进行排序并最终用插入排序将局部有序的数组排序** 对插入排序进行了简单的改进. 

**定义**: $h$ 有序数组
> $h$ 有序数组是由 $h$ 个相互独立的有序数组编织在一起组成的一个数组, 在这个数组中, 任意间隔为 $h$ 的元素都是有序的. 

$h$ 为希尔排序中可自定义的一个控制被交换元素距离的参数, 其思想是让 **数组中任意间隔为 $h$ 的元素都是有序的**. 在进行排序时, 如果 $h$ 很大的话, 只需要经过一次交换我们就能将元素移动到很远的地方. 

~~~java
public class Shell {
    public static void sort(Comparable[] a) {
        int N = a.length;  
        int h = 1;
        // dynamically calculate h's val
        while (h < N/3) {
            h = 3*h + 1;
        }
        // in this implementation, we use geometric progression: 
        // [1, 3, 9, ..., N/3] for h in different iterations
        while (h >= 1) {
            for (int i=h; i<N; i++) {
                // insert a[i] into [a[i-h], a[i-2h], a[i-3h], ...]
                for (int j=i; j>=h && less(a[j], a[j-h]); j -= h) {
                    exch(a, j, j-h);
                }
            }
            h = h/3;    // decrease h after each iteration
        }
    }
}
~~~

希尔排序权衡了子数组的 **规模** 和 **有序性**. 在排序之初, 各个子数组都很短, 排序后各个子数组部分有序, 这两种情况都适合插入排序, 而子数组部分有序的程度取决于递增序列的选择.

选择递增序列是一项复杂的工作, 算法的性能取决于 $h$ 与序列中 $h$ 之间的数学性质. 我们在上文的实现中采用的简单递增序列与复杂递增序列的性能接近, 但可以证明复杂的序列在最坏情况下的性能表现是优于这个简单的序列的. 

和选择排序, 插入排序不同的是, 希尔排序也可以用于 **大型数组**, 它对任意排序的数组表现也很好. 

<br>

## 2.2 归并排序

我们在本节中将要讨论的算法都基于 **归并** 这个操作, 也就是将 **两个有序的数组** 归并成一个 **更大的有序数组**. 

一种简单的递归排序算法: **归并排序** 的工作原理就是基于这个操作之上的. 要将一个数组排序, 可以先 **递归地** 将它分成两半分别排序, 然后将结果归并起来. 归并排序能保证, 它排序 **任意长度为 $N$ 的数组** 所需要的时间和 $N\log(N)$ 成正比, 而它需要的额外空间和 $N$ 成正比. 

### 原地归并的抽象方法

实现归并的一种简单方法是将两个不同的有序数组归并到第三个数组中. 虽然我们利用两个数组中的元素都实现了 `Comparable` 接口的特性可以指甲创建一个适当大小的数组并将两个数组中的元素由小到大依次放入其中, 但在需要进行多次归并 (如对一个很大的数组排序) 时, 如果每次归并都需要创建一个新数组存储排序结果就会带来存储空间使用上的问题. 因此, 我们需要考虑一种 **能够在原地归并** 的方法, 这样就可以分别将前半部分和后半部分排序, 然后在数组中移动元素而无需使用额外的空间. 

下面我们给出一个抽象化原地归并操作的静态方法, 它将归并过程中涉及到的所有元素复制到一个辅助数组中, 然后再将归并的结果放回到原数组中:

~~~java
public static void merge(Comparable[] a, int lo, int mid, int hi) {
    // merge a[lo...mid] and a[mid+1...high]
    int i = lo;
    int j = mid+1;
    
    // first copy a[lo...high] to aux[lo...high]
    for (int k=lo; k<high; k++) {
        aux[k] = a[k];
    }

    // then merge them and modify a[]
    for (int k=lo; k<=high; k++) {
        if (i>mid) {            // used all left-side subarray
            a[k] = aux[j++];
        } else if (j>hi) {      // used all right-side subarray
            a[k] = aux[i++];
        } else if (less(aux[j], aux[i])) {  // right < left
            a[k] = aux[j++];
        } else {                            // left < right
            a[k] = aux[i++];
        }
    }
}
~~~

该方法先将 `a[]` 中的所有元素复制到新数组 `aux[]` 中, 然后再归并回 `a[]`. 方法在执行归并时进行了四个 `for` 条件判断: 左半边子数组用尽 (故取右半边), 右半边子数组用尽 (故取左半边), 右半边子数组元素小于等于左半边和左半边子数组元素小于等于右半边 (故取较小的那一个).

<br>

### 自顶向下的归并排序

我们再介绍一个基于 **原地归并的抽象实现** 实现了 **递归归并** 的算法:

~~~java
public class Merge {
    private static Comparable aux[];     // auxiliary array used in merge()
    
    public static void sort(Comparable a[]) {
        aux = new Comparable[a.length];
        sort(a, 0, a.length-1);
    }

    public static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) {
            return;
        }
        int mid = lo + (hi - lo)/2;
        sort(a, lo, mid);       // sort left side
        sort(a, mid+1, hi);     // sort right side
        merge(a, lo, mid, hi);  // then merge them finally
    }
}
~~~

要理解归并排序, 我们可以研究该方法 **调用的动态情况**. 要将 $a[0...15]$ 排序, `sort` 方法会调用自身将 $a[0...7]$ 排序, 再在其中调用自己将 $a[0..3]$ 和 $a[4..]$ 排序, 而在将 $a[0], a[1]$ 排序后才会开始反过来合并数组. 在合并回 $a[0...7]$ 后, 再去进行后续的归并. 显然, `sort()` 方法的作用实际上在于 **安排多次 `merge()` 方法调用的正确顺序**.

我们同样可以通过树状图理解下列的命题: 在图中, 每个结点都表示一个 `sort()` 方法通过 `merge()` 方法归并而成的子数组, 这棵树恰好有 $n$ 层. 对于 $0$ 到 $n-1$ 之间的任意 $k$, 自顶向下的第 $k$ 层有 $2^k$ 个子数组, 每个数组的长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较, 故每层的比较次数为 $2^k \cdot 2^{n-k} = 2^n$, $n$ 层总共为 $n \cdot 2^n = N\cdot \lg(N) ~~~ \small{(n = \lg(N)})$.

![20210913204532](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20210913204532.png)

**命题**
> 对于长度为 $N$ 的任意数组, 自顶向下的归并排序需要 $\frac{1}{2}N\cdot \lg(N)$ 到 $N\cdot \lg(N)$ 次比较. 

**证明**
> 记 $C(N)$ 表示将一个长度为 $N$ 的数组排序时所需要的比较次数. 立刻可知: $C(0) = C(1) = 0$. <br>
> 对于 $N>0$, 通过递归的 `sort()` 方法可以由相应的归纳关系得到比较次数的上限: 
> $$C(N) \leqslant C(\lfloor\frac{N}{2}\rfloor) +  C(\lceil\frac{N}{2}\rceil) + N.$$
> 其中, 不等号右侧分别为将数组左半部分和右半部分排序所用的比较次数, 以及归并所用的比较次数. 由于归并所需要的比较次数最少为 $\lfloor\frac{N}{2}\rfloor$, 故比较次数的下限是: 
> $$C(N) \geqslant C(\lfloor\frac{N}{2}\rfloor) +  C(\lceil\frac{N}{2}\rceil) + \lfloor\frac{N}{2}\rfloor.$$
> 当 $N$ 为 $2$ 的幂且等号成立时我们能得到一个解: 由于 $\lfloor\frac{N}{2}\rfloor = \lceil\frac{N}{2}\rceil = 2^{n-1}$, 可得:
> $$C(2^n) = 2\cdot C(2^{n-1}) + 2^n$$
> 即
> $$\frac{C(2^n)}{2^n} = \frac{C(2^{n-1})}{2^{n-1}} + 1$$
> 故知
> $$\frac{C(2^{n-1})}{2^{n-1}} = \frac{C(2^{n-2})}{2^{n-2}} + 1$$
> 因此有
> $$\frac{C(2^n)}{2^n} = (\frac{C(2^{n-2})}{2^{n-2}} + 1) +1$$
> 重复该替换过程可得:
> $$\frac{C(2^n)}{2^n} = (\frac{C(2^{0})}{2^{0}}+(n-1)) + 1$$
> 也就是
> $$\frac{C(2^n)}{2^n} = \frac{C(2^{0})}{2^{0}}+n$$
> 去分母得
> $$C(N) = C(2^n) = n \cdot 2^n = N\cdot \lg(N).$$

对于一般的 $N$, 对其比较次数的上下界不等式使用放缩的技巧同样不难证明前述结论成立. $\blacksquare$

<br>

**命题**
> 对于长度为 $N$ 的任意数组, 自顶向下的归并排序最多需要访问数组 $6N\cdot \lg(N)$ 次.

**证明**
> 由于在每一次归并中最多需要访问数组 $6N$ 次: $2N$ 次用于复制, $2N$ 次用于将排好序的元素移动回去, 另外最多比较 $2N$ 次, 结合上一命题立刻可得, 本命题成立. $\blacksquare$

上述的两个命题告诉我们, **归并排序所需要的时间和 $N\cdot \lg(N)$** 成正比, 远远快于我们在上一节中讨论的初级排序算法. 它表明, 我们只需要 **比便利整个数组多个对数因子的时间** 就能将整个庞大的数组排序, 这使得使用归并排序处理大小为百万级别甚至更大规模的数组在事实上可行. 相应的, 归并排序的主要缺点则是 **辅助数组所使用的额外空间和数组的大小成正比**. 不过, 通过一些细致的思考我们还可以进一步地缩短归并排序的运行时间. 

<br>

### 优化: 对小规模子数组使用插入排序

对不同的方法处理小规模问题能改善 **大多数递归数组** 的性能, 因为递归会使 **小规模问题中方法的调用过于频繁**, 因此改进对它们的处理方式就能改善整个算法. 在排序问题上, 基于上一节的讨论, 我们已经知道插入排序或选择排序非常简单, 因此它们很可能在小规模数组上比归并排序更快. 使用插入排序处理小规模的子数组 (如长度小于 $15$), 一般就可以将归并排序的运行时间缩短 $10 \sim 15 \%.$

### 优化: 测试数组是否已经有序

针对子数组有序的情况, 我们可以添加判别条件检测 $a[\text{mid}]$ 是否小于等于 $a[\text{mid+1}]$. 如果确实如此的话, 我们就可以直接将其拼接起来而跳过 `merge` 方法. 这样的优化不影响排序的递归调用, 但对于 **任意有序的子数组**, 算法的运行时间就变成线性的了.

### 优化: 不将元素复制到辅助数组

我们还可以节省将数组元素复制到用于归并的辅助数组所消耗的时间. 我们需要两种排序方法实现这一优化: 一种是将数据从输入数组排序到辅助数组, 另一种则是将数据从辅助数组排序到输入数组, 而在递归调用的每一层对输入数组和辅助数组的角色进行对换. 

<br>

### 自底向上的归并排序

递归实现的归并排序是算法中 **分治算法** 的典型应用. 实现归并排序的另一种方法是先归并那些小规模的子数组, 然后再成对归并得到的更大的子数组: 

~~~java
public class MergeBU {
    private static Comparable[] aux;    // auxiliary array used for sorting

    // merge() is identical to Merge class
    
    public static void sort(Comparable[] a) {
        int N = a.length;
        aux = new Comparable[N];
        for (int sz=1; sz<N; sz = 2 * sz) {
            for (int lo=0; lo<N-sz; lo+= 2 * sz) {
                merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
            }
        }
    }
}
~~~

自底向上的归并排序会 **多次遍历整个数组**, 根据子数组大小进行 **两两合并**. 子数组的大小 `sz` 初始值为 $1$, 每次循环加倍一次. 最后一个子数组的大小只有在数组大小为 `sz` 的偶数倍时才会与其相等, 否则它会比 `sz` 小.

**命题**
> 对于长度为 $N$ 的任意数组, 自底向上的归并排序需要 $\frac{1}{2}N\cdot \lg(N)$ 到 $N\cdot \lg(N)$ 次比较, 并最多访问数组 $6N\cdot \lg(N)$ 次.

**证明**
> 处理一个数组的遍数恰好为 $\lfloor \lg(N) \rfloor$, 而每一遍会访问数组 $6N$ 次, 比较次数介于 $\frac{N}{2}$ 和 $N$.

注意, 当数组长度为 $2$ 的幂时, 自顶向下和自底向上的归并排序所用的比较次数和数组访问次数 **恰好相同**, 只是顺序刚好相反. 在其他情况下, 二者的比较和访问数组的次序均有不同. 

自底向上的归并排序适合 **用链表组织的数据**. 这种方法只需要重新组织链表链接即可将链表 **原地排序**. 