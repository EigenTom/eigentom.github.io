---
layout:     post
title:      普林斯顿算法4-Ch2 排序
subtitle:   Sorting Algorithms
date:       2021-09-03
author:     R1NG
header-img: img/post-bg-algs4.jpg
description: 
catalog: true
tags:
    - 2021
    - 数据结构和算法
    - 扩展自习
---

# Ch2 排序

在本章中, 我们将学习数种经典的排序算法, 并实现 **优先队列** 这一基础数据类型, 讨论比较排序算法的理论基础并最后总结若干排序算法和优先队列的应用.

<br>

## 2.1 初级排序算法

我们首先研究两种 **初级的排序算法** 和其中一种的一个变体. 在此, 我们关注的主要对象是 **重新排列数组元素** 的算法, 其中 **每个元素都有一个主键**. 排序算法的目的就是将 **所有元素的主键** 按照某种方式排列, 在经过排序后索引较大的主键大于等于索引较小的. 

下面, 我们规定排序代码的结构和模板:

我们会将排序代码放在类的 `sort()` 方法中, 该类还包含辅助函数 `less()`, `exch()` 和示例用例 `main()`, 其中 `less()` 方法对元素进行比较, 而 `exch()` 方法将元素交换位置. 为了区分不同的算法, 我们还可以为相应的类取不同的名字, 用例可以按照名字调用不同的实现. 

为了确保数组的初始状态是不影响排序算法的成功与否的, 我们会在测试代码 `main()` 中添加语句 `assert isSorted(a)` 来确认经过排序后的数组元素都是有序的. 

在确认算法的有效性后, 我们还需要对其性能进行评估. 首先, 我们需要计算各个排序算法在 **不同的随机输入下的基本操作的次数** (包括比较和交换的数量. 对于不交换元素的算法, 我们需要计算访问数组的次数). 随后, 我们用这些数据来估计算法的性能. 

除此以外, 我们也需要关注排序算法的 **额外内存开销**. **原地排序算法** 是 **除了函数调用所需的栈和固定数目的实例变量之外无需额外内存** 的算法, 而需要额外内存空间来存储一份数组副本的则被列为 **其他排序算法**. 

~~~java
public class Example {
    public static void sort(Comparable[] a) {
        // see each sorting algorithms
    }

    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private static void show(Comparable[] a) {
        for (int i=0; i<a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }

    public static boolean isSorted(Comparable[] a) {
        for (int i=1; i<a.length; i++) {
            if (less(a[i], a[i-1])) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        String[] a = In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
~~~

### 选择排序

