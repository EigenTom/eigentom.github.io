---
layout:     post
title:      Ch7 函数和方法
subtitle:   Branching back and forth
date:       2020-11-16
author:     R1NG
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - COMP15111
    - 课程笔记
    - 2020
---

# Ch7 函数和方法

Motivation:
1. 了解汇编语言实现函数调用和函数嵌套调用的基本原理
2. 堆栈的实现原理
3. 一些与堆栈相关的 `ARM` 汇编指令
4. 使用堆栈对函数嵌套调用行为进行优化
5. 使用堆栈在函数和方法之间执行数据传递
   

## 1. 使用汇编语言实现函数调用和嵌套调用
     
要实现汇编语言中的函数调用和嵌套调用, 首先需要对函数调用的流程有足够的了解. 高级程序语言中的函数调用过程相对简化, 便于我们观察和理解函数调用的流程. 

### 1.1 高级程序设计语言中的函数调用和嵌套调用

我们以 `Python` 为例:
![20201210174937](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201210174937.png)

通过观察我们可知, 对函数进行调用就是传递参数, 存储函数执行完毕后将要跳转回的位置, 跳转至函数执行相应的数据处理, 最后从函数体跳转回原代码并利用函数的返回值或函数处理数据的成果的过程. 

而相应的, 在函数内, 函数要使用传递进来的参数, 在函数体内执行基于这些参数的相关数据处理, 并存储数据处理的成果, 最后跳转回原代码. 

<br>

### 1.2 汇编语言中的函数定义

高级程序设计语言下的函数定义包含了函数名, 参数列表和函数体. 函数名是在调用函数时, 将它与其他函数区隔开的依据; 参数列表表明在对该函数进行调用时需要传递给函数哪些参数, 函数体包含了函数的数据处理逻辑, 是函数的核心. 

相应地, 汇编语言中的函数定义也包含了这三个部分, 只是略有细微不同:

1. 在汇编语言中, 我们通过定义位于函数体头部的跳转标识符来对该函数进行声明. 
2. 在汇编语言中, 我们无法直接声明函数的参数列表, 它被集成在了函数体内部: 该函数所需要的数据就是该函数的参数列表. 
3. 汇编语言下所定义的函数必须具备返回值的功能: 即使是一个最简单的函数, 也必须能够在函数体执行完毕后跳转回原代码处. 
4. 汇编语言下所定义的函数必须能够控制其内部的数据流动并妥善定义并处理在函数内部所使用的寄存器, 确保函数对主程序和其他函数所使用的寄存器不造成任何影响, 防止造成数据损坏和数据污染.

下面, 简要介绍一下汇编语言下所定义的函数跳转回主程序处的实现方法和原理:

一个函数在主程序内可能被多次从不同的位置调用, 因此该函数每一次返回主程序时不能返回到相同的地址, 其跳转目标地址必须按照实际情况而定. 因此, 我们需要在函数跳转时 (更确切地说, 是跳转前) 将程序计数器的当前值, 也就是该函数对应的返回位置 (`Returning Point`) 存储下来. 在 `ARM` 架构中, 寄存器 `R14` 被指定为存储这样的返回位置的特化寄存器: `Link Register-LR` 链接寄存器.

```
                ADR LR, next_address    //LR: return address
                B function
next_address    STR R0, data            //then use the result proessed by the method (function)

;the method declared:
function        ...                     //do some calculations
                ...                     //data is calculated inside the method
                MOV PC, LR              //branch back to where the function came from
```



<br>

### 1.3 汇编语言中的函数调用

在上面的例子中, 我们了解了汇编语言中函数调用的特点和性质. 不过实际上, 在实际编程中我们执行函数跳转时所使用的是 `BL` 指令:

上述例子中涉及的跳转方法使用了 `ADR` 指令 将一个内存位置存储到链接寄存器中, 再调用分支指令 `B` 执行跳转. 该方法存在两种缺陷. 首先, `ADR` 实际上是一个伪指令, 这导致了从主程序体跳转到函数头的过程就需要执行两条指令, 执行时间上有优化空间; 其次, 在采用该方法时, 从函数体跳转到的主程序中的那条语句必须被标示 (`labeled`).  

为解决这一问题而提出的解决方法即为: 改用更先进的 `BL` (`Branch and Link`) 指令:<br>
在执行该指令时, 它通过增加程序计数器中的值可确定函数跳转回主程序体时的目标地址, 将该目标地址存入链接寄存器中, 随后跳转到被调用的函数头地址处. <br>
可以看出, `BL` 指令封装了一个标准的函数跳转流程, 可以起到 “以一抵三” 的效果. 
```
        BL function                 // it is one instruction
        STR R0, data                // then use the result processed by the method, and no need to label this!
```

至此, 单次调用函数的问题得到了完整的解决. 但是, 如果我们需要考虑函数的嵌套调用, 则会立刻发现一个新的问题: 存储目标地址的链接寄存器容量不够用了, 它只能存储一条地址. 

<br>

### 1.3 汇编语言中的函数嵌套调用

我们下面考虑进行函数嵌套调用时如何对目标地址进行妥善保存. 在对函数进行嵌套调用时, 被调用的函数, 调用的位置和调用的次数都是未知的, 并且我们需要注意, 被调用的函数不能对原函数和主程序所生成/使用的, 存储在寄存器内的数据进行我们所不希望的修改. <br>

这些行为都涉及对数据的存储和保护. 因此, 我们需要一个 “缓存区域”, 用于暂时存储这些需要被保护的关键数据, 而在它们无需再被保护时, 再从缓存区域中将它们销毁. <br>

我们可以在内存空间内预留出一段, 用于缓存区域的数据存储. 下面是一个在内存空间中预留出一个寄存器大小的缓存区域的例子:

```
        STR R4, temp    //store R4 to variable: temp
        ...
        //then the method body can use R4 safely
        ...
        LDR R4, temp    //recover the original value of R4
        MOV PC, LR

temp    DEFW 0
```

在实现了缓存区域的定义和使用后, 我们现在可以正式地考虑函数嵌套调用的问题:
1. 一个函数有可能对自身进行嵌套调用, 因此我们可能需要更大的缓存区域
2. 在内存中预留的, 固定大小的缓存空间可能根本不会被使用, 或者只有部分被使用而其余部分始终空置, 由此造成了存储空间的浪费.

因此, 我们需要用一种新的方法在内存空间中定义一种动态可变的缓存区域. 

<br>

## 2. 堆栈
堆栈的出现解决了上述的问题. 

### 2.1 堆栈模型

我们可以将堆栈想象为一个无限容量的单列弹夹中所有子弹所组成的集合. 在这样的数据结构中, 我们能且只能从顶端将新的子弹 “弹入” ("Push") 弹夹或从弹夹中 “弹出” ("Pop").  

### 2.2 堆栈实现

在绝大多数的计算机架构中, 通常以一个很大的内存地址为栈头, 并随着栈长的增加, 栈头所在位置依次向前递减. <br>
`ARM` 架构定义了一个特化寄存器 `R13` 作为 **栈指针寄存器** (`Stack Pointer Register`), 简称为 `SP`. <br>

## 3. 堆栈相关的 `ARM` 汇编指令

## 4. 优化函数的嵌套调用

### 4.1 嵌套调用中的链接寄存器数据保护

### 4.2 嵌套调用中的一般寄存器数据保护

### 4.3 嵌套调用中涉及的寄存器数据传递


## 5. 使用堆栈执行函数间数据传递