---
layout:     post
title:      高级计算机图形学:色彩和动画
subtitle:   Color & Animation
date:       2022-10-10
author:     R1NG
header-img: img/post-bg-comp37111.jpg
description: 本章主要介绍对颜色的建模和关于动画的简单概念.
catalog: true
tags:
    - 课程笔记
    - 高级计算机图形学
---

# 色彩和动画

我们将在本章中简介对 **色彩** 的建模, 一般概念和具体表示, 并对动画的概念进行简单介绍.

## 色彩

### 物理学: 光
拥有色彩的是 **可见光** (`Visible Light`). 可见光是 **波长位于肉眼可视范围内**, 即 $450 - 700\text{nm}$ 范围内的 **电磁波**, 可见光的特征由其 **光谱** (`Spectrum`) 所描述. 它展现的是给定可见光中, 在整个可见光谱范围内, **每一种不同波长的光的相对能量大小**. 由于光的波长是 **无限可分** 的, 因此光谱图实际上是一条 **曲线**, 如下图所示:

![20221012123556](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012123556.png)

每一种光的光谱 (等价地, 或称颜色信号图) 都不相同, 我们可以使用一些工具将复合光还原. 从物理实验中的知识可知, 我们可用棱镜 (`Prism`) 或衍射光栅 (`Diffusion Grating`) 将复合光还原成组成它的多种彩色光:

![20221012125142](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012125142.png)

进一步地, 被成像设备 (传感器, 肉眼视网膜, 胶片等) 所接收到的光的 **光谱** 由 **不同波长的光本身包含的能量强度** 和 **不同波长的光在平面上反射造成的能量损失** 共同决定:

![20221012133616](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012133616.png)

换言之, 成像设备所接收到光的光谱不仅和这束光本身的组成有关, 同时和光反射的不同表面也有关系. 光在物体表面的反射是非常复杂的物理过程, 但可以被近似认为 “不同波长的光在不同种类的物体上反射之后其能量强度有所衰减”. 因此光谱图 (或色彩信号图) 中每个横轴 (波长) 对应的纵轴值 (能量强度) 就可被近似认为是: **特定波长的光本身包含的能量强度和物体表面对这一波长的光的反射系数的乘积**.

### 生物学: 光感细胞

视网膜上的光感细胞分为具有感知颜色功能的 **视锥细胞** (`Cone Cell`) 和擅长捕捉低亮度光源的 **视杆细胞** (`Rod Cell`). 其中, 视锥细胞分为可感知 **红, 绿, 蓝** 三原色的三种细胞 (`L`, `M`, `S`), 每种视锥细胞对光的感知强度都有不同, 这种对不同波长光的感知差异可以用下列的图表所表示:

![20221012140804](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012140804.png)

视锥细胞对给定的复合光所产生的刺激 (`Stimulus`) 可被计算为 **该复合光所包含的对应波长纯色光的信号强度** 和 **该类视锥细胞对这一纯色光的反馈强度** 乘积的 **积分**. 此处需要注意: 在任何情况下光对细胞产生的刺激 **总是正的**.

而由于这三种细胞在视网膜上同时存在, 因此整个视网膜的感光反馈 (`Respond`) 可被简单地 **线性叠加**. 

肉眼可感知的三原色恰好可以通过 **不同比例的混合** 构造出所有可见的颜色. 如下图所示, 显示器中的每个像素点都由 **红, 绿, 蓝** 三个子像素点组成, 通过调控子像素光强即可混合出不同的颜色.

![20221012141035](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012141035.png)

使用三原色构造出其他颜色的方法分为 **加色法** (`Color Additive Method`) 和 **减色法** (`Color Subtractive Method`). 下图中, 左侧展示的是通过加色法, 从三原色直接生成的不同颜色. 此处我们假设每个颜色通道取值都为 $0-255$, 可知三种颜色通过加色法混合后得到的是 $(255, 255, 255)$, 也就是说中心必为 **白色**, 对减色法来说中心就是深色. 一般地, 显示器基于加色法混合颜色, 而减色法用于印刷和染色.

![20221012141332](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012141332.png)

从不同波长的光强的角度看, 加色法和减色法所进行的操作实际就是对 **两种光谱不同的混合光** 的光谱曲线进行的 **叠加** 或 **相减** 操作. 如下图所示, 考虑混合光 $C_1$ (表为橙色) 和 $C_2$ (表为紫色), 则左侧和右侧的图分别表示通过加色法和减色法得到的光.

![20221012212504](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012212504.png)

需要注意, 由于不同视锥细胞对光的感知范围是 **部分重叠** 的, 因此如果我们将某束混合光中的蓝光部分 (也就是 $S$ 视锥细胞感知到的部分) 光强 **减半**, 得到的光在肉眼感知上并不是 “蓝色部分强度减半而其他不变”, 因为如下图所示, **蓝光部分其实和另两种视锥细胞的感知范围相重合**, 对这一范围的纯色光的强度所进行的削减同样会影响其他类别的视锥细胞对绿色和红色的感知.

### 光学: 基本概念

随后回顾一些基本概念: 

**定义** (强度)
> 光的 **强度** (`Intensity`) 由辐射量所定义, 单位为 `cd/m^2` (坎德拉/平方米), 在光谱图中表示为 **曲线和坐标轴围成的面积**. 因此, 若光线中某种纯色光的光强越大, 它在光谱图中对应的 $y$ 轴高度则越高.


**定义** (色相)
> 光的 **色相** (`Hue`) 指的是人眼所实际感受到的颜色, 由 **光谱图中占主导地位 (`Predominant`) 的纯色光波长** 决定.
> 
>如下图所示: 三束人眼分别感受为 **蓝色, 黄色和红色** 的光的光谱图如下, 它们的主导色就是光谱曲线最高点对应的波长: 即虚线所示的部分.
>
> ![20221012213722](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012213722.png)
> 

**定义** (饱和度 | 色彩浓度)
> 光的 **饱和度 | 色彩浓度** (`Saturation | Chroma`) 描述了 **色彩的鲜艳程度**, 取决于该色中 **含色成分** 和 **消色成分** (`Achromatic`) 的比例: 含色成分越大则饱和度越大, 反之亦然. 在光谱图中, 表现为色彩分布曲线相对最高的均值位置的聚集程度 (方差). 聚集程度越高, 则饱和度越大. 

不难看出, 光的 **强度**, **饱和度** 和 **色相** 不可单独调整, 牵一发而动全身. 我们有下列的 `HSI` 色彩模型描述这三个参数的关系:

![20221012214604](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012214604.png)

### 标准: 色彩空间

为了 **准确地, 标准化地** 描述和还原颜色, 我们需要 **标准化** 颜色的描述方式: 使用 **色彩空间**. 

色彩空间可以用多种方式定义, 即使我们使用视锥细胞的光强反馈图 (`Cone Response`) 表示也是可以的. 由于人类的色彩视觉是 **三维** 且 **线性** 的, 我们可将不同色彩 **在三维空间内描述**. 最常用的色彩空间定义是 `CIE-XYZ`.

在 `CIE` 色彩标准诞生的年代尚无计算机和其他一系列先进的测量设备. 在那个年代, 确定光中三原色分布的方式是:

构造一个从中间完全隔断的光屏, 左侧打入 **被测光源**, 右侧打入 **由红, 绿, 蓝三原色混合而成的光**, 令被试者观察二者的差异. 手动调价三原色的混合比例直到被试者 **看不出区别**, 此时就得到了被测光源的 **三原色混合比例**.

![20221012215310](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012215310.png)

将这样的测试对全光谱范围内的绝大多数光做一遍, 就得到了不同光的三原色混合比例. `CIE` 标准还规定了作为色彩空间的基色的三原色的波长为:

1. 蓝色: $435.8$ nm
2. 绿色: $541.6$ nm
3. 红色: $700$ nm

此外, 不同色彩空间内的表示可以被 **互相转换**. 在其他色彩空间下定义的颜色经过表示上的转换后就可以在 `CIE-XYZ` 色彩空间中表示为三基色的合成. 三基色的权重也被称为 **三刺激值** (`Tristimulus Values`).

由于其他色彩空间选用的基色波长不同, 一些颜色经过转换后对应的刺激值可能是 **负值**. 在这种情况下, 需要使用其他基色的光补光.

考虑下面的例子: 假设人眼视锥细胞的实际感光曲线如下图所示, 则视网膜在感受竖虚线所描述的光时, 其实际感受方式是: **主要感受蓝光和绿光的两种视锥细胞在这一波长的光下给予了不同的正反馈**, 而感受红光的视锥细胞给予了负反馈, **三者叠加** 得到了视网膜对这种光的总反馈, 但这并非色彩空间定义颜色的方式, 这样的色彩也无法被色彩空间 **直接表示**.

![20221012220323](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012220323.png)

解决方案就是 **使用另两种基色补光** 以 **填充掉特定类型视锥细胞对这一波长颜色的负反馈**, 如下图所示:

![20221012220527](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012220527.png)

和其他色彩标准一样, `CIE` 标准定义的色彩空间是 **三维的**. 为了方便展示和理解, 我们将色彩空间 **投影到二维平面上**, 就得到了 **色度图** (`Chromaticity Diagram`). 并且, 实际色彩空间中构成给定颜色的三刺激值 $X, Y, Z$ 和色度图中的横纵坐标 $x, y$ 之间的关系如下图所示. 注意: 在将色彩空间映射到二维平面上得到色度图后, 原本的色彩明暗度信息就会丢失.

![20221012220841](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221012220841.png)

### 伽马校正

**伽马校正** (`Gamma Correction`) 是一种用于编码和解码视频或图像中 **亮度** 或 **三刺激值** 的 **非线性操作**, 其目的是: 利用人类感知光线和颜色的 **非线性方式**: 人对较暗色调之间的相对差异相比浅色调而言更敏感, 从而让暗色的过渡更平滑, 防止出现肉眼可见的断层.

## 动画

回顾之前的内容, 我们已经介绍了曲线建模, 曲面建模和色彩标准, 下一步我们将简介 **动画** 的基本定义和原则. 

动画基本是在 **建模** 基础上的扩展延伸, 其描述的是模型在时间上一系列的连续 **变换** 或 **动作**, 得到的是一系列基于时间顺序的流畅, 连续的图片.

对于电影, 最基本的 “流畅帧率” 为 $24\text{fps}$, 而对 `VR` 而言则需要至少 $90\text{fps}$.

从 **动画制作人** 的角度, 我们需要了解 `Rigging`, `Skinning` 和 `Posing`. 而从 **数据驱动的动画** 角度, 我们将简要讨论如何通过 **动作捕捉** (`Motion Capture`) 制作和得到动画; 若考虑 **基于过程的动画** (`Procedual Animation`), 所需要考虑的是如何进行 **物理建模** (`Physical Simulation`), 如 **织物模拟**.

### 基本概念: 挤压, 拉伸和时序

最基本的概念是 **挤压** (`Squash`) 和 **拉伸** (`Stretch`). **挤压** 指用外力将物体压平, 或物体对自身施加类似的压力. 而 **拉伸** 的目的是 **加速**, 并同时和 **挤压** 形成明显的对比. 

![20221013155705](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221013155705.png)

另一个重要概念是 **时序** (`Timing`). 物体的重量受其时序的影响: 更轻的物体运动的速度更快. 同时, 时序也会对动画的插值产生影响: 运动速度不同的物体在相同时间差之间的两帧动画之间运动的距离不同, 要在这段时间内补帧, 插值得到的中间帧上物体的位置也会有所不同.

### 对物体运动的建模和描述

下面讨论如何描述和建模物体在场景中的运动. 

对物体运动的描述有两种类别: 第一种是以动画, 电影为首的 `Production`: 预先设定好场景中物体的运动轨迹, 然后在 **完整渲染出动画后** 直接播放. 由于有充足的时间和资源进行计算, 我们可以得到视觉效果更好的产品; 另一种 `Interactive` 以游戏和虚拟现实为例: 使用者可以和场景中的物体进行交互, 实时改变物体的运动方式与轨迹. 由于对延迟的要求极高, 因此难以实现如同 `Production` 一般的真实度和质量.

### 关键帧和补帧

前面已经提到, 对电影, 视频和虚拟现实或游戏, 满足基本需求的动画帧速率为 $24$, $30$ 和 $90$. 显然我们不可能在生产中进行 **逐帧绘制**, 因此需要求助于 **关键帧** 技术 (`Keyframe`). 其基本思想是: 只手动绘制描述动画 **关键节点** 的数帧 (也就是关键帧), 然后对关键帧之间缺失的部分进行 **自动插值补帧**, 也称 `Tweening`.

![20221013160816](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221013160816.png)

### 过程式动画生成

过程式动画生成的基本思想是: 使用 **确定的函数表达式**, 基于一系列 **参数** 对物体的运动进行 **描述** 和 **控制**. 比较常见的例子包括 **对时钟的时针, 分针和秒针建模**, 以及对 **随风摆动的草地** 和 **逐渐消散的白云** 建模等. 这些动画共同的特点是: 它们所包含的运动具有 **确定性**, 可以被准确清晰地描述. 

### 基于物理建模的动画生成

基于物理建模的动画生成的基本思想是: 对动画中物体的运动进行 **物理建模**, 比如对虚拟空间的物体赋予 **物理属性**, 比如质量等参数, 并对物体进行受力分析, 通过建模描述不同的, 施加在物体上力的变化来刻画物体随时间的运动状态. 常见的例子有刚体模拟, 流体模拟等. 

用这种方式生成的动画贴近现实, 但也很难控制, 因为物体的运动状态不仅受建模的物理规律影响, 和它被赋予的物理属性也有关系, 因此难以通过控制一些简单的参数来修改物体的运动行为.

### 对物体运动状态的控制: 骨架装配

为了能够使用简单的参数 (`Low dimensional control`) 对物体的运动状态进行控制, 我们需要考虑 **在物体的不同运动状态下对物体模型重建模之外的方法**. 

比较简单的一种 **结构化控制方式** 是 **控制物体关节屈伸的角度** 或 **物体骨骼的形变**. 显然, 相比调整描述物体运动状态的表达式或在每个关键帧都对物体依据理想的动作重新建模, 通过给物体 **赋予骨架 | 骨骼** (`Skeleton`) 并使用技术手段让物体的 **贴图, 内构** 等元素 **随着骨架一起运动**, 只需控制骨架的运动就可 **间接控制物体的运动**. 这一过程也称 **骨架装配** (`Rigging`).

表达式骨架装配 (`Articulated Skeleton`) 需要包含下列的信息:

1. 模型中的贴图等元素需要 **附着在骨架的哪个部分和哪个位置上**.
2. 骨架的层级结构是什么样的.
3. 骨架中有哪些 **关节** (`Joints`), 它们分别在什么位置上.

并且显然, 骨架的描述是不能包含 **环** 的. 需要注意: 在骨架中, 对关节角度的控制也属于 `Low dimensional control`.

### 对关节角度的计算: 正向和反向动力学

![20221017093106](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221017093106.png)

正向动力学 (`Foward kinematics`) 的基本假设是: 物体骨架上的每一个关节的状态都是 **根据 `Rigging` 的层级控制链来一级级地计算出来的**, 换言之在构建动画的关键帧时需要 **对每一个不同的关节点 (`Joint`)单独调整位置**. 比如, 如果要构造一个抬手的动作, 在正向动力学中就首先需要调整手臂和肩膀处的关节角度, 然后调整肘关节, 最后设置手腕关节的角度. 

显然, 基于正向动力学的动作调整需要耗费更多的时间, 但好处是每一个关节的角度和状态都可被 **单独调整**, 因此它可以为我们提供更多的控制自由, 为角色调整出更多的动作和姿态的控制方式.

比如在上面的图中, 我们就需要提供关节角度 $(\theta_1, \theta_2)$, 从而让建模软件 **通过计算确定肢体末端位置 $p$**, 这也是骨架装配的一个重要步骤.

![20221017093222](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221017093222.png)

反向动力学 (`Inverse Kinematics`) 的基本假设则是: **`Rigging` 层级中的子节点可以反过来影响父级节点的运动**. 换言之, 在构建动画的关键帧时我们可以只对模型的某个肢体的 **最下层关节角度设置一个数值**, 然后这个在抽象的层级中位于最下层的关节之上, 其余每一层的关节角度就可以基于一定的规则被 **自动计算出来**, 由此大量节约了编辑动画关键帧的时间.

比如在上面的图中, 我们给定了这个物体肢体的最终状态 (`End Effector`), 然后基于给定的约束条件, 建模软件就需要 **计算出满足约束条件的一组关节角度 $(\theta_1, \theta_2)$**. 一方面我们可以用这种方式 **限制物体肢体末端的位置 $p$ 在运动过程中始终保持不变**, 同时也可以 **通过只调整 $p$ 的位置来改变物体的肢体形态**.

需要注意的是, 如果使用反向动力学, 给定一系列约束要求计算出关节角度, 在这个约束下 **可能无解**, 也可能有 **多个可行解**, 因此反向动力学中基于约束对关节角度的计算总体上来看还是一个很复杂的问题. 

总地来说, 基于动力学方法对关节角度的确定逻辑相对简单并容易实现, 但正向动力学方法耗时较长, 需要人为调整肢体姿态, 而反向动力学计算出的角度不仅可能违背肢体的实际运动规律 (比如: 手臂的屈伸角度是有限的), 还可能违背了现实的物理规律, 使生成的动画看上去不真实.

### 用现实世界的数据逃大课: 动作捕捉

我们上面已经讨论了基于物理建模和动力学方法确定关节角度从而描述和控制物体姿态的方法, 显然上述的方法是复杂且存在局限性的. 

实际生产中, 我们还可以使用动作捕捉设备直接收集物体在 **真实的世界中** 基于 **全部的物理规律和肢体动作的限制** 所产生的运动数据. 

这一方法的优势在于: 实际上对角度的计算是 **基于现实的物理规则和条件约束** 在 **现实世界中** 真实 “演算” 而来的, 因此必然无限贴近我们认知上的 “真实”. 同时, 由于无需进行计算, 这也大大节约了计算资源, 唯一需要解决的问题就是: 如何用足够高的精度收集现实中的数据.

在动作捕捉方法中, 要利用所收集的运动数据, 就需要解决 **如何将从动捕演员肢体的关键点上收集的运动数据转换为模型的骨骼运动数据** 的问题. 这一过程称为 **重定向** (`Retargeting`).

![20221017094738](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221017094738.png)

至此我们已经了解了从两个方向对模型的运动状态进行捕捉或模拟的方法, 下面讨论 **将模型贴图 (蒙皮)** 和模型骨架的运动相结合的问题.

### 结合模型的纹理贴图与骨架: 蒙皮

蒙皮 (`Skinning`) 解决的是如何将贴图和骨架相结合, 一起运动的问题. 

蒙皮这一流程的目标是: 将贴图的 **适当位置** 和 **骨架的适当位置** 相 **绑定**, 从而使贴图可以和骨架结合在一起并 **毫无违和感的运动**.

完成蒙皮步骤的一种方法称为 **骨骼子空间变形** `Skeleton Subspace Deformation`, 也称 **线性混合蒙皮** (`Linear-Blend Skinning`) 或 **遮罩** (`Enveloping`). 

最简单的蒙皮方法是:  **为每一块 “皮肤” 都对应到一块 “骨骼” 上**. 但这种做法的问题是: 骨骼在运动时, 其周围的空间会发生变形, 进而会导致理论上皮肤也需要变形 (其实, 这也就是为什么在现实中动物的皮肤是柔软而有弹性的). 而直接一一对应的方法会导致蒙皮表现为 **刚体** (`Rigid Body`), 在骨骼运动时会发生 **撕裂**. 

![20221017101304](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221017101304.png)

因此更合理的方法是: (尤其是在关节处) 把皮肤绑定到相连的多个骨骼上, 然后把骨骼的每一个关节衔接处都看成是一个 **顶点**, 为相邻的骨骼赋予不同的, **非负** 且 **总和为 $1$** 的 **权重**. 

然后, 皮肤在这个关节运动时, 经过拉伸后每个位置的实际坐标 就可以表示为 **它在不同骨骼的绑定点的坐标和对应权重的加权和**:

![20221017101609](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221017101609.png)

## 基于物理规则的动画

在上面的讨论中, 我们已经陆续介绍了 **基于关键帧技术的动画**, **基于过程描述的动画** 和 **基于物理规则的动画**. 本节我们将着重讨论最后一种动画构建方法的具体技术细节.

一种常用于模拟 **烟尘** 和 **流体**, 如烟雾, 海浪, 火焰等的方法为 **粒子系统模拟**, 而对 **布料** 的模拟方法一般是 **弹簧系统** (`Massive Spring`). 

回顾之前对基于物理规则构建的动画的设计流程: 为物体赋予诸如所受的力, 质量等基本属性, 并结合其他约束条件构造方程, 并通过对方程求解得到物体在不同时间点上的运动状态. 

不同的物体类型, 如 **点** (`Point`), **刚体** (`Rigid Body`) 和 **柔性物体** (`Deformable Body`) 的物理规则各不相同. 下面讨论对由 **点 | 粒子** (`Point | Particle`) 组成的系统的物理模拟. 

### 粒子系统模拟 (`Particle System`)

典型的粒子系统由 **海量的点状粒子** (`Point Particles`) 组成, 每个粒子都有其自身的 **运动状态**: **当前位置, 速度, 加速度等**, 在不同的情形下可能还需要考虑粒子的 **已存在时间 (寿命) 和它的颜色**.

粒子系统的定义实际上介于 **过程式动画模拟** 和 **基于物理规则的动画模拟** 之间. 

对粒子的模拟从 “将粒子射入到三维空间中” 起步. 成千上万的粒子可以从喷射器, 瀑布, 枪口, 烟囱, 管道等任何位置 “射出”. 

在粒子进入到三维空间中之后, 就需要对这些被排出的粒子施加 **相应的力**, 如重力, 阻力, 推力等, 换言之就是需要对每一个粒子进行受力分析.

在完成受力分析后, 还需要基于 **力学定律** (`Laws of Mechanics`), 使用上一步受力分析的结果计算出粒子运动状态的改变. 值得注意的是, 一般而言决定粒子运动状态改变程度的公式都是 **常微分方程** (`ODE`).

如果我们需要建模的粒子系统满足:

1. 粒子之间彼此 **独立**, 不会互相影响各自的运动状态.
2. 粒子的喷射 (产生) 具有充分的 **随机性**.
3. 所产生的粒子拥有无限长的 **生命周期**

则在这种情况下通过粒子模拟会得到非常好的效果, 如模拟 **瀑布**, **沙漠**, **灰尘** 等. 

粒子系统模拟既可以作为一种巧妙的, 让 **被模拟的物体看上去栩栩如生** 的技术 (`Hack`), 也可以被用来进行 **对现实世界中特定物体或物理问题的严肃模拟**.

### 弹簧系统和柔性表面 (`Massive Spring & Deformable Surfaces`)

弹簧系统常用于建模以布料为例的 **柔性表面**, 它可被视为粒子系统的扩展. 在粒子系统中, 相邻粒子之间彼此不会相互作用, 但弹簧系统的假设是: 仍然用一系列粒子表示某个曲面, 但在这个由大量粒子组成的网格 (`Grid`) 中, 相邻的粒子之间会通过 **相互作用力** 防止曲面被撕裂, 保证它的 **一致性** (`Coherence`).

## 求解常微分方程

以上就是本课程所需要介绍的两种物理模拟方法, 下面我们讨论如何求解实际表示物理模拟的一类公式:  **常微分方程**.

我们可以使用一系列常见的方法和模型对常微分方程求解.

### 对质点求解位移向量: 牛顿法

对质点而言, 它所受到的力 $F$ 可以表示为 **其质量和加速度的积**, 同时可知, 其加速度等价于它 **单位时间内位移向量关于时间 $t$的二阶导数** (对位移向量关于时间的一阶导数是速度, 二阶导数自然是加速度). 进一步地可用最简单的变量代换法将得到的二阶常微分方程降为一次常微分方程组, 然后就可以求解出所需要的变量 $x$.

![20221018114157](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221018114157.png)

通过对微分方程降次并求解, 从而求得位移向量 $x$ 的方法被称为 `Newtonian`.


### 用折线逼近曲线求解位移向量: 欧拉法

下面考虑一个最简单的例子: 在一条位于二维平面的一维直线上, 从 $x_n$ 开始沿着 $x$ 轴 **反向** 运动. 给定当前位置 $x_n$ 可知对应的 $y$ 值和曲线在当前点的切线 (标为红色), 自然可知所需预测的下一个位置就是 **切线关于 $x$ 轴的交点**.

![20221018115246](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221018115246.png)

再考虑一个更复杂的例子. 考虑在如下图所示的向量场中, 从红点 $X(t)$ 出发, 经过时间 $t$, 要求在下一时刻红点可能在的位置是什么. 

![20221018115501](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221018115501.png)

如果使用欧拉法, 则我们假设 **在所经过的 $t$ 时间中, 红点的加速度方向向量不发生变化**, 因此它的运动轨迹就是一条 **直线段**, 上图中绿色的箭头所指的就是它经过 $t$ 后到达的位置,

如果使用牛顿法, 我们将得到下图所示的常微分方程组:

![20221018115433](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221018115433.png)


可见欧拉法估计位移向量的方式明显比求解常微分方程要简单的多. 但由于在欧拉法中我们 **使用折线对曲线进行估计**, 因此在每次估计的过程中都不可避免地会引入 **误差**.

![20221018115715](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221018115715.png)

如上图所示, 如果使用欧拉法对一个实际上是 **圆** 的质点运动轨迹进行估计, 最后得到的折线首尾相连之后得到的轨迹是 **发散出去** 的.

## 对物体受力进行建模

下面我们讨论如何对 **物体的受力** 进行建模. 要解决这个问题, 首先需要讨论: 物体会受到哪些不同的力, 它们分别有什么样的性质.

物体可以受到的力有多种类型, 如 **重力**, **弹力**, **阻力** 等. 物体的受力大小, 方向和类型可能取决于物体的速度, 当前的时间, 它所处的地点等不同因素.

对质点而言, 它所受的力可表示为 **向量**, 其模长就是受力大小, 指向就是所受力的方向. 将质点所受到的力的向量进行 **向量求和** 就得到了它所受的 **合力**.

### 重力

重力就是一种 **只和质点的质量相关** 的力. 在高中物理中我们已经得知了重力的计算公式, 此处不再赘述.

值得一提的是, 一种模拟烟尘的方式就是: 对每个质点, 在给定重力的情况下, 将其所受的重力反转, 将其视为 **浮力** (`Buoyancy`), 就可以得到不错的模拟效果.

需要注意, 某个质点所受的重力 **取决于其他所有的质点对它施加的重力**.

### 粘性阻力 (`Viscous Damping`)

施加在粒子上的粘性阻力大小取决于它的 **速度**. 阻力的作用是 **抵抗物体的运动** 并 **消耗物体的动能**, 从而迫使物体回到静止状态. 

为物体设置运动时受到阻力的程度不同会影响物体表现出的状态. 若为它设立较小的阻力数值, 则会让物体的运动表现得更稳定, 但若设立的数值过大则会让它体现出 **粘滞性** 等非牛顿流体的性质, 比如蜂蜜.

### 空间场力 (`Spacial Force`)

空间场力的大小和方向完全取决于物体在空间中的 **位置**. 场力对物体的作用效果同样可能取决于时间等多种因素, 描述它作用效果的公式同样是 **常微分方程**, 可以使用牛顿法或欧拉法求解. 

需要注意, 空间场力同样会为物体 **带来动能**, 因此在一些情况下需要增加粘性阻力来抗衡它.

同时, 场力也可能是 **过程性** 的, 可以通过定义过程性的运动描述公式来刻画它, 比如流体对处于其内部的质点产生的推力等.


### 毛发和布料模拟

除此之外, 还有其他的一些不属于质点范畴的物体. 以布料为例, 组成布料的 “粒子” 之间就存在着相互作用关系.

下面首先考虑最简单的情况: **毛发模拟**.

将一根毛发考虑为由数个关键点组成的折线, 下面需要考虑关键点之间的作用力. 显然, 除了终点之外, 其他的关键点都和另外两个关键点相邻.

![20221018162740](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221018162740.png)

我们可以将关键点之间的连接视为 **弹簧**, 这样的话就可使用 **胡克定律** 计算这些关键点所受到的力.

![20221018162849](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221018162849.png)

而要对布料进行模拟, 将考虑的范围从一维直线扩展到二维平面即可.