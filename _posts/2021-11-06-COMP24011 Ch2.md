---
layout:     post
title:      约束满足问题
subtitle:   Constraint Satisfation
date:       2021-11-06
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: 本章将介绍约束满足问题及其处理方法.
catalog: true
tags:
    - 2021
    - 课程笔记
    - COMP24011
---

# 约束满足问题

在本章中, 我们将解释 **约束满足问题** 的定义和对它的建模方式, 并将其形式化为搜索问题. 

## 1. 对约束满足问题的定义和建模

**定义 1.1** (约束满足问题)
> 我们称 要求我们针对 **给定的一组变量** 以及这些变量的 **需要满足的一些限制和约束条件**, 找出 **符合这些所有限制条件** 的解的问题为 **约束满足问题** (`Constraint Satisfaction Problem`), 又称 **约束满足网络** (`Constraint Satisfaction Network`).

形式上, 约束满足问题为一个三元组 $\mathcal{N} = <\bar{x}, \bar{D}, C>$, 其中:

1. $\bar{x}$ 为 **变量集合** $\{x_1, \cdots, x_n\}.$
2. $\bar{D}$ 为 **值域集合** $\{D_1, \cdots, D_n\}$, 每个 $D_i$ 分别对应值域集合中的 $x_i$. 
3. $C$ 为描述变量取值的 **约束集合**: <br>
    $C$ 中的每个元素均为有序对 
    
    $$<\text{scope}, \text{relation}>$$

    其中 $\text{scope}$ 为约束中的变量组 (若只涉及两个变量就是变量对), $\text{relation}$ 为变量组中涉及的变量 **需要满足的关系**. 

    如考虑变量 $X_1, X_2$, 要求它们必须满足关系 $X_1 \neq X_2$, 则可以将该约束表示为这样的有序对:

    $$<(X_1, X_2), X_1 \neq X_2>.$$

我们下面定义 **状态空间** 和 **解** 的概念:

**定义 1.2** (状态空间)
> 称由 **状态** 组成的集合为给定问题的 **状态空间**. **状态** 为对部分或全体变量的一个 **赋值**. 

**定义 1.3** (赋值的相容性与完整性)
> 若某个赋值 **不违反任何约束条件**, 则称其为 **相容的**, 也称为 **合法的**. 
>
> 若某个赋值中, **所有的变量均被赋值**, 则称其为 **完整赋值**. 反之, 则称为 **部分赋值**.

**定义 1.4** (约束满足问题的解)
> 称某个问题的任何 **相容且完整** 的赋值为该问题的解. 

**定义 1.5** (约束)
> 称只限制单个变量取值的约束为 **一元约束**, 与两个变量相关的约束为 **二元约束**.
>
> 违反直觉的是, **变量个数任意** 的约束称为 **全局约束** (但它不一定涉及问题中的所有变量). 要求约束中的所有变量取值必须互异的约束 `Alldiff` 就是一种全局约束.

若我们考虑约束中变量可取值的范围, 就会对问题的难易程度和处理方式产生直接影响. 

最简单的 `CSP` 问题涉及的变量是 **离散且值域有限** 的, 若值域无限, 则我们只能使用 **约束语言** 而非像有限值域情形下那样枚举受约束变量的所有可能取值. 我们在这里暂不考虑值域无限的情形. 

<br>

## 2. 约束传播 (`Constraint Propogation`)

在上一章中, 我们已经介绍了数种常见的可用于解决一些问题的状态空间搜索算法. 这些算法唯一能执行的操作只有搜索, 而在 `CSP` 中, 除了搜索之外算法还可以执行称为 **约束传播** 的逻辑推理. 由于在约束满足问题中, 对于一些变量的取值存在关系上的约束, 我们可以在利用这些约束来排除某些变量的非法取值, 缩小它的合法取值范围, 并进一步根据变量间的关系推断其他变量的取值范围, 从而无需开始搜索即可有效地对搜索树剪枝, 甚至在某些情况下将这一步骤作为搜索前的预处理, 无需真正展开搜索即可在预处理中就已经解决问题. 

约束传播的核心是 **局部相容性**: 若我们将变量视为某个图 (`Graph`) 中的节点 (`Vertices`), 变量间的约束视为图的边 (`Edges`), 则若要实现某些节点之间的局部相容性, 就必然导致其余不相容的节点被删除. 下面我们讨论几种局不相容性的定义:

**定义 2.1** (节点相容性)
> 称 **某个变量** 是 **节点相容的**, 若其值域中的所有值都满足它的 **一元约束**. 

显然, 通过执行节点相容, 我们总能消除给定 `CSP` 问题中的任何一元约束. 此外, 我们还可以将任何 $n$ 元约束转换为二元约束. 在随后的内容中, 除非特殊定义, 否则我们默认考虑的求解对象均为二元约束. 

### 2.1 弧相容

**定义 2.1.1** (弧相容性)
> 称 **某个变量** 是 **节点相容的**, 若其值域中的所有值都满足它的 **二元约束**. 
> 
> 形式的说, 对变量 $X_i, X_j$, 若对值域 $D_i$ 中的每个数值, 在 $D_j$ 中必存在另一个数值, 满足弧 $(X_i, X_j)$ 的二元约束, 则称 $X_i$ 相对 $X_j$ 为 **弧相容** 的.
> 
> 若每个变量对于其他变量都是弧相容的, 则称该网络为 **弧相容的**. 

下面介绍一个最流行的弧相容算法:

**算法 2.1.1** (`AC-3`, AIAA版)
> 为确保每个变量均为弧相容, `AC-3` 算法维护一个弧相容集合 (队列):
> 
> 在初始状态下, 该队列中包含 `CSP` 问题涉及的所有弧. 算法首先从队列中弹出某一个弧 $(X_i, X_j)$, 并尝试先使 $X_i$ 与 $X_j$ 相容. 若执行该步骤后 $D_i$ 不发生变化, 则处理下一条将要从队列中弹出的弧. 
> 
> 若 $D_i$ 因该步骤的执行而发生变化 (实际上, 这样的变化只能是缩小), 则需将每个指向 $X_i$ 的弧 $(X_k, X_i)$ 重新插入队列中检验, 因为随着 $D_i$ 的变化, 对于其他弧而言原本某些相容的解 $X_k$ 可能会变得不相容, 因此必须抓回来重新检测.
> 
> 若 $D_i$ 变成空集, 则可知该 `CSP` 问题一定没有相容解, 故算法直接返回失败结果, 否则继续检查, 持续缩小变量值域, 知道队列中不再有弧. 
> 
> 此时, 我们得到的 `CSP` 问题等价于原问题, 并且我们得到的新问题由于变量值域更小, 所需的求解时间也更短.

伪代码如下:

~~~java
// returns false if an inconsistency is found
// and true otherwise
function boolean AC3(CSP csp) {
    // inputs: `csp`, a binary CSP with components(X, D, C).
    // local variables: `queue`, a queue of arcs, initially all the arcs in `csp`

    while (queue not empty) {
        arc (X_i, X_j) = queue.pop();
        if (REVISE(csp, X_i, X_j)) {
            if (D_i.size() == 0) {
                return false;
            }
            for (node X_k: X_i.Neighbors(X_j)) {
                queue.push(new arc(X_k, X_i));
            }
        }
    }
    return true;
}

// return true iff revised the domain of X_i
function boolean REVISE(csp, X_i, X_j) {
    boolean revised = false;
    for (node x : D_i) {
        if (no_value_in_D_j_allows_(x,y)_to_satisfy_the_constraint_between_X_i_and_X_j) {
            D_i.remove(x);
            revised = true;
        }
    }
    return revised;
}
~~~

**算法 2.1.2** (`AC-3`, Slides版)
> 讲义中所描述的伪代码原理与参考教材中的基本一致, 此处解释伪代码中的数个重要记号:
> 1. $R_{i,j}$ 记为某个约束集合中的关系, 任何解都需满足这一关系.
> 2. 伪代码中的函子 $\text{revise(i, j)}$ 描述了从值域 $D_i$ 中删去 $X_i$ 的任何对于弧 $X_i, X_j$ 不相容的取值:
> 
> $$\begin{aligned}\text{revise(i,j)}:~ D_i :&= D \cap \pi_1(R_{i, j}; D_j) \\ &= \{a \in D_i \vert \exists b \in D_j, <a, b>~ \in R_{i, j}\}.\end{aligned}$$

伪代码如下:

~~~java
// returns false if an inconsistency is found
// and true otherwise
function AC3(CSP (X, D, C)) {
    // inputs: `(X, D, C)`, a binary CSP with components.
    // local variables: `Q`, a queue of arcs, initially empty, contains all the arcs in `(X, D, C)` after initialization.

    queue Q = null ;
    for (all i, j, satisfy R_{i,j} in constraint C) {
        Q.push(arc (X_i, X_j));
        Q.push(arc (X_j, X_i));
    }

    // while queue is not empty
    while (Q != null) {
        arc (X_i, X_j) = queue.pop();   // pop off some (X_i,X_j) off Q
        revise(X_i, X_j);
        if (the revise procedure causes a change in D_i) {
            //add to Q all (X_k, X_i) with R_{i,k} in C; i != k, j != k
        }
    }
}

// note the slides version doesn't cut off when it found the CSP is unsatisfiable

// and its revise() method only do the cuts in D_i but does not return any boolean value

// i.e. the pseudo code in the slides are not well implemented...
~~~

我们简单讨论一下 `AC-3` 的时间复杂度.

假设给定 `CSP` 中包含 $n$ 个变量, 变量值域的大小最大为 $d$, 并且存在 $C$ 个二元约束 (也就是 $C$ 个弧). 

对于弧 $(X_k, X_i)$, 由于 $X_i$ 至多有 $d$ 个值可删除, 故每条弧最多只能插入队列 $d$ 次, 故检查一条弧的相容性最多需要 $O(d^2)$ 才能完成. 

因此, 在最坏情况下, 算法的时间复杂度为 $O(C \cdot d^2)$.

**定义 2.1.2** (有向弧相容性)
> 称约束满足问题 $\mathcal{N} = <\bar{x}, \bar{D}, C>$ **对于变量顺序 $\bar{x} = x_1, \cdots,x_n$** 为 **有向弧相容的**, 若对
> 
> $$\forall R_{i,j} \in C, ~~ i<j, ~~ \forall a \in D_i$$
> 
> 存在 $b\in D_j$ 满足 $<a, b>  ~ \in R_{i, j}.$


<br>

### 2.2 路径相容


