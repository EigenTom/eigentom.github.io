---
layout:     post
title:      数据库导论复习 Ch3
subtitle:   REVISION
date:       2022-01-13
author:     R1NG
header-img: img/post-bg-comp23111.jpg
description: 数据库实现
catalog: true
tags:
    - 2021
    - COMP23111
---


# COMP23111 REVISION Ch3

## 3. 数据库实现

本节讨论 `SQL` 语句和部分高级功能, 并介绍 **数据库事务** 的概念和其处理方式.

### 3.1 `SQL` 基础

#### 3.1.1 选择运算: `SELECTION`

`SELECT` 语句用于从一个关系中选出 **满足选择条件** 的元组的一个子集, 我们可以将其视为一个 **过滤器**. 如果将一个关系视为一张表, 则 `SELECT` 操作相当于从这张表中按照条件选出一些行, 而丢弃另外一些行.

~~~sql
SELECT column1, column2, ...,  FROM table_name; 
~~~

以及

~~~sql
SELECT * FROM table_name;
~~~

我们可使用 `SELECT` 语句查询一个或多个属性, 并且可在语句中对属性进行数值运算:

~~~sql
SELECT u_name, u_score, u_score+10, u_score-10, u_score*2, u_score/2 
FROM T_USER;
~~~

此外, 可使用 `SELECT-WHERE` 执行 **条件查询**, 在 `WHERE` 子句中使用下列的运算符:

![20220113222029](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113222029.png)

以及使用 **与条件** (`AND`, `BETWEEN`) :

(查询` T_USER` 表中成绩大于等于 $60$ 分且小于等于 $80$ 分的学生)

~~~sql
SELECT u_name, u_score
FROM T_USER 
WHERE u_score >60 AND u_score <80;

SELECT u_name, u_score
FROM T_USER 
WHERE u_score BETWEEN 60 AND 80; 
~~~

使用 **或条件** (`OR`, `IN`):

~~~sql
# 查询分数大于90分或者小于60分的记录 (用 OR)

SELECT u_name, u_score
FROM T_USER 
WHERE u_score >90 OR u_score <60;

# 查询成绩为100，98，65的学生 (用 IN)
SELECT u_name, u_score
FROM T_USER 
WHERE u_score IN (100,98,65);
~~~

使用 **非条件** (`!=`, `NOT`):
~~~sql
# != 写法
SELECT *
FROM T_USER 
WHERE u_name != `Axton Yao`;


# NOT 写法
SELECT *
FROM T_USER 
WHERE u_name NOT LIKE `Ryan Xin`;
~~~

如果需要的话还可以为列名称和表名称指定别名:

~~~sql
SELECT `ID` AS `StudentID`, `Name` AS `StudentName` FROM `Students`;
~~~

在一些情况下, 我们可能希望从表中选取 **不重复** 的数据. 我们可以使用 `DISTINCT` 关键词:

~~~sql
SELECT DISTINCT Company FROM Orders;
~~~

#### 3.1.2 投影运算: `PROJECTION`

和 `SELECT` 不同, 投影操作可以视为从表中 **选出某些列** 而 **丢弃某些列**. 

我们可以使用 `SELECT` 语句从表中选出特定列作为表的 **投影**:

![20220113223058](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113223058.png)

#### 3.1.3 修改运算: `ALTER/UPDATE`

我们可以使用 `ALTER` 语句在 **已有的表中** 增/删表中属性, 修改属性的域, 修改属性名, 修改表名, 增/删主键:

1. 在表中添加/删除列:

~~~sql
# 添加
ALTER TABLE table_name 
ADD column_name datatype;

# 删除
ALTER TABLE table_name 
DROP COLUMN column_name;
~~~

2. 修改属性域 (列的数据类型):

~~~sql
ALTER TABLE table_name
ALTER COLUMN column_name datatype;
~~~

3. 修改属性名 (列名):

~~~sql
ALTER TABLE table_name
CHANGE COLUMN columm_name new_name
~~~

4. 修改表名:

~~~sql
ALTER TABLE table_name
RENAME TO new_name
~~~

5. 增/删主键:

~~~sql
# 删主键
ALTER TABLE table_name
DROP primary key

# 增主键
ALTER TABLE table_name
ADD CONSTRAINT pk_name PRIMARY KEY column_name
~~~

而 `UPDATE` 语句用于修改表中的数据:

~~~sql
UPDATE 表名称 SET 列名称=新值 WHERE 列名称=某值;
~~~

#### 3.1.4 联合查询: `UNION`

我们可以使用 `UNION` 子句求两个不同表中两列的重复元素, `UNION` 的作用是将 **两个 `SELECT` 语句的查询结果** 作为一个 **整体** 展示出来. 

使用 `UNION` 必须确保各个 `SELECT` 集合的结果的 **列数必须相同**, 且每个对应列的 **数据类型必须相同**, 但 **列名可以不同**.

![20220113223855](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113223855.png)

需要注意的是, `UNION` 执行的是对两个结果集的 **并集** 操作, **会筛选掉重复记录**.

#### 3.1.5 笛卡尔积运算: `CARTESIAN PRODUCT`

笛卡尔积可以视为对关系的 **乘法**, 它的效果是将 **分别来自两个数据集合中的行** 以 **所有可能的方式** 进行组合.

我们可以使用下列两种方式执行笛卡尔积:

~~~sql
SELECT * FROM table_1 CROSS JOIN table_2;

# 本质是第一种写法的语法糖
SELECT * FROM table_1, table_2;
~~~

![20220114111921](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114111921.png)

![20220114112045](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114112045.png)

#### 3.1.6 连接运算: `JOIN`

**连接** 运算可以视为 **在水平方向上** 对两个表的 **合并**, 其基本方法是: 将两个表中在共同数据项上相匹配的那些行合并.

连接运算本质是由 **一个笛卡尔积运算** 和 **一个选取运算** 所构成的: 

1. 首先用一个笛卡尔积完成对两个数据集合的乘法, 生成的结果集合包含两个数据集合中所有行的, 所有可能的组合.

2. 然后对生成的结果集合进行 **选取运算** , 确保只把 **分别来自两个数据集合** 并且 **具有重叠部分** 的行所 **合并在一起**. 

`SQL` 提供的多种连接方式之间的区别在于: 它们**在连接运算流程的第二步中** 从 **相互交叠的不同数据集合** 中选取 **用于连接的行** 时所采用的方法不同:

|连接类型|定义|
|:-|:-|
|内连接 `INNER JOIN`|包含 `Theta 连接`, `EQUI 连接` 和 `自然连接`, 只连接满足匹配条件的行, 展现出的是两表 **共同** 的数据.|
|左外连接 `LEFT JOIN`|包含左边表中的全部行 (无论是否和右表匹配), 以及右边表中所有与左边表匹配的行.|
|右外连接 `RIGHT JOIN`|包含右边表中的全部行 (无论是否和左表匹配), 以及左边表中所有与右边表匹配的行.|
|全外连接 `FULL JOIN`|包含左右表的全部行, 不考虑匹配与否, 注意与交叉连接区分.|
|交叉连接 `CROSS JOIN`|生成笛卡尔积: 考虑数据集中任意行与另一数据集中任意行的两两组合. |

下面详细说明各种连接运算:

1. 内连接:

    内连接展现的是两表 **共同** 的数据. 

    内连接又因其匹配条件的不同而被区分为`Theta 连接`, `EQUI 连接` 和 `自然连接`.

    1. `Theta 连接` 是使用 **等值以外的条件** (如大于等于, 小于等于, 不等于之类) 来匹配左右两表中行的内连接.

    2. `EQUI 连接` 是使用 **等值 (==) 条件** 来匹配左右两表中行的内连接.

    3. `自然连接` 是 `SQL` 中一种预定义的内连接, 可以视为语法糖, 它在匹配左右两表好似 **自动判断** 两表中相同名称的列, 而后形成匹配.

        我们无法在自然连接中人为指定哪些列被用于匹配, 但用于指定查询结果包含哪些列.

    ~~~sql
    # Theta连接的例子
    SELECT t1.prop, t2.char FROM table_1 t1 
    INNER JOIN table_2 t2 ON t1.axton != t2.axton;

    # EQUI连接的例子
    SELECT t1.prop, t2.char FROM table_1 t1 
    inner JOIN table_2 t2 ON t1.axton=t2.axton;

    # 注: 上面的内连接相当于:
    SELECT t1.prop, t2.char FROM table_1 t1, table_2 t2 
    WHERE t1.axton=t2.axton;

    # 自然连接的例子
    SELECT t1.prop, t2.char FROM table_1 t1 
    NATURAL JOIN table_2 t2;
    ~~~

2. 外连接:
   
   外连接不但返回符合连接和查询条件的数据行, 还 **返回不符合条件的一些其他行**. 外连接分三类: 左连接 `LEFT JOIN`, 右连接 `RIGHT JOIN` 和完整外部连接 `FULL JOIN`:
   
   1. 左连接除了返回两表中符合连接条件的数据行外, 还返回 **左表中不符合连接条件但符合查询条件的数据行**. 

        如果左表的某行在右表中没有匹配行, 则将右表对应的行处返回 **空值** 并与其连接.

    2. 右连接除了返回两表中符合连接条件的数据行外, 还返回 **右表中不符合连接条件但符合查询条件的数据行**.

        如果右表的某行在左表中没有匹配行, 则将左表对应的行处返回 **空值** 并与其连接.

    3. 完整外部链接返回左表和右表中的所有行. 若某行在另一个表中没有匹配行, 则另一个表的对应列包含 **空值**, 否则这一整行包含对应的数据值.

    ~~~sql
    # 左连接
    # 以左表为主表，右表没数据则为null
    SELECT m.Province,S.Name FROM member m 
    LEFT JOIN ShippingArea s ON m.Province=s.ShippingAreaID;

    # 右连接
    # 以右表为主表，左表没数据则为null
    SELECT m.Province,S.Name FROM member m 
    RIGHT JOIN ShippingArea s ON m.Province=s.ShippingAreaID;

    # 全外连接
    SELECT m.Province,S.Name FROM member m 
    FULL JOIN ShippingArea s ON m.Province=s.ShippingAreaID;
    ~~~


### 3.2 `SQL` 进阶

#### 3.2.1 空值: `NULL`

在 `SQL` 中, 任何 **未指定** 的数据值称为 `NULL`, 它实际上应当被视为 **一种状态** 而非属性的值:

![20220114170013](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114170013.png)

属性在下列的情况下可能被视为 `NULL`:

1. 数据值 **未知**
2. 数据值 **不可取得**
3. 数据值 **被隐藏**
4. 数据值 **不适用** (坦白说我也没搞懂不适用是什么意思)

需要注意的是, `NULL`是独立于 `True`, `False` 之外的. 执行逻辑运算时需要遵循下列的 **三值逻辑** 规则:

![20220114172714](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114172714.png)

注意, 我们不可使用 `=` 检测某个参数是否为 `NULL`. 要进行这样的检测, 需要使用关键字 `IS`:

~~~sql
# 返回的查询结果为空
SELECT name FROM VIPs 
WHERE flat = NULL;

# 返回的查询结果是正常的
SELECT name FROM VIPs 
WHERE flat IS NULL;
~~~

#### 3.2.2 排序, 取极值, 求和与计数

我们可以使用 `ORDER BY` 语句对查询的结果集进行 **排序**:

~~~sql
# ORDER BY 默认按照升序对记录进行排序
SELECT col_1, col_2 FROM table ORDER BY attribute;

# 如果需要按照降序排序记录, 需要使用 DESC 关键字
SELECT col_1, col_2 FROM table ORDER BY attribute DESC;
~~~

注意: `ORDER BY` 子句可 **同时使用多个列** 作为排序条件, 但是必须确保 **作为排序条件的每个列都在表中存在**.

我们可以使用 `MAX()` 和 `MIN()` 取表中数据列的 **极值**:

~~~sql
# 取极大值
SELECT MAX(column_name) FROM table_name;

# 取极小值
SELECT MIN(column_name) FROM table_name;
~~~

我们使用 `SUM()` 函数返回 **数值列的总数**:

~~~sql
SELECT SUM(column_name) FROM table_name;
~~~

我们使用 `COUNT()` 函数返回 **查询结果某一列项的数目**:

~~~sql
# 若考虑重复结果:
SELECT COUNT(column(s)) FROM table;

# 若要求不重复结果的数目:
SELECT COUNT(DISTINCT column(s)) FROM table;
~~~

#### 3.2.3 聚合分组 `GROUP BY`

聚合函数/集合函数 (`COUNT`, `MAX`, `MIN`, `SUM`, `AVG`) 往往需要搭配 `GROUP BY` 语句. 它用于 **结合合计函数**, 根据 **一个或多个列** 对结果集进行分组:

~~~sql
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
~~~

对聚合函数的理解如下: 考虑表

![20220114182133](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114182133.png)

执行 `SQL` 语句

~~~sql
SELECT `name` FROM 'test'
GROUP BY `name`
~~~

则其查询结果的生成过程可视为:

1. 首先 “执行” 语句中的 `FROM 'test'` 得到一张和原表一模一样的新表.

2. 然后在这张表上执行 `GROUP BY` 语句进行聚合分组, 在本例中需要基于 `name` 进行分组, 显然分组依据是将所有在 `name` 属性相同的行全部 “合并”, 此时执行结果是这样的一个虚拟的表:

    ![20220114182424](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114182424.png)

3. 接下来才需要对这个虚拟表执行 `SELECT` 后面的语句 (在此处是 `name`). 
   
   在这个例子中, 由于 `name` 列被用于 `GROUP BY`, 因此该列必然不存在重复值, 所以简单执行 `SELECT name` 就不会出错. 
   
   但如果我们需要选择那些在虚拟表中有多个数据的单元格, 如 `id`, `number`, 就不能直接选择它们, 而需要使用 **以多个数据作为输入, 输出单个数据的** 聚合函数, 将这些多数据的单元格作为输入.

   假如我们执行了

   ~~~sql
    SELECT name, SUM(number) FROM test
    GROUP BY name;
   ~~~
    
    则结果就是在 `虚拟表3` 的基础上, 对 `number` 列的每个单元格都执行 `SUM()` 聚合函数, 返回的表就是

    ![20220114183114](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114183114.png)

注: 对于 `GROUP BY` 多个字段的情况, 我们只需要将作为聚合分组依据的多个字段 **视为整体字段** 即可.


#### 3.2.4 嵌套查询语句



#### 3.2.5 视图

在 `SQL` 中, **视图** 是基于 **查询结果** 的, 可视化的表. 它包含行和列, 且字段实际上来自于被查询的一个或多个数据库中真实存在的表中. 

我们可以根据需要向视图中添加 `SQL` 函数和语句, 视图中的函数和语句不会影响被查询数据库的设计和结构.

~~~sql
# 创建 View 语法
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition

# 在创建后我们可以像查表一样查询这个View中的数据
SELECT * FROM [view_name]

# 视图可以被更新
CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition

# 也可以被撤销
SQL DROP VIEW Syntax
DROP VIEW view_name
~~~

#### 3.2.6 存储过程



#### 3.2.7 触发器


### 3.3 数据库事务的概念和处理




REFERENCE:

[SQL中SELECT语句详解](https://blog.csdn.net/u013634252/article/details/80569386)

[SQL WHERE 子句](https://www.w3school.com.cn/sql/sql_WHERE.asp)

[SQL总结（一）基本查询](https://www.cnblogs.com/yank/p/3672478.html)

[SQL ALTER TABLE 语句](https://www.w3school.com.cn/sql/sql_alter.asp)

[SQL的alter用法总结](https://blog.csdn.net/qq_41820897/article/details/100179834)

[sql中union和union all的用法](https://www.cnblogs.com/xiangxinhouse/p/6053134.html)

[SQL查询cross JOIN的用法(笛卡尔积)](https://blog.csdn.net/xiaolinyouni/article/details/6943337)

[left join 和 left outer join 的区别](https://www.cnblogs.com/cy163/archive/2008/10/16/1312920.html)

[SQL的四种连接-左外连接、右外连接、内连接、全连接](https://www.cnblogs.com/webwangjie/p/11425632.html)

[sql 内连接、外连接、自然连接等各种连接](https://www.cnblogs.com/fnlingnzb-learner/p/6343828.html)

[Understanding cartesian product in SQL](https://stackoverflow.com/questions/30955338/understanding-cartesian-product-in-sql)

[SQL VIEW（视图）](https://www.w3school.com.cn/sql/sql_view.asp)

[SQL中MAX()和MIN()函数的使用](https://www.cnblogs.com/lihaozy/archive/2013/06/03/3115110.html)

[SQL COUNT DISTINCT 函数](https://www.w3school.com.cn/sql/sql_func_count_distinct.asp)

[可以这样去理解group by和聚合函数](https://blog.csdn.net/shaofei63/article/details/42800793)