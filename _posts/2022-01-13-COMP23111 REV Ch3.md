---
layout:     post
title:      数据库导论复习 Ch3
subtitle:   REVISION
date:       2022-01-13
author:     R1NG
header-img: img/post-bg-comp23111.jpg
description: 数据库实现
catalog: true
tags:
    - 2021
    - COMP23111
---


# COMP23111 REVISION Ch3

## 3. 数据库实现

本节讨论 `SQL` 语句和部分高级功能, 并介绍 **数据库事务** 的概念和其处理方式.

### 3.1 `SQL` 基础

#### 3.1.1 选择运算: `SELECTION`

`SELECT` 语句用于从一个关系中选出 **满足选择条件** 的元组的一个子集, 我们可以将其视为一个 **过滤器**. 如果将一个关系视为一张表, 则 `SELECT` 操作相当于从这张表中按照条件选出一些行, 而丢弃另外一些行.

~~~sql
SELECT column1, column2, ...,  FROM table_name; 
~~~

以及

~~~sql
SELECT * FROM table_name;
~~~

我们可使用 `SELECT` 语句查询一个或多个属性, 并且可在语句中对属性进行数值运算:

~~~sql
SELECT u_name, u_score, u_score+10, u_score-10, u_score*2, u_score/2 
FROM T_USER;
~~~

此外, 可使用 `SELECT-WHERE` 执行 **条件查询**, 在 `WHERE` 子句中使用下列的运算符:

![20220113222029](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113222029.png)

以及使用 **与条件** (`AND`, `BETWEEN`) :

(查询` T_USER` 表中成绩大于等于 $60$ 分且小于等于 $80$ 分的学生)

~~~sql
SELECT u_name, u_score
FROM T_USER 
WHERE u_score >60 AND u_score <80;

SELECT u_name, u_score
FROM T_USER 
WHERE u_score BETWEEN 60 AND 80; 
~~~

使用 **或条件** (`OR`, `IN`):

~~~sql
# 查询分数大于90分或者小于60分的记录 (用 OR)

SELECT u_name, u_score
FROM T_USER 
WHERE u_score >90 OR u_score <60;

# 查询成绩为100，98，65的学生 (用 IN)
SELECT u_name, u_score
FROM T_USER 
WHERE u_score IN (100,98,65);
~~~

使用 **非条件** (`!=`, `NOT`):
~~~sql
# != 写法
SELECT *
FROM T_USER 
WHERE u_name != `Axton Yao`;


# NOT 写法
SELECT *
FROM T_USER 
WHERE u_name NOT LIKE `Ryan Xin`;
~~~

如果需要的话还可以为列名称和表名称指定别名:

~~~sql
SELECT `ID` AS `StudentID`, `Name` AS `StudentName` FROM `Students`;
~~~

在一些情况下, 我们可能希望从表中选取 **不重复** 的数据. 我们可以使用 `DISTINCT` 关键词:

~~~sql
SELECT DISTINCT Company FROM Orders;
~~~

#### 3.1.2 投影运算: `PROJECTION`

和 `SELECT` 不同, 投影操作可以视为从表中 **选出某些列** 而 **丢弃某些列**. 

我们可以使用 `SELECT` 语句从表中选出特定列作为表的 **投影**:

![20220113223058](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113223058.png)

#### 3.1.3 修改运算: `ALTER/UPDATE`

我们可以使用 `ALTER` 语句在 **已有的表中** 增/删表中属性, 修改属性的域, 修改属性名, 修改表名, 增/删主键:

1. 在表中添加/删除列:

~~~sql
# 添加
ALTER TABLE table_name 
ADD column_name datatype;

# 删除
ALTER TABLE table_name 
DROP COLUMN column_name;
~~~

2. 修改属性域 (列的数据类型):

~~~sql
ALTER TABLE table_name
ALTER COLUMN column_name datatype;
~~~

3. 修改属性名 (列名):

~~~sql
ALTER TABLE table_name
CHANGE COLUMN columm_name new_name
~~~

4. 修改表名:

~~~sql
ALTER TABLE table_name
RENAME TO new_name
~~~

5. 增/删主键:

~~~sql
# 删主键
ALTER TABLE table_name
DROP primary key

# 增主键
ALTER TABLE table_name
ADD CONSTRAINT pk_name PRIMARY KEY column_name
~~~

而 `UPDATE` 语句用于修改表中的数据:

~~~sql
UPDATE 表名称 SET 列名称=新值 WHERE 列名称=某值;
~~~

#### 3.1.4 联合查询: `UNION`

我们可以使用 `UNION` 子句求两个不同表中两列的重复元素, `UNION` 的作用是将 **两个 `SELECT` 语句的查询结果** 作为一个 **整体** 展示出来. 

使用 `UNION` 必须确保各个 `SELECT` 集合的结果的 **列数必须相同**, 且每个对应列的 **数据类型必须相同**, 但 **列名可以不同**.

![20220113223855](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220113223855.png)

需要注意的是, `UNION` 执行的是对两个结果集的 **并集** 操作, **会筛选掉重复记录**.

#### 3.1.5 笛卡尔积运算: `CARTESIAN PRODUCT`

笛卡尔积可以视为对关系的 **乘法**, 它的效果是将 **分别来自两个数据集合中的行** 以 **所有可能的方式** 进行组合.

我们可以使用下列两种方式执行笛卡尔积:

~~~sql
SELECT * FROM table_1 CROSS JOIN table_2;

# 本质是第一种写法的语法糖
SELECT * FROM table_1, table_2;
~~~

![20220114111921](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114111921.png)

![20220114112045](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220114112045.png)

#### 3.1.6 连接运算: `JOIN`

**连接** 运算可以视为 **在水平方向上** 对两个表的 **合并**, 其基本方法是: 将两个表中在共同数据项上相匹配的那些行合并.

连接运算本质是由 **一个笛卡尔积运算** 和 **一个选取运算** 所构成的: 

1. 首先用一个笛卡尔积完成对两个数据集合的乘法, 生成的结果集合包含两个数据集合中所有行的, 所有可能的组合.

2. 然后对生成的结果集合进行 **选取运算** , 确保只把 **分别来自两个数据集合** 并且 **具有重叠部分** 的行所 **合并在一起**. 

`SQL` 提供的多种连接方式之间的区别在于: 它们**在连接运算流程的第二步中** 从 **相互交叠的不同数据集合** 中选取 **用于连接的行** 时所采用的方法不同:

|连接类型|定义|
|:-|:-|
|内连接 `INNER JOIN`|包含 `Theta 连接`, `EQUI 连接` 和 `自然连接`, 只连接满足匹配条件的行, 展现出的是两表 **共同** 的数据.|
|左外连接 `LEFT JOIN`|包含左边表中的全部行 (无论是否和右表匹配), 以及右边表中所有与左边表匹配的行.|
|右外连接 `RIGHT JOIN`|包含右边表中的全部行 (无论是否和左表匹配), 以及左边表中所有与右边表匹配的行.|
|全外连接 `FULL JOIN`|包含左右表的全部行, 不考虑匹配与否, 注意与交叉连接区分.|
|交叉连接 `CROSS JOIN`|生成笛卡尔积: 考虑数据集中任意行与另一数据集中任意行的两两组合. |

下面详细说明各种连接运算:

1. 内连接:

    内连接展现的是两表 **共同** 的数据. 

    内连接又因其匹配条件的不同而被区分为`Theta 连接`, `EQUI 连接` 和 `自然连接`.

    1. `Theta 连接` 是使用 **等值以外的条件** (如大于等于, 小于等于, 不等于之类) 来匹配左右两表中行的内连接.

    2. `EQUI 连接` 是使用 **等值 (==) 条件** 来匹配左右两表中行的内连接.

    3. `自然连接` 是 `SQL` 中一种预定义的内连接, 可以视为语法糖, 它在匹配左右两表好似 **自动判断** 两表中相同名称的列, 而后形成匹配.

        我们无法在自然连接中人为指定哪些列被用于匹配, 但用于指定查询结果包含哪些列.

    ~~~sql
    # Theta连接的例子
    SELECT t1.prop, t2.char FROM table_1 t1 
    INNER JOIN table_2 t2 ON t1.axton != t2.axton;

    # EQUI连接的例子
    SELECT t1.prop, t2.char FROM table_1 t1 
    inner JOIN table_2 t2 ON t1.axton=t2.axton;

    # 注: 上面的内连接相当于:
    SELECT t1.prop, t2.char FROM table_1 t1, table_2 t2 
    WHERE t1.axton=t2.axton;

    # 自然连接的例子
    SELECT t1.prop, t2.char FROM table_1 t1 
    NATURAL JOIN table_2 t2;
    ~~~

2. 外连接:
   
   外连接不但返回符合连接和查询条件的数据行, 还 **返回不符合条件的一些其他行**. 外连接分三类: 左连接 `LEFT JOIN`, 右连接 `RIGHT JOIN` 和完整外部连接 `FULL JOIN`:
   
   1. 左连接除了返回两表中符合连接条件的数据行外, 还返回 **左表中不符合连接条件但符合查询条件的数据行**. 

        如果左表的某行在右表中没有匹配行, 则将右表对应的行处返回 **空值** 并与其连接.

    2. 右连接除了返回两表中符合连接条件的数据行外, 还返回 **右表中不符合连接条件但符合查询条件的数据行**.

        如果右表的某行在左表中没有匹配行, 则将左表对应的行处返回 **空值** 并与其连接.

    3. 完整外部链接返回左表和右表中的所有行. 若某行在另一个表中没有匹配行, 则另一个表的对应列包含 **空值**, 否则这一整行包含对应的数据值.

    ~~~sql
    # 左连接
    # 以左表为主表，右表没数据则为null
    SELECT m.Province,S.Name FROM member m 
    LEFT JOIN ShippingArea s ON m.Province=s.ShippingAreaID;

    # 右连接
    # 以右表为主表，左表没数据则为null
    SELECT m.Province,S.Name FROM member m 
    RIGHT JOIN ShippingArea s ON m.Province=s.ShippingAreaID;

    # 全外连接
    SELECT m.Province,S.Name FROM member m 
    FULL JOIN ShippingArea s ON m.Province=s.ShippingAreaID;
    ~~~


### 3.2 `SQL` 进阶

#### 3.2.1 空值: `NULL`



#### 3.2.2 排序与求和

#### 3.2.3 聚合分组 `GROUP BY`

#### 3.2.4 嵌套查询语句

#### 3.2.5 视图

#### 3.2.6 存储过程

#### 3.2.7 触发器


### 3.3 数据库事务的概念和处理




REFERENCE:

[SQL中SELECT语句详解](https://blog.csdn.net/u013634252/article/details/80569386)

[SQL WHERE 子句](https://www.w3school.com.cn/sql/sql_WHERE.asp)

[SQL总结（一）基本查询](https://www.cnblogs.com/yank/p/3672478.html)

[SQL ALTER TABLE 语句](https://www.w3school.com.cn/sql/sql_alter.asp)

[SQL的alter用法总结](https://blog.csdn.net/qq_41820897/article/details/100179834)

[sql中union和union all的用法](https://www.cnblogs.com/xiangxinhouse/p/6053134.html)

[SQL查询cross JOIN的用法(笛卡尔积)](https://blog.csdn.net/xiaolinyouni/article/details/6943337)

[left join 和 left outer join 的区别](https://www.cnblogs.com/cy163/archive/2008/10/16/1312920.html)

[SQL的四种连接-左外连接、右外连接、内连接、全连接](https://www.cnblogs.com/webwangjie/p/11425632.html)

[sql 内连接、外连接、自然连接等各种连接](https://www.cnblogs.com/fnlingnzb-learner/p/6343828.html)

[Understanding cartesian product in SQL](https://stackoverflow.com/questions/30955338/understanding-cartesian-product-in-sql)

