---
layout:     post
title:      Prolog 学习 Ch6
subtitle:   Cut and Negation
date:       2021-10-31
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: 
catalog: true
tags:
    - 2021
    - 课程笔记
    - COMP24011
---

# `Prolog` 入门: 剪枝和否定

在本章中, 我们将介绍一个新的用于剪枝 (`Cut`) 的内置谓词 `!`, 并解释如何使用它控制 `Prolog` 的回溯行为. 

随后我们将介绍否定谓词 `fail`, 并介绍剪枝谓词和它的联合应用: `negation as faiulure`.

## 1. 剪枝谓词 `Cut`

`Prolog` 的证明搜索机制高度依赖自动化的回溯算法, 但基于预置规则的回溯行为有时可能会导致遍历了完全没有必要遍历的内容, 降低程序的运行效率. 

在第三章中我们已经了解到, 通过调节规则和目标的顺序, 我们可以一定程度地影响 `Prolog` 证明搜索的行为. 本节将介绍一个 `Prolog` 内置谓词: **剪枝谓词** (`Cut`), 它可用于人为终止 `Prolog` 的回溯和证明搜索行为, 从而为我们提供对程序行为更精细的控制.

`Cut` 的占位符为 `!`, 它是一个可被直接写入子句中的原子谓词:

~~~prolog
axton(X) :- rhythm_gamer(X), proficient_developer(X), !, android_user(X), windows_user(X).
~~~

剪枝谓词 `Cut` 具如下性质:

1. 在证明搜索过程中若它被视为目标, 则它为一个 **永远被满足的目标**.
2. 考虑某个子句 $\alpha$ 包含了剪枝谓词 `!`. 则在某次为了尝试满足目标 $G$ 的证明搜索尝试联合该子句时, 剪枝谓词会 **直接将自目标 $G$ 和包含子句的规则左侧联合之前所执行的所有选择, 包括对这个特定子句 $\alpha$ 的选择作为查询的结果提交**, 即使联合失败程序也不会再尝试新的规则或变量.

我们来看下面的一个例子. 

~~~prolog
p(X) :- a(X). 
p(X) :- b(X), c(X), d(X), e(X). 
p(X) :- f(X). 
    
a(1). b(1). c(1). 
d(2). e(2). f(3). 
b(2). c(2).
~~~

我们若查询 `p(X)` 可得:

~~~prolog
?- p(X).
X = 1 ;
X = 2 ;
X = 3.

false
~~~

我们在执行证明搜索时,搜索树如下图所示. 可见 `Prolog` 在处理第二条规则时执行了一次回溯:

![20211031232853](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20211031232853.png)

我们下面对第二条规则进行简单改动:

~~~prolog
p(X) :- b(X), c(X), !, d(X), e(X).
~~~

则此时我们若执行同样的查询, 返回的结果如下:

~~~prolog
?- p(X).
X = 1 ;
false.
~~~

可见 `Prolog` 不再为我们提供另两个可行解. 下面我们分析程序的执行流程来解释这一现象的成因.

1. 在程序执行伊始 `Prolog` 尝试首先联合第一条规则, 因此我们得到目标 `a(X)`. 通过检索知识库将 `a` 实例化为 $1$, 程序即可将 `a(X)` 和事实 `a(1)` 联合, 从而找到第一个可行解 `X=1`. 到此为止新程序的执行流程和原先没有任何差别.
2. 下面 `Prolog` 会尝试联合第二条规则, 而得到目标序列 `b(X),c(X),!,d(X),e(X)`. 由于 `Prolog` 顺着知识库中事实排序尝试联合变量 `X`, 此次尝试还是会从 `X=1` 开始. 联合的结果使得我们满足了目标序列中的前两个子目标, 此时的目标序列变为 `!,d(X),e(X)`.
3. 我们对第二条规则的修改在此处真正生效. 由于 `!` 被视为一个自动被满足的目标, 因此程序会提交我们此前做出的选择 `X=1` 和我们当前对第二条规则的选择, 跳过 `!` 并尝试联合下一个子目标 `d(X)`. 
4. 由于无法从知识库中找到满足目标的事实 `d(1)`, 此次联合失败, 并且我们找不出任何能够满足该子目标的其他方法. 由于 `Prolog` 在处理内置谓词 `!` 时已经将我们在这一轮证明搜索中对事实和规则的选择提交, 程序不再被允许回溯并重新选择事实 `b(2)` 进行联合, 也更不会被允许回溯到原点选择第三条规则进行联合, 因此我们只能得到在第一轮联合中得到的唯一解 `X=1`.

![20211031234355](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20211031234355.png)

在这里需要注意一点. 剪枝谓词 `Cut` 实质上移除的仅仅是程序回溯到该谓词左侧以及更低一层地, 作出尝试联合母子句那一层的可能, 而不会限制比它更深层级的回溯. 举例而言, 考虑规则

~~~prolog
q:-  p1,...,pn,  !,  r1,...,rm
~~~

则谓词 `!` 并不会限制程序在 `r1, ..., rm` 中的任何回溯. 

<br>

## 2. 对剪枝谓词的利用

我们下面讨论对剪枝谓词的利用. 考虑下列的例子:

~~~prolog
max(X,Y,Y) :- X =< Y. 
max(X,Y,X) :- X > Y.
~~~

我们定义了一个三元谓词 `max/3`, 用于检查第三个元素是否 **恰好** 为第一个和第二个元素中更大的哪一个. 

该程序显然可以正常执行被设计的功能, 但不包含剪枝谓词的设计可能导致较低的执行效率. 考虑第三个元素恰好为最大元的情况, 此时程序会尝试执行完全没有执行必要的, 和已经被满足的第一条规则实际上互斥的第二条规则, 显然这纯粹是浪费时间. 

我们所希望的是, 若满足第一条规则, 则不应该再去执行第二条. 通过如此修改程序我们就可以实现这一点:

~~~prolog
max(X,Y,Y) :- X =< Y, !. 
max(X,Y,X) :- X > Y.
~~~

对该程序的过程式描述如下:

程序首先尝试从知识库中联合第一条规则, 若第一条规则蕴含的目标不可被满足 (也就是Y不是最大元), 程序尝试联合第二条规则并得到可行解.

若程序在联合第一条规则时即可满足子目标 `X =< Y`, 由于剪枝谓词的存在当前的一切选择会被提交为查询结果, 程序在联合完成后就会终止而不会尝试徒劳地联合第二条规则. 

显然, 我们在这一例子中加入的剪枝谓词在不改变程序原本功能的前提下实现了对程序执行效率的优化. 这样的剪枝谓词被称为 **安全剪枝** (`Green Cuts`).

我们下面考虑第二个优化的例子. 看上去我们可以去除第二个规则查询符号右侧的数值大小判断:

~~~prolog
max(X,Y,Y) :- X =< Y, !. 
max(X,Y,X).
~~~

虽然看上去程序更加简洁, 但此时程序会在 `max/3` 的三个作用域全部被分别实例化为某些值 (也就是被赋值) 的情况下出错:

~~~prolog
?- max(114, 514, 114).
~~~

此时执行查询, 由于程序无法成功联合第一条规则, 而第二条规则不会对 `X`, `Y` 的大小关系作任何检查, 因此我们提出的明显有误的查询语句会得到 `true`.

但是这不意味着简化第二条规则的尝试完全是徒劳的. 实际上, 这一问题出现的原因只是我们没有让程序在执行变量联合后再执行剪枝. 只需要进行下述的修改, 就可以得到一个既简化了第二条规则又不影响设计功能的程序:

~~~prolog
max(X,Y,Z) :- X =< Y, !, Y = Z. 
max(X,Y,X).
~~~

需要注意的是, 此处的剪枝谓词不再是安全的, 因为 **我们将它从程序中移除后得到的新程序功能不再和原先的保持一致**, 它兼具了 **影响程序功能** 和 **优化运行效率** 的作用. 

在设计程序时, 应尽量避免使用 **不安全剪枝** (`Red Cuts`), 而只将剪枝谓词用于优化程序的运行效率. 

<br>

## 3. 否定谓词

