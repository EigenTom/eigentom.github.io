---
layout:     post
title:      逻辑学探幽 Part7
subtitle:   没有逻辑 只有heip
date:       2021-10-30
author:     R1NG
header-img: img/post-bg-logicnotes.jpg
description: 本章介绍另一种可满足性检测工具-语义树.
catalog: true
tags:
    - 逻辑学
    - 2021
---

# 语义树

本章介绍 **语义树**, 它是另一种可用于可满足性检查和生成谓词公式模型的工具. 给定谓词公式的语义树的生成规则基于对逻辑联结词运算表的分析. 通过应用这些生成规则, 我们就可以得到给定谓词公式的 **所有模型**. 

我们首先对 **语义树** 进行定义, 随后讨论语义树逻辑演算的健全性和完备性. 在第三节中, 我们将给出一个通过捕捉从分支中被删除的公式并使用名为 **可逆性** 的证明理论论证来确立公式的可满足性的语义树运算. 在最后一节中, 我们将展示语义树运算的一个重要的证明理论属性: 子式属性.

<br>

## 7.1 语义树 (`Semantic Tableaux`)

首先考虑一个检查谓词公式

$$\neg (q \vee p \rightarrow p \vee q)$$

可满足性的例子. 

首先考虑逻辑联结词 $\neg$, 显然可知若该公式存在一个解释 $I$, 则该解释必使

$$(q \vee p \rightarrow p \vee q)$$

为真. 进一步地考虑联结词 $\rightarrow$, 可知 $I$ 必使

$$(q \vee p) = 1, ~~ (p \vee q)=0.$$

最后, 同时考虑两个 $\vee$, 我们可得该解释必须同时满足 

$$p=0, ~~ q=0; ~~ q=1 ~\text{or} ~ p=1.$$

由于这样的赋值是互相矛盾的, 显然可知该谓词公式不存在任何模型, 因此它是不可满足的. 

在上述的过程中, 我们基于联结词对子公式进行的分别检查流程大致可以用下图表示: 

![20211031162447](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20211031162447.png)

其中决策树的节点为所需要满足的子公式赋值, 而每一个分支都代表一种可选的赋值方式. 

本质上, 在尝试构造该公式的模型时, 我们采取的策略是基于逻辑联结词的操作表得出 “为了使包含该联结词的谓词公式被解释为特定值, 该公式内位于该链接词不同作用域内的子式需要满足的条件”, 并根据这些在拆解过程中逐步被简化的条件最终依次得出为使原公式被解释为真, 各个变量所需要被赋予的值. 

由于我们在每一次拆分中都会将所有可行的赋值方式和解释方式考虑在内, 通过这种方法得出的全体解释就是原谓词公式的全部模型. 

将我们的检索过程可视化的搜索树被称为 **语义树** (`tableaux`). 语义树的分支分为两种类型: **开** 和 **闭**:

**定义 7.1.1** (开分支和闭分支)
 若语义树中的任何一个分支可被确认为无法得到原公式的一个模型, 则这一分支就被称为 **闭分支**, 反之则称为 **开分支**.

构造语义树可被视为一个单人决策过程 (`One-Player Game`). 这样的决策过程包含一系列决策: 在每一步中, 决策者都从可选的规则和策略中选择一个, 而每一次决策都会影响当前局势的配置 (`Configuration`).  

对于语义树问题而言, 将它视为决策问题时它的配置就是一张语义表 `tableau`. 在为给定的一个谓词公式 $\alpha$ 构造语义表时, 首先构造一个被标记为 $\alpha$ 的单节点, 注意此时我们的语义表中有且只有一条分支, 且该分支显然应该被同时声明为 **开分支**. 

随后, 决策者可执行的操作被大致分为以下的两类:

i. 在当前的语义表中选择某个开分支 $B$, 并在该分支上选择一个 **有符号公式 $\alpha$**, 且该公式需满足 $\alpha$ 不为有符号原子 (也就是说要选择一个尚未被赋值的谓词原子并且同时考虑某个在该分支中包含该原子的子式). 

ii. 使用下列的规则扩展语义表:

我们下面介绍语义表的扩展规则. 这些规则或在分支 $B$ 下增加新节点, 或在当前分支处展开新分支. 规定 $B$ 表示分支, 而 $\beta$ 表示将要作为叶子节点添加到 (相对而言的!) 根结点 $B$ 下的谓词公式, **或包含公式 $\beta$ 的叶子结点.** 则我们有下列规则:

**规则 7.1.1** (分支扩展规则)

>1. 若 $\alpha$ 形为 
>  
>    $$(A_1 \wedge A_2 \wedge \cdots \wedge A_n)=0,$$ 
>
>    则将 $\beta$ 作为 **$n$ 个子节点** 挂在 $B$ 下, 分别为
>
>    $$A_1=0, A_2=0, \cdots, A_n=0.$$
>
>2. 若 $\alpha$ 形为 
>
>    $$(A_1 \wedge A_2 \wedge \cdots \wedge A_n)=1,$$ 
>
>    则将 $\beta$ 作为一个 **单独子节点** 挂在 $B$ 下, 包含公式
>
>    $$A_1=1, A_2=1, \cdots, A_n=1.$$
>
>3. 若 $\alpha$ 形为 
>  
>    $$(A_1 \vee A_2 \vee \cdots \vee A_n)=0,$$ 
>    
>    则将 $\beta$ 作为一个 **单独子节点** 挂在 $B$ 下, 包含公式
>    
>    $$A_1=0, A_2=0, \cdots, A_n=0.$$
>
>4. 若 $\alpha$ 形为 
>  
>    $$(A_1 \vee A_2 \vee \cdots \vee A_n)=1,$$ 
>    
>    则将 $\beta$ 作为 **$n$ 个子节点** 挂在 $B$ 下, 分别为
>    
>    $$A_1=1, A_2=1, \cdots, A_n=1.$$
>
>5. 若 $\alpha$ 形为 
>  
>    $$(A_1 \rightarrow A_2)=0,$$ 
>    
>    则将 $\beta$ 作为一个 **单独子节点** 挂在 $B$ 下, 包含公式
>    
>    $$A_1=1, A_2=0.$$
>
>6. 若 $\alpha$ 形为 
>  
>    $$(A_1 \rightarrow A_2)=1,$$ 
>    
>    则将 $\beta$ 作为 **$2$ 个子节点** 挂在 $B$ 下, 分别为
>    
>    $$A_1=0, A_2=1.$$
>
>7. 若 $\alpha$ 形为 
>  
>    $$(\neg A_1)=0,$$ 
>    
>    则将 $\beta$ 作为一个 **单独子节点** 挂在 $B$ 下, 包含公式
>    
>    $$A_1=1.$$
>
>8. 若 $\alpha$ 形为 
>  
>    $$(\neg A_1)=1,$$ 
>    
>    则将 $\beta$ 作为一个 **单独子节点** 挂在 $B$ 下, 包含公式
>    
>    $$A_1=0.$$
>
>9. 若 $\alpha$ 形为 
>  
>    $$(A_1 \leftrightarrow A_2)=0,$$ 
>    
>    则将 $\beta$ 作为 **$2$ 个子节点** 挂在 $B$ 下, 分别为
>    
>    $$A_1=0, A_2=1$$
>    
>    和
>    
>    $$A_1=1, A_2=0.$$
>
>10. 若 $\alpha$ 形为 
>  
>    $$(A_1 \leftrightarrow A_2)=1,$$ 
>    
>    则将 $\beta$ 作为 **$2$ 个子节点** 挂在 $B$ 下, 分别为
>    
>    $$A_1=0, A_2=0$$
>    
>    和
>    
>    $$A_1=1, A_2=1.$$

上述规则可被总结为下图, 其中有符号谓词公式 $\alpha$ 位于符号 $\rightsquigarrow$ 左侧, 叶子结点 $\beta$ 的子节点位于符号右侧, 若有多个子节点的话则用 $\vert$ 分隔. 

![20211031165639](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20211031165639.png)

与之相对的, 我们还有两条 **分支闭合规则**:

**规则 7.1.2** (分支闭合规则)

>i. 若语义表的某个分支同时包含某个有符号谓词原子 $p$ 的一对值 
> 
> $$p=0, ~~ p=1$$
> 
> 则该分支被标记为 **闭合分支**. 
>
>ii. 若语义表的某个分支包含任一赋值
>
>$$\top = 0$$
>
>或
>
>$$\perp=1$$
>
>则该分支也被标记为 **闭合分支**.

显然. 基于分支扩展和分支闭合规则生成的语义表会随着决策着做出选择的变化而变化, 因而它是 **非确定性** 的. 

此外, 为了确保决策一定会终止, 我们必须 **禁止对分支上已选择过的公式进行二次选择**. 此外, **不可选择已经被标记为闭合分支的分支**.

不难看出, 在引入上述规则后任何博弈过程都是有限的, 因为在每次决策过程执行后, 在原节点下加入的新子式都比原式小. 因此, 对于任何决策, 我们都有下述的两种可能:

1. 由于所有分支都闭合, 不再存在任何可能的新决策.
2. 存在一个开分支, 但该分支上的任何有符号公式都已经被选择过, 因而不可再进行任何选择.

我们称第一种情况下 **给定的原公式是不可满足的**, 而对于第二种情况下原公式是 **具备可满足性** 的. 

下面我们说明, 在第二种情况下我们可以构造出一个原公式的模型:

不妨假设一次决策终止且我们得到的语义表中 **包含一个开分支**. 设 $B$ 为这个开分支中的全部有符号公式, 考虑对于任意布尔变量 $p$, 满足下述要求的解释 $I$: 

$$I(p) \overset{\text{def}}{=} \begin{cases} 0~~~ \text{if} ~~ (p=0) \in B \\ 1 ~~~ \text{if} ~~ (p=1) \in B\end{cases}$$

而若某个布尔变量 $p$ 在该分支中没有出现 (也就是说它的可行取值没有被限定), 则我们可以在构造解释 $I$ 时对它取任意值. 不难证明 (见下节), 这样构造出的解释 $I$ 不仅是位于语法树根部的谓词公式的模型, 还是分支上每一个有符号公式的模型. 

<br>

## 7.2 可靠性和完备性

逻辑往往使用合适的概念模型 (`Notion of Model`), 以语义 (`Semantic`) 的方式定义. 语义树的 **逻辑演算** 或 **解析演算** 则是通过 **证明** 或 **逻辑推导** 的概念定义的. 

为了确认构造的模型理论语义 (`Model-Theoretic Notions`) 和证明理论语义 (`Proof-Theoretic Notions`) 具一致性, 我们需要证明它的 **可靠性** (`Soundness`) 和 **完备性** (`Completeness`). 

直观地说, **可靠性** 意味着任何在该算法下有证明的谓词公式都是语义上合法的 (谓词公式要么为有效的, 要么为可满足的). 而 **完备性** 意味着任何有效或可满足的公式在该算法下都有对应的证明. 



