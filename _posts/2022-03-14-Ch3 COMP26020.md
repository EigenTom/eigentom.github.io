---
layout:     post
title:      编译器引论：绪论
subtitle:   Introduction to Compilation
date:       2022-03-14
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: 本章介绍编译器的基本结构.
catalog: true
tags:
    - 课程笔记
    - 编译理论
---

# 编译器引论

任何使用程序设计语言编写的计算机程序在被实际执行前都必须 **转译为机器语言**, 而负责这一转译过程的软件系统就是 **编译器** (`Compiler`). 

在本章中, 我们将简要介绍 **编译** 流程的基本原理和技术, 并简单讨论在构造编译器时可能遇到的一些常见问题.

## 1. 绪论

### 1.1 定义

我们首先为 **编译器** 的概念给出形式化的定义.

一种说法是, 任何接收一种一段程序字段作为输入, 并以另一种语言的程序字段作为输出, 且输入和输出的含义保持一致的程序就被称为 **编译器**.

我们也可认为, 任何读入用一种语言编写的程序, 并将其翻译为另一种语言下的等价形式的程序也是 **编译器**.

而 **解释器** 的概念为: 任何读入一段 **源程序** (`Source Program`) 并产出 **执行这段源程序的结果** 的程序.

必须使用 **编译器** 才能生成可被直接运行的可执行文件的程序设计语言被称为 **编译型语言**, 如 `C/C#/C++`, `Java` 和 `LaTeX`.

而无需编译可被解释器直接运行的语言称为 **解释型语言**, 如 `Python, PHP, JavaScript` 等.

### 1.2 应用

编译器作为衔接两种不同语言之间的桥梁, 其最基础的功能就是 **在翻译过程中确保程序所含的语义 (意义) 保持不变**. 而在实际情况中, 编译器往往还承担了对源代码进行 (各种意义上的) 优化的功能, 如:

1. 提升编译后的程序的运行速度
2. 减少编译后的程序的占用空间
3. 向用户提供有价值的反馈和信息
4. 在编译失败时能够返回便于调试的错误信息
5. 以较高的效率编译源码

而一般地, 我们认为优秀的编译器至少需要具备下列的其中一些特质:

![20220314213639](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314213639.png)

实际上, 编译技术的应用场景不仅局限在对程序设计语言的转换上. 它还可用于优化计算机机构, 实现自动的并行式计算, 提升软件安全性等.

### 1.3 基本结构

下面我们考虑编译器的基本结构. 

我们在上面的介绍中已经知道, 编译器以 **源代码** (`Source Code`) 作为输入, 将其转换输出 **目标代码** (`Object Code`). 因此, 正常工作的编译器需要具备的最基础性质是:

1. 生成的目标代码必须是正确的, 保持源代码的语义不变.
2. 必须具备识别源代码中错误的能力.
3. 必须具备对源代码进行分析与合成目标代码的能力.

进一步地, 编译器内部又被划分为 **前端** (`Front-End`) 以及 **后端** (`Back-End`) 两个部分, 前端 **输入源代码, 输出中间表示**, 而后端以 **中间表示作为输入, 输出目标代码**.

**前端** 负责对源代码进行 **分析**, 源代码的合法性和可能存在的错误需要在这一阶段中被识别并反馈; 同时, 前端需要 “理解” 并收集源代码蕴含的语义, 并由此生成代码的 **中间表示**. 

**后端** 负责对目标代码的 **合成**: 在这一阶段中, 后端将对中间表示中每一行指令和运算选择合适的指令, 并由此将中间表示翻译为目标语言. 

需要注意, 前端涉及的大部分操作都可以被 **自动化**, 因此对常见的编译器而言执行前端操作的时间复杂度为 $O(n)$ 级别, 而后端所需要处理的问题则为 `NP-Complete` (要想确保完全解决这类问题需要至少指数级别的时间复杂度) 的. 

编译器中 **前后端分离** 的架构便于编译器的 **模块化**, 它允许我们将 **能够生成或处理相同类型的中间表示的**, 针对不同语言的前后端进行 **拼接**, 从而构造出可以编译不同语言, 适配不同平台的编译器. 

![20220314215002](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215002.png)

### 1.4 前端结构

我们下面讨论编译器前端的基本结构. 

编译器前端一般由 **词法分析** (`Lexical Analysis`), **语法分析** (`Syntax Analysis`), **语义分析** (`Semantic Analysis`) 和 **中间表示生成** (`Intemediate Code Generation`) 四个部分组成.

![20220314215256](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215256.png)

首先考虑 **词法分析** (`Lexical Analysis`, `Scanning`). 在这一步中, 编译器前端需要:

1. **扫描, 读入源代码的字符**, 并将其 **分组为词汇** 形成有意义的 **词素序列** (`Lexeme`).

2. 生成词汇, 并分析不同词汇的 **类型**, 生成将要传递到下一步中进行语法分析的 **词法单元** (`Token`). 其形式一般为

    $$\text{<type, lexeme>}$$

    或

    $$\text{<token\_class, attribute>}$$

3. 此外, 在生成词法单元时, 词法分析器还需要维护 **符号表** (`Symbol Table`). 
4. 在词法分析中, 空格, 注释等和程序逻辑无关的内容都会被过滤.

其次考虑 **语法分析** (`Syntax Analysis`, `Parsing`). 

在语法分析这一步中, 第一步中生成的各词法单元将被 **解析**, 从而生成 **树状的中间表示**, 常用的就是 **语法树**. 树状的语法结构将被用于编译器的后续步骤来分析源程序并生成目标程序. 

![20220314220308](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220308.png)

一般地, 生成树还会被进一步通过删去多余的信息被简化为 **抽象语法树** (`Abstract Syntax Tree`, `AST`):

![20220314220818](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220818.png)

然后考虑 **语义分析** (`Semantic Analysis`, `Context Handling`):

语义分析由 **语义分析器** 完成, 负责收集语义信息, 检查语义错误, 如类型检查, 检测变量是否被合法地声明, 进行变量与函数的命名检查等. 它还将使用语法树和符号表中的信息检查源程序是否和源语言定义的语义一致.

此外, 语义分析器也会收集 **类型信息**, 并将这些信息放在语法树或符号表中. 

语义分析器最重要的功能是 **类型检查**: 检测每个运算符 (`Operator`) 是否具有 **匹配的运算分量**, 若目标语言要求某个数组的下标必须是整数, 则若用浮点数作为下标的时候编译器就会将这种操作认定为类型错误.

最后考虑 **中间表示生成** (`Intemediate Code Generation`). 

编译器会在完成源代码的词法分析, 语法分析和语义分析后生成一个 **明确的, 类机器语言的中间表示**. 本质上, 中间表示是一种对源代码的抽象, 合格的中间表示必须是便于生成且便于翻译的, 常用的中间表示形式是 **三地址指令** (`Three-Address Instruction`).

### 1.5 后端结构

继续讨论编译器的后端结构. 

编译器后端一般由 **中间表示优化** (`Intermediate Code Optimisation`), **代码生成** (`Code Generation`), **目标代码优化** (`Target Code Optimisation`) 和 **目标代码生成** (`Target Code Generation`) 构成.

![20220314221932](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314221932.png)

先讨论 **中间代码优化**. 在这一步中, 编译器后端会尝试基于预先给定的目标 (如生成能耗更低/更短/更快的代码) 对传入的中间代码进行优化.

而在后续的步骤中, 需要以经过优化的中间代码作为输入, 并将其映射为目标语言. 若目标语言是机器语言, 还需要在这一步中 **选择合适的机器指令, 为每个变量分配寄存器或指定内存位置**.

![20220314222308](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314222308.png)


## 2. 词法分析



## 3. 语法分析

## 4. 编译器中端 (`Middle-End`)

## 5. 代码生成

