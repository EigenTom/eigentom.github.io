---
layout:     post
title:      编译器引论：绪论
subtitle:   Introduction to Compilation
date:       2022-03-14
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: 本章介绍编译器的基本结构.
catalog: true
tags:
    - 课程笔记
    - 编译理论
---

# 编译器引论

任何使用程序设计语言编写的计算机程序在被实际执行前都必须 **转译为机器语言**, 而负责这一转译过程的软件系统就是 **编译器** (`Compiler`). 

在本章中, 我们将简要介绍 **编译** 流程的基本原理和技术, 并简单讨论在构造编译器时可能遇到的一些常见问题.

## 1. 绪论

### 1.1 定义

我们首先为 **编译器** 的概念给出形式化的定义.

一种说法是, 任何接收一种一段程序字段作为输入, 并以另一种语言的程序字段作为输出, 且输入和输出的含义保持一致的程序就被称为 **编译器**.

我们也可认为, 任何读入用一种语言编写的程序, 并将其翻译为另一种语言下的等价形式的程序也是 **编译器**.

而 **解释器** 的概念为: 任何读入一段 **源程序** (`Source Program`) 并产出 **执行这段源程序的结果** 的程序.

必须使用 **编译器** 才能生成可被直接运行的可执行文件的程序设计语言被称为 **编译型语言**, 如 `C/C#/C++`, `Java` 和 `LaTeX`.

而无需编译可被解释器直接运行的语言称为 **解释型语言**, 如 `Python, PHP, JavaScript` 等.

### 1.2 应用

编译器作为衔接两种不同语言之间的桥梁, 其最基础的功能就是 **在翻译过程中确保程序所含的语义 (意义) 保持不变**. 而在实际情况中, 编译器往往还承担了对源代码进行 (各种意义上的) 优化的功能, 如:

1. 提升编译后的程序的运行速度
2. 减少编译后的程序的占用空间
3. 向用户提供有价值的反馈和信息
4. 在编译失败时能够返回便于调试的错误信息
5. 以较高的效率编译源码

而一般地, 我们认为优秀的编译器至少需要具备下列的其中一些特质:

![20220314213639](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314213639.png)

实际上, 编译技术的应用场景不仅局限在对程序设计语言的转换上. 它还可用于优化计算机机构, 实现自动的并行式计算, 提升软件安全性等.

### 1.3 基本结构

下面我们考虑编译器的基本结构. 

我们在上面的介绍中已经知道, 编译器以 **源代码** (`Source Code`) 作为输入, 将其转换输出 **目标代码** (`Object Code`). 因此, 正常工作的编译器需要具备的最基础性质是:

1. 生成的目标代码必须是正确的, 保持源代码的语义不变.
2. 必须具备识别源代码中错误的能力.
3. 必须具备对源代码进行分析与合成目标代码的能力.

进一步地, 编译器内部又被划分为 **前端** (`Front-End`) 以及 **后端** (`Back-End`) 两个部分, 前端 **输入源代码, 输出中间表示**, 而后端以 **中间表示作为输入, 输出目标代码**.

**前端** 负责对源代码进行 **分析**, 源代码的合法性和可能存在的错误需要在这一阶段中被识别并反馈; 同时, 前端需要 “理解” 并收集源代码蕴含的语义, 并由此生成代码的 **中间表示**. 

**后端** 负责对目标代码的 **合成**: 在这一阶段中, 后端将对中间表示中每一行指令和运算选择合适的指令, 并由此将中间表示翻译为目标语言. 

需要注意, 前端涉及的大部分操作都可以被 **自动化**, 因此对常见的编译器而言执行前端操作的时间复杂度为 $O(n)$ 级别, 而后端所需要处理的问题则为 `NP-Complete` (要想确保完全解决这类问题需要至少指数级别的时间复杂度) 的. 

编译器中 **前后端分离** 的架构便于编译器的 **模块化**, 它允许我们将 **能够生成或处理相同类型的中间表示的**, 针对不同语言的前后端进行 **拼接**, 从而构造出可以编译不同语言, 适配不同平台的编译器. 

![20220314215002](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215002.png)

### 1.4 前端结构

我们下面讨论编译器前端的基本结构. 

编译器前端一般由 **词法分析** (`Lexical Analysis`), **语法分析** (`Syntax Analysis`), **语义分析** (`Semantic Analysis`) 和 **中间表示生成** (`Intemediate Code Generation`) 四个部分组成.

![20220314215256](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314215256.png)

首先考虑 **词法分析** (`Lexical Analysis`, `Scanning`). 在这一步中, 编译器前端需要:

1. **扫描, 读入源代码的字符**, 并将其 **分组为词汇** 形成有意义的 **词素序列** (`Lexeme`).

2. 生成词汇, 并分析不同词汇的 **类型**, 生成将要传递到下一步中进行语法分析的 **词法单元** (`Token`). 其形式一般为

    $$\text{<type, lexeme>}$$

    或

    $$\text{<token\_class, attribute>}$$

3. 此外, 在生成词法单元时, 词法分析器还需要维护 **符号表** (`Symbol Table`). 
4. 在词法分析中, 空格, 注释等和程序逻辑无关的内容都会被过滤.

其次考虑 **语法分析** (`Syntax Analysis`, `Parsing`). 

在语法分析这一步中, 第一步中生成的各词法单元将被 **解析**, 从而生成 **树状的中间表示**, 常用的就是 **语法树**. 树状的语法结构将被用于编译器的后续步骤来分析源程序并生成目标程序. 

![20220314220308](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220308.png)

一般地, 生成树还会被进一步通过删去多余的信息被简化为 **抽象语法树** (`Abstract Syntax Tree`, `AST`):

![20220314220818](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314220818.png)

然后考虑 **语义分析** (`Semantic Analysis`, `Context Handling`):

语义分析由 **语义分析器** 完成, 负责收集语义信息, 检查语义错误, 如类型检查, 检测变量是否被合法地声明, 进行变量与函数的命名检查等. 它还将使用语法树和符号表中的信息检查源程序是否和源语言定义的语义一致.

此外, 语义分析器也会收集 **类型信息**, 并将这些信息放在语法树或符号表中. 

语义分析器最重要的功能是 **类型检查**: 检测每个运算符 (`Operator`) 是否具有 **匹配的运算分量**, 若目标语言要求某个数组的下标必须是整数, 则若用浮点数作为下标的时候编译器就会将这种操作认定为类型错误.

最后考虑 **中间表示生成** (`Intemediate Code Generation`). 

编译器会在完成源代码的词法分析, 语法分析和语义分析后生成一个 **明确的, 类机器语言的中间表示**. 本质上, 中间表示是一种对源代码的抽象, 合格的中间表示必须是便于生成且便于翻译的, 常用的中间表示形式是 **三地址指令** (`Three-Address Instruction`).

### 1.5 后端结构

继续讨论编译器的后端结构. 

编译器后端一般由 **中间表示优化** (`Intermediate Code Optimisation`), **代码生成** (`Code Generation`), **目标代码优化** (`Target Code Optimisation`) 和 **目标代码生成** (`Target Code Generation`) 构成.

![20220314221932](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314221932.png)

先讨论 **中间代码优化**. 在这一步中, 编译器后端会尝试基于预先给定的目标 (如生成能耗更低/更短/更快的代码) 对传入的中间代码进行优化.

而在后续的步骤中, 需要以经过优化的中间代码作为输入, 并将其映射为目标语言. 若目标语言是机器语言, 还需要在这一步中 **选择合适的机器指令, 为每个变量分配寄存器或指定内存位置**.

![20220314222308](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220314222308.png)


## 2. 词法分析 `Lexical Analysis`

在本节中, 我们讨论词法分析步骤中的基本原理. 

回顾定义, 词法分析是读入程序源码并将其转换为一系列词素 (`Token`) 的过程.

为了避免人工编码复杂的词法分析器, 简化程序语言的语法定义和实现, 词法分析器对编译器而言至关重要.

为了便于后续的解释, 此处引入一系列定义:

### 基本定义

**定义 2.1** (单词表, 字符串, 语言和语法)
> 1. 称由一系列不同符号组成的集合为单词表.
> 2. 称由一系列单词表中的符号组成的有序队列为字符串.
> 3. 称由所有定义在某个单词表上的字符串组成的集合为语言.
> 4. 称任何一种有限的, 表示语言的方式为语法. 

**定义 2.2** (上下文无关语法, `Context-Free Grammar`)
> 记上下文无关语法 $G$ 为四元组 
> 
> $$G = (S, N, T, P):$$
> 
> 1. $S$: 起始符号 (`Starting Symbol`)
> 2. $N$: 非终止符号 (`Non-Terminal Symbol`)
> 3. $T$: 终止符号 (`Terminal Symbol`)
> 4. $P$: 生成规则

因此我们也可将语言定义为由某个上下文无关语法生成的所有终止的字符串组成的集合. 如:

![20220429222240](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222240.png)

注:

1. 一般情况下非终止符号均用大写字母表示.
2. 上面的例子中使用的是 `LeftMost Derivation`: 基于规则从左到右逐步构建字符串.

上下文无关语法对于词法分析至关重要. 使用恰当的表示方法, 我们即可利用上下文无关语法高度的结构性和过程性对程序语言的语法进行编码. 下面简介其中一种恰当的表示法: **正则表达式**. 

### 正则表达式

正则表达式 (`Regular Expression`) 用于表示正则语言, 我们可以使用正则表达式表示无穷种字符串.

正则表达式的基本语法:

![20220429222758](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222758.png)

需要注意, 正则表达式的基础语法恰为前三条, `Shorthands` 实为对前三条规则的简化封装, 类似语法糖.

虽然 **正则表达式无法用于表示所有语言**, 但它足够解决绝大多数的问题. 下面给出正则表达式表示整数, 浮点型和变量名的例子. 在 `Python` 表达式的例子中, 我们使用正则表达式分别用常规方式和科学技术法表示了浮点型数字.

![20220429222904](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429222904.png)

如上文所述, 理论上我们完全可以将词法分析规则硬编码, 但这样做会极大降低分析器的可扩展性, 难以修改, 且工作量巨大. 正则表达式恰可以 **自动化词法分析的过程**, 极大地简化我们在构造词法分析器时的工作.

如下图所示, 正则表达式实际上可以被表示为状态转换图. 

![20220429223259](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223259.png)

上图中的转换图可以被相应地 **等价表示** 为下列的转换表: 

![20220429223347](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223347.png)

在转换表中, 第一列表示当前状态的编号, 第二列表示在当前状态下接受不同输入将会导致状态转换 (切换, 更新) 到什么新的状态上, 如在 `state0` 时, 若输入为 `r` 则所处状态将转换到 `state1`, 而任何其他输入都无法让当前状态转换. 

进一步地, 在将正则表达式所表示的状态转换图转化为状态转换表后, 我们就可以通过在词法分析逻辑中查询和调用状态转换表, 明显地优化性能.

需要注意的是, 能够被利用的状态转换表必须是 **确定性** 的, 也就是在任何状态下, 给定任何输入, 其状态转换效果必须唯一. 我们下面对不同类型的状态转换图, 转换表和状态机进行讨论.

### NFA, DFA 和转换与简化

在介绍各种状态机前, 我们首先明确它们在构建词法分析器的步骤中起到的作用:

![20220429223851](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223851.png)

我们首先使用正则表达式编码程序设计语言的语法规则, 并通过 `Thompson's Construction` 先将其转换为非确定性有穷状态机, 再使用 `Subset Construction` 将其转换为未经精简的确定性有穷状态机, 最后使用 `Hopecroft's Algorithm` 将其精简的方式得到可供特定的词法分析器生成工具作为输入的, 精简的确定性有穷状态机.

首先回顾确定性有穷状态机 (`DFA`) 和非确定性有穷状态机 (`NFA`) 的定义:

![20220429223741](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429223741.png)

#### 正则表达式到 `NFA` 的转换

`Thompson‘s Construction` 的构造规则如下:

![20220429224213](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224213.png)

我们可以使用这些表示正则表达式基本元素的中间件构造复杂的非确定性有穷状态机, 如:

![20220429224253](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224253.png)

#### `NFA` 到 `DFA` 的转换

`Subset Construction` 的核心逻辑由两个操作组成:

1. `move(s_i, a)`: 找出从状态 $s_i$ 开始, 通过输入 `a` 所可以转换到的全部新状态.

2. `epsilon-closure(s_i)`: 所有从状态 $s_i$ 开始, 通过空输入 $\epsilon$ 所可以 **直接或间接** 转换到的状态.

用于将 `NFA` 转换到 `DFA` 的 `Subset Construction` 的基本逻辑是:

1. 从 `NFA` 的 **初始状态节点** 开始查找其 `epsilon-closure`.
2. 对找到的所有 `epsilon-closure`, 结合它们所可以接收到的所有类型的新输入 应用 `move()`.
3. 对新生成的 `epsilon-closure` 再循环反复应用上述规则, 直到再也无法生成新的 `epsilon-closure` 为止.

此时, 所生成的所有不同的 `epsilon-closure` 就代表我们得到的, 等价的 `DFA` 的所有节点. 依据转换规则将这些新节点编号, 连接, 就得到了和原来的 `NFA` 所等价的 `DFA`.

![20220429224921](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429224921.png)

在上面的例子中, 我们从 `NFA` 的初始状态节点 $0$ 开始应用 `epsilon-closure`, 一步步扩展最终得到了五个不同的闭包. 上述 `NFA` 即被相应地转换为:

![20220429225030](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225030.png)

注意通过 `Subset Construction` 得到的 `DFA` 存在大量冗余节点. 下面使用 `Hopecroft's Algorithm` 将其简化. 

#### `DFA` 的精简

在对 `DFA` 进行精简时, 我们将合并全部状态转换规则相同的节点, 检查冗余节点的方式为 `Hopecroft's Algorithm` 的基本思想:

首先将输入 `DFA` 的全部节点分为两个部分: 终止节点, 和非终止节点. 

其次, 根据不同输入分别判断: 非终止节点中是否有某个或某些节点在输入某些符号时状态转换的规则和其他的不一致. 如果对于任何一种输入出现了这种情况有的话, 将其聚类并拆分. 

对拆分后的节点集继续进行相同的检测, 直到无法再拆为止. 此时我们得到的一系列拆分后的节点集合就表明了原 `DFA` 中哪些节点是互相等价, 可以合并的. 如:

![20220429225556](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225556.png)

以及

![20220429225756](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429225756.png)

#### 构造高效的词法分析器

在上面一小节中我们已经解释了如何从正则表达式通过数种中间形态转换到精简的确定性有穷状态机的过程. 而在将确定性有穷状态机转换成完全等价的状态转换表后, 它就可以被词法分析器调用以相对高效地完成词法分析任务. 

然而调用状态转换表仍然相对低效, 且会产生可观的内存开销. 因此, 契合实际的解决方案是: 将状态转换表编码的转换规则使用工具直接 **自动化地集成** 到词法分析器中.

![20220429230219](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429230219.png)

在业界中, 常用的转换工具为 `Flex`:

![20220429230310](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220429230310.png)

它可以直接接受正则表达式为输入.

#### 总结

词法分析器将由一系列符号组成的源码经过分析和转换, 变为一系列词素. 这一过程是完全自动化的, 遵循 “正则表达式 - 非确定性有穷状态机 - 确定性有穷状态机” 的流程. 由于正则表达式具有表达多种复杂模式的强大功能, 它常被用于自动化词法分析的流程.


## 3. 语法分析



## 4. 编译器中端 (`Middle-End`)

## 5. 代码生成

