---
layout:     post
title:      C/C++
subtitle:   Introduction to C/C++
date:       2021-11-11
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: 本章介绍C语言和C++.
catalog: true
tags:
    - 课程笔记
    - C语言和C++
---


# C/C++

## 1. 引论: 程序设计范式

本章着重介绍两种贴近底层但功能强大的计算机程序设计语言: 鼎鼎大名的 `C` 语言 和在此基础上发展而来, 具备面向对象程序设计特性的 `C++`. 

我们将从 **程序设计范式** 的角度出发, 分别剖析`C` (面向过程) 和 `C++` (面向对象) 这两种 **描述数据和计算过程具有较大差别** 的程序设计语言.

**定义 1.1** (程序设计范式, `Programming Paradigm`)
>程序设计范式描述的是 **程序设计的本质**: **描述所使用的数据和对数据执行的计算** 的不同方法. 
>
> 程序设计范式一般分为 **函数式 (如 `Haskell`)**, **面向对象 (如 `C++`, `Java`)** 和 **逻辑式 (如 `Prolog`, `tptp`)**. 
>
> 需要注意的是, 程序设计语言可能同属多种不同的范式, 如 `C++` 虽然常被视为面向对象语言, 但也支持一些函数式编程的特性. 
> 
> 程序设计范式没有优劣之分, 它们对于不同的情形具有各自的优越性. 

![20220501161204](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501161204.png)

程序设计范式表现为程序设计风格. 如常见的程序设计语言均为过程式编程, 而 `Haskell` 和 `Prolog` 则为声明式编程:

![20220501161812](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501161812.png)

程序设计范式还可表现为程序员描述程序计算过程的不同方式:

![20220501161931](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501161931.png)

程序设计范式同时决定了程序员应该如何描述在计算过程中使用的数据:

![20220501162010](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501162010.png)

### 纯过程式程序设计语言

主要的 **过程式/命令式** (`Imperative`) 程序设计语言包括汇编语言, `C` 语言等, 通过明确地命令计算机如何处理某件事情来达到所希望的结果, 程序员在编写程序时需要使用循环, 条件判断等语句明确描述算法的每一步过程. 和纯粹的声明式语言相比, 过程式语言能够更清楚地描述复杂程序. 

![20220501162327](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501162327.png)

### 过程式面向对象程序设计语言

而 **过程式/命令式面向对象** 程序设计语言 将 **特定的功能代码和数据封装到对象中**, 利用继承和多态 (`Inheritance & Polymorphism`) 等面向对象建模思想实现了高效的代码复用并降低了程序复杂度, 适合使用在包含大量状态转换和操作的复杂程序中, 而且便于理解和维护.

![20220501162655](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501162655.png)

### 过程式并行程序设计语言

在 **过程式并行程序设计语言** 中, 程序员可以使用 **线程/进程** 的概念描述 **交错执行** 或 **并行执行** 的计算流, 适合应用于分布式计算, 高性能计算, 图形处理等领域. 

![20220501162913](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501162913.png)

### 声明式/描述式程序设计语言

主要的 **声明式语言** 包括 `SQL`, `HTML`, `Markdown`, [正则表达式等](https://zhuanlan.zhihu.com/p/34445114), 解决问题的方式并非详细解释解决问题的步骤, 让机器严格按照步骤执行计算, 而是使用特定语法清晰明确地描述问题本身或所期望得到的结果, 让机器自行基于预设规则尝试解决问题. 

声明式语言具备高度的抽象性, 往往同时具有极高的复杂度, 应用场景主要是文本渲染, 结构化数据存储等领域. 

![20220501163420](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501163420.png)

### 声明式/描述式函数式程序设计语言

**声明式/描述式函数式程序设计语言** 基于一阶函数 (可被作为参数输入其他的函数中, 也可以从其他的函数中作为返回值返回的函数) 或高阶函数, 循环是通过递归实现的. 使用这类语言编写的程序主要包括 **纯函数**: 输出完全由输入决定, 不产生任何副作用, 由此具有更高的安全性, 某种程度上也相对更容易理解. 

![20220501163858](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501163858.png)

### 声明式/描述式并行程序设计语言

![20220501164112](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501164112.png)

最后总结如下:

![20220501164151](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501164151.png)

## 2. C语言简介

`C` 语言诞生于上世纪 $70$ 年代, 是一种久负盛名的重要的, **结构化命令式面向过程的程序设计语言**. 

![20220501164552](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501164552.png)

`C` 由于其高效, 贴近硬件底层 (如可直接执行内存读写和内存空间分配) 的特点, 非常适合操作系统, 驱动程序, 嵌入式系统开发.

首先以最简单的 `Hello World` 程序为例描述 `C` 语言程序源代码中不同元素的作用:

![20220501164802](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501164802.png)

而由于 `C` 是一种编译型语言, 我们需要在执行程序前先使用编译器从源码生成实际的可执行程序.

![20220501164913](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501164913.png)

### 变量, 类型

`C` 是强类型语言, 任何变量在使用前需要声明其变量名, 初始值和变量类型. 

![20220501165034](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501165034.png)

`C` 语言中的 **变量类型** 描述了 **分配给变量的内存空间大小**, 同时编译器在执行程序编译时会检查程序所执行的变量运算和变量调用等是否在类型匹配的角度上是合法的.

`C` 语言中的三种基础数据类型包括: **整数 (`int`, `short`, `long`)**, **浮点数 (`float`, `double`)** 和 **字符 (`Char`)**.

![20220501165348](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501165348.png)

而在 `C` 中对不同类型数据的控制台格式化输出方法如下:

![20220501165459](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501165459.png)

注: 可以将 **无符号 (unsigned), 长型 (long)** 视为前缀 `u` 和 `l`, `d` 表示整数 (`digit`), 注意长浮点数 (`double`) 即为 `lf`.

同时需要注意, **由于类型定义的不同只是决定了编译器如何解释固定长度内存空间中的数据的方式**, 因此如果意外地在处理数据和格式化输出时使用和变量类型不匹配的输出标记编译器也不会报错. 

![20220501170011](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501170011.png)

在上图的例子中, 当我们将含符号整数当成无符号整数格式化输出时, 将会得到非常意外的结果. 

提示: 回顾无符号整数表示法, 含符号整数的补码表示法和小端序定义.

### 数组, 字符串和命令行变量

#### 数组

在 `C` 语言中, 数组的编码方式为 **行主导** (回顾 COMP26020 Ch3 编译器导论), 且存储方式为: **在一段连续的内存空间内依次存储每行的所有元素**:

![20220501185541](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501185541.png)

![20220501185608](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501185608.png)

在 `C` 语言中, 对数组的声明一般伴随着初始化. 需要注意的是, 在静态初始化 (`Static Initialisation`) 数组时, 我们可以 **忽略**对数组 **第一维度** 尺寸信息的声明. 

![20220501185756](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501185756.png)

#### 字符串

此外, 数组和 `C` 语言中的字符串也有密不可分的联系. 在 `C` 语言中, 字符串实际上就是一个字符数组, 而其特点是在该字符数组中, 除了按照顺序存储每个字符外, **还会在字符串尾额外加上一个 `\0`** 表示 **字符串的终止**. 

![20220501190019](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501190019.png)

#### 命令行变量

下面介绍 `C` 语言中命令行变量及其调用方法:

![20220501190109](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501190109.png)

`C` 语言中任何程序的 `main` 主函数 都需包括两个参数: 存储命令行变量数量的 `argc` (`argument count`), 以及存储实际命令行变量的 **数组** `argv` (`argument vector`). 

![20220501190232](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501190232.png)

需要注意: 

1. **可执行文件路径** 本身在任何情况下都会被作为第一个命令行变量传入 `main` 中. 

2. 输入的命令行参数类型恒为字符串.

### 条件控制语句和循环语句

本小节讨论 `C` 语言中的条件控制与循环语句. 

在 `C` 语言中, 每一条陈述语句 (基本语句) 都以分号 `;` 结尾, 并且按照顺序依次执行:

![20220501190600](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501190600.png)

#### 条件控制语句

而 `C` 语言中对条件控制语句 `if...else..` 的定义如下:

![20220501190645](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501190645.png)

注意逻辑表达式的短路特性和优先级: “非 > 与 > 或”.

`C` 语言同时具有 `Switch` 语句:

![20220501190736](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501190736.png)

注意在每一种子情况对应的语句后都需要加上 `break` 以防止自动执行后面的不同情况对应的语句; 以及在任何情况下最好都要确保声明了默认情形 `default`.

#### 循环语句

`C` 语言提供了 `while` 和 `do...while` 循环:

![20220501191022](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501191022.png)

其核心差别在于 `while` 总会优先检查循环条件, 可能执行 $0~\infty$ 次循环, 而 `do...while` 总是先执行循环体再检查条件, **循环体至少会执行一次**.

`C` 语言还提供了 `for...` 循环, 我们可以精准控制循环变量和循环条件:

![20220501191207](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501191207.png)

#### 循环控制语句

`C` 语言还允许我们使用下列的循环控制语句:

`break` 允许我们 **终止当前循环体的执行并跳出当前循环**.

`continue` 允许我们 **跳过当前循环体的执行并进入下一轮循环**, 类比于 `Python` 中的 `pass` 关键字.

![20220501191343](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501191343.png)

最后, 我们说明控制循环/条件判断语句作用范围的 中括号 `{}` 在避免程序出现歧义上的重要性:

![20220501191526](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501191526.png)

若每个循环体/条件判断语句体只包含 **一条语句**, 则此时才可以安全地省略括号, 否则就可能导致类似于上图中第二个例子里 `else` 和 `if` 配对时出现的歧义问题.

### 函数


#### 函数的声明

我们可以在 `C` 语言中定义函数. 对函数的定义必须包括一个 **函子 (`functor`, 实际上就是函数名)**, $0$ 个或多个 **声明类型** 的参数, 以及 **返回值的类型** (也就是常说的, 函数的类型).

![20220501191754](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501191754.png)

如果函数不返回任何值, 则定义其类型为 `void`. 注意, 即使函数不返回任何值, 仍需要保留 `return` 语句. 

![20220501191915](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501191915.png)

#### 函数参数和返回值的传值 

而在调用函数时, **函数参数和函数的返回值会以拷贝而非引用的方式传入/传出函数**, 这和包括 `Python` 在哪的程序设计语言一致. 这意味着, 我们将某个变量 $x$ 作为函数参数 $y$ 传入函数后, 该函数对这个参数 $y$ 进行的任何修改都不会影响 $x$, 因为在传入变量时 $y$ 是作为 $x$ 的拷贝 **独立存在的**. 

![20220501192220](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501192220.png)

此外, 由于 `C` 语言编译器在编译源码时会进行全局扫描, 我们完全可以对函数 “先调用, 后定义”, 也就是所谓的 **前置定义** (`Forward Declaration`).

![20220501192416](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501192416.png)

#### 变量的作用域和生命周期

我们再明确 `C` 语言函数变量作用域和生命周期的问题:

1. 全局变量定义在 **函数体之外**, **整个源代码** 范围内均可见. 

    ![20220501192849](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501192849.png)

2. 局部变量定义在函数体内 (也就是由一对中括号 `{}` 包裹起来的程序段中), 而其作用域也 **仅限于这个程序段里**. 

    ![20220501192915](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501192915.png)

出于安全考虑, 应当 **尽可能地避免声明和使用全局变量**.


### 用户自定义类型和数据结构

本节讨论 `C` 语言中的用户自定义类型和数据结构.

#### 自定义类型

我们可以使用 `typedef` 关键字为 **特定的数据类型创建别名**: 

![20220501193052](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501193052.png)

如在上面的例子中, 我们就使用 `typedef` 关键字为类型 `long long unsigned int` 创建了别名 `my_int`, 此后就可以用 `my_int` 指代它对应的类型.

#### 自定义数据结构

`C` 语言中的自定义数据结构称为 **结构体**, 它可以使用 `struct` 关键字, 我们想要赋予结构体的名称和结构体中 **包含的变量类型** (`namefield`) 来定义:

![20220501193552](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501193552.png)

而在调用对应结构体时, 也需要指明被调用变量的类型为结构体. 

在从外部访问结构体内存储数据时, 需要使用的语法为 `<variable_name>.<field_name>`, 如从描述某个 `Arcaea` 玩家 `axton` 的结构体 `struct axton` 中访问存储其潜力值的字段 `float potential` 时就需要使用 `axton.potential`.

在 **不考虑编译器优化** 的情况下, 结构体的大小就等于其 **内部存储的所有数据字段对应类型的大小之和**. 

![20220501193943](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501193943.png)

如上图所示的结构体 `person` 在内存中占用的空间大小就为 `10 * 1 + 4 + 4 == 18` 字节. 

我们可以利用自定义类型简化对结构体的调用. 

假定我们想声明存储个人信息的结构体 `person`, 则按照常规的定义方法我们每次在声明一个新的 `person` 类型的变量时都需要使用 `struc person`. 

利用自定义类型语句 `typedef struc s_person person`, 再将对 `person` 的结构体定义名从 `person` 改为 `s_person`, 从此在程序中 `person` 就代表 `struc s_person`, 再也无需表明它是一个结构体类型 `struc`.

![20220501194341](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501194341.png)

#### 枚举类型

`C` 语言支持 **枚举类型**, 注意编译器实际上会自动为每个枚举定义一个对应的整数常量, 这使我们可以直接在 `switch` 语句中调用枚举类型.

![20220501194601](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501194601.png)

同样地, 我们也可以相应地利用自定义类型简化对枚举类型的引用. 

![20220501194717](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220501194717.png)

## 3. C语言进阶

### 指针和指针的应用

### 动态内存分配

### C标准库

## 4. C++简介

### 类和对象

### 动态对象分配和动态数组

### 继承

### 同态

## 5. 编译

### 预处理

### 模块化编译

### 自动编译

### C的类型转换

### 案例: 高性能计算

### 案例: `LibC`

## 5. 其他课题

### 操作系统内核

### 内存安全