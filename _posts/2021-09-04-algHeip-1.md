---
layout:     post
title:      普林斯顿算法4-Ch1 基础
subtitle:   Basics and Union Find Set
date:       2021-09-03
author:     R1NG
header-img: img/blogpost_images/20210905154720.png
description: 
catalog: true
tags:
    - 2021
    - 数据结构和算法
    - 扩展自习
---

# Ch1 基础

在本章中, 我们将学习在随后的章节中用于实现, 分析和比较算法的基本原则与方法. 本书使用 `Java` 编程, 故在第一章中涉及了诸多关于 `Java` 语言的基本语法和面向对象程序设计的概念. 除此之外,  **背包, 队列和栈** 这三种基础的 **抽象数据类型** 也在该章节中被介绍. 最后, 本章介绍了一些分析算法性能的方法, 并通过对连通性问题解法的讨论引出了 **并查集** 这个数据结构的实现. 

<br>

## 1.1 `Java` 程序设计模型和面向对象程序设计

我们首先回顾一些重要的 `Java` 语言特性和 `OOP` 概念. 


**定义**: 数据类型和抽象数据类型

>数据类型指的是 **一组值** 和 **一组对这些值的操作的集合**, 而 `Java` 程序设计的基础是使用 `class` 关键字构造称为 **引用类型** 的数据类型.

要使用一种数据类型, 我们不需要知道它是如何实现的. 如果我们将一种数据类型的数据表示方式 **隐藏** 起来, 那么这样的数据类型就被称为 **抽象数据类型**. 在实现抽象数据类型时, 我们只需要将注意力集中在它的 `API` 所描述的操作上而无需关注具体的细节. 

`API` 常被用来描述 **抽象数据类型** 的行为. 其作用是列出该数据类型的所有 **构造函数** 和 **实例方法**. 

<br>

**定义**: 对象

>对象是 **能够承载数据类型的值**的实体. `Java` 中所有对象均具备三个特性: **状态**, 即数据类型中的值; **标识**, 用于将对象加以区分; **行为**, 亦即数据类型的操作. 

<br>

要完全了解一个数据类型, 我们就需要它的 **API**, **典型用例** 和 **实现**. 为了达成用例和实现的分离, 我们可以将用例独立成含有一个静态方法 `main()` 的类, 并将数据类型定义中的 `main()` 方法预留为一个测试用例. 同样的, 在开发数据类型时, 我们可以按照下列的顺序使用 **抽象数据类型** 满足用例的需求:

1. 定义一份 `API` 实现编程的模块化.
2. 编写一个 `Java` 类实现 `API` 的定义.
3. 实现多个测试用例用于验证前两步的设计和完成情况.

面向对象程序设计的一大特征是 **使用数据类型的实现封装数据**. 封装使我们可以独立开发 **用例** 和 **实现** 的代码, 并且确保即使以后 **实现** 部分的代码被替换成改进的版本, **用例** 部分也不会受到影响. 在学习数据结构与算法时, 倘若开发出更好的算法, 只需要用抽象数据类型的, 改进的实现替换原有的旧实现, 就可以保证在不改变任何用例代码的前提下改善所有这些用例的性能. 

**定义**: 接口和子类

> **接口** 规定了一系列需要实现的方法, 它可以使两个实现了这些公共方法的, 原本没有关联的类之间建立联系.  **子类** 允许我们在不重写整个类的前提下就能改变它的行为或者添加新的功能, 其主要思想是定义一个新类来继承父类的所有 **实例方法和实例变量**, 其中子类可以包含比父类更多的方法, 也可以对父类中原有的方法进行重定义. 

<br>

## 1.2 基础抽象数据类型: 背包, 队列和栈

**背包**, **队列** 和 **栈** 的不同之处只在于其删除或访问对象的顺序. 我们首先介绍这三种数据结构的 `API`:

1. 背包

    |`public class` | `Bag<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Bag()`|创建一个空背包|
    |`void` | `add(Item item)`| 添加一个新元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

2. 队列  (先进先出)
   
    |`public class` | `Queue<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Queue()`|创建一个空队列|
    |`void` | `enqueue(Item item)`| 添加一个新元素|
    |`Item`|`dequeue()`|删除最近添加的元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

3. 栈 (后进先出, 下压栈)

    |`public class` | `Stack<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Stack()`|创建一个空栈|
    |`void` | `push(Item item)`| 添加一个新元素|
    |`Item`|`pop()`|删除最近添加的元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

下面分别介绍三种数据类型.

### 背包

背包是一种 **不支持从中删除元素** 的 **集合数据类型**, 其作用是帮助用例收集并迭代遍历所有收集到的元素, 并且 **迭代的顺序不确定**且与用例无关. 

### 队列 (先进先出)

先进先出队列, 或简称队列, 是一种基于先进先出 (`FIFO`) 策略的集合类型. 在用例使用高级循环语句 `foreach` 迭代访问队列的元素时, 元素被处理的顺序就是 **它们被添加进队列中** 的顺序. 通过在程序中使用队列数据结构, 我们可以在集合保存元素的同时 **保存它们的相对顺序**.

### 下压栈

下压栈, 或简称栈, 是一种基于后进先出 (`LIFO`) 策略的集合类型. 和队列不同, 当用例使用 `foreach` 迭代遍历栈中元素时, 元素的处理顺序恰好与它们被压入的顺序相反. 通过在程序中使用队列数据结构, 我们可以在用集合保存元素的同时 **颠倒保存它们的相对顺序**.

<br>

下面讨论对上述三种数据类型的实现. 首先考虑一种容量固定的抽象数据类型: **定容栈**:

定容栈只能处理 `String`, 不支持迭代并且要求用例指定一个容量. 我们可以使用 **`String`数组** 作为定容栈的数据表示方式:

~~~java
public class FixedCapacityStackOfStrings {
    private String[] a;     // stack entries
    private int N;          // size
    
    // constructor
    public FixedCapacityStackOfStrings(int cap) {
        a = new String[cap];
    }

    // check whether a is empty or not
    public boolean isEmpty() {
        return N == 0;
    }

    // return the size N
    public int size() {
        return N;
    }

    // push new elem 
    public void push(String item) {
        a[N++] = item;
    }

    // pop out item
    public String pop() {
        return a[N--];
    }

    // usage cases (tests)
    public static void main(String[] args) {
       FixedCapacityStackOfStrings s;
        s = new FixedCapacityStackOfStrings(100);
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-")) {
                s.push(item);
            } else if (!s.isEmpty()) {
                StdOut.print(s.pop() + " ");
            }
            StdOut.println("(" + s.size() + " left on stack)")
        }
    }
}
~~~

上述代码给出的实现最明显的问题之一就是只能处理 `String` 对象. 我们可以使用 **泛型** 重新实现这个数据类型, 使其可以对任何类型的对象进行处理:

~~~java
public class FixedCapacityStack<Item> {
    private Item[] a;       // stack entries
    private int N;          // size
    
    // constructor
    public FixedCapacityStackOfStrings(int cap) {
        // java does not allow creating generic arrays directly
        // therefore we need conversions
        a = (Item[]) new Object[cap];   
    }

    // check whether a is empty or not
    public boolean isEmpty() {
        return N == 0;
    }

    // return the size N
    public int size() {
        return N;
    }

    // push new elem 
    public void push(Item item) {
        a[N++] = item;
    }

    // pop out item
    public Item pop() {
        return a[N--];
    }

    // usage cases (tests)
    // specify the type of 'Item' is 'String'
    public static void main(String[] args) {
       FixedCapacityStack<String> s;
        s = new FixedCapacityStackOfStrings<String>(100);
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-")) {
                s.push(item);
            } else if (!s.isEmpty()) {
                StdOut.print(s.pop() + " ");
            }
            StdOut.println("(" + s.size() + " left on stack)")
        }
    }
}
~~~

注意上下两个实现方式的区别.

在使用泛型对数据类型的实现方式进行改进使其适用于任何类型的对象后, 我们现在需要考虑解除定容限制需要使用什么样的优化方式. `Java` 数组一旦创建大小无法改变, 但这不影响我们在将要改变栈内容时, 一旦检测到剩余容量不足时将原数组中的所有内容迁移到一个更大的数组中.

具体来说, 我们所进行的修改如下:

~~~java
// migrate the array to a new one with its size doubled
private void resize(int max) {
    Item[] temp = (Item[]) new Object[max];
    for (int i=0; i<N; i++) {
        temp[i] = a[i];
    }
    a = temp;
}

// check if the size is too small in push()
public void push(Item item) {
    if (N == a.length) {
        resize(2*a.length);
    }
    a[N++] = item;
}

// shrink a[]'s size into a half if stack's size < 1/4 * a.length 
// to ensure the stack never overflow.
// if the portion > 1/4: tends to do more migrations since less vacant space after shrinking
// if the portion < 1/4: tends to waste memory space since array is vacant
public String pop() {
    String item = a[--N];
    a[N] = null;    // prevent object loitering
    if (N>0 && N==a.length/4) {
        resize(a.length/2);
    }
    return item;
}
~~~

还又一个需要处理的改进是防止在 `pop()` 实现中, **被弹出元素的引用** 仍然存在于数组中而无法被 `Java` 垃圾收集器回收, 造成对象游离. 实现这一优化的一个有效手段是将被弹出的数组元素值设为 `null`, 这将 **覆盖无效的引用** (也就是清除掉对它的引用), 并使得系统在用例使用完被弹出的元素后 **回收它占用的内存空间**. 

下一个需要处理的问题是实现 `iterable` 接口, 使这个数据类型支持 **迭代**:

首先需要在类声明中加入  ```implements Iterable<Item>```, 然后需要在类中实现方法 `iterator()` 并返回一个迭代器 `Iterator<Item>`: 

~~~java
// we name the iterator to 'ReverseArrayIterator'
// since we need to traverse it in reverse order
public Iterator<Item> iterator() {
    return new ReverseArrayIterator();
}
~~~

而迭代器本身又是一个 **实现了 `hasNext()` 和 `next()` 方法的类** 的对象:

~~~java
public class ReverseArrayIterator implements Iterator<item> {
    private int i = N;
    public boolean hasNext() {
        return i>0;
    }
    public Item next() {
        return a[--i];
    }
    // leave it empty, we does not want to make it possible for 
    // editing data structure inside the iterations
    public void remove() {}
}
~~~

这样, 我们从定容栈出发, 完成了 `Stack API` 的一种能够 **动态调整数组大小** 的实现. 用例支持创建任意类型数据的栈, 并可调用高级循环 `foreach` 语句按照后进先出的顺序对全栈元素迭代访问. 这一实现还可以用作其他 **集合数据类型** 的实现的模板:

~~~java
// for some reason, 'Iterator' is not contained in 'java.lang'
// so we have to import it manually
import java.util.Iterator;  
public class ResizingArrayStack<Item> implements Iterable<Item> {
    private Item a = (Item[]) new Object[1]; // stack elem array
    private int N = 0;                       // the num of elements
    
    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    private void resize(int max) {
        Item[] temp = (Item[]) new Object[max];
        for (int i=0; i<N; i++) {
            temp[i] = a[i];
        }
        a = temp;
    }

    public void push(Item item) {
        if (N == a.length) {
            resize(2*a.length);
        }
        a[N++] = item;
    }

    public Item pop() {
        Item item = a[--N];
        a[N] = null;
        if (N>0 && N == a.length/4) {
            resize(a.length/2);
        }
        return item;
    }

    public class ReverseArrayIterator implements Iterator<item> {
        private int i = N;
        public boolean hasNext() {
            return i>0;
        }
        public Item next() {
            return a[--i];
        }
        public void remove() {}
}
~~~

<br>

## 1.3 基础数据结构: 链表

**链表** 是一种非 `Java` 直接支持的数据结构, 需要我们从零开始手动实现. 它适用于在 **集合类的抽象数据类型实现** 中表示数据的合适选择. 

**定义**: 链表
> **链表** 是一种 **递归的数据结构**, 任何一个链表或为空, 或是指向一个节点 (`Node`) 的 **引用**, 且该节点包含一个 **泛型的元素** 和一个 **指向另一条链表的引用**.

根据递归定义, 我们只需要一个 `Node` 类型的变量就能表示一条链表, 并保证它的值为 `null` 或指向另一个 `next` 域也指向了另一条链表的 `Node` 对象:

~~~java
private class Node {
    Item item;
    Node next;
}
~~~

链表所表示的是 **一列元素**, 下面我们讨论如何在链表中向序列 **插入元素** 或从序列中 **删除元素**. 

1.  在表头插入结点:<br> 
    ~~~java
    Node oldfirst = first; 
    first = new Node();
    first.item = "...";
    first.next = oldfirst;
    ~~~
    注意在链表开头插入一个结点的代码只需要几行赋值语句, 故其执行时间 **和链表的长度无关**.

2. 从表头删除结点:<br>
    要从表头删除结点, 我们只需要将 `first` 指向 `first.next` 即可, 而如此操作后 **原来的表头结点对象** 由于无法再被访问到而成为了一个将被自动回收的 **孤儿**, 因此也无需关心垃圾回收问题. 同样的, 这个操作的执行时间也 **和链表的长度无关**.
    ~~~java
    first = first.next;
    ~~~
    
3. 在表尾插入结点:<br>
   一般地, 我们只需要先保存指向尾结点的链接, 创建新的尾结点并将原来的尾链接指向这个新的结点即可完成操作. 不过需要注意的是, 这一步骤不适用于链表为空的情况, 故需要额外的判断: 
   ~~~java
    Node oldlast = last; 
    last = new Node();
    last.item = "...";
    oldlast = last;
   ~~~

可见对于 **链表**, 在表头插入, 删除结点和从表尾插入结点都不困难. 但是, 如果我们需要删除指定的结点和在指定结点前插入一个新结点则必须 **遍历整个列表**. 一个棘手的例子是, 我们必须便利整条链表并找到指向尾结点的结点才能将链表的尾结点删除, 而这种解决方案所需要的时间和链表的长度成正比.

实现对链表节点的任意插入和删除操作的标准解决方式是使用 **双向链表**, 其每个节点都含有两个 **分别指向不同方向** 的链接, 其具体实现就是单链表的简单扩展, 在此不多赘述.

要遍历链表, 我们只需将循环的索引变量 `x` **初始化为链表的首结点**, 然后通过 `x.item` 访问与 `x` 相关的元素, 再将 `x` 设为 `x.next` 访问链表中的下一结点, 循环往复直到 `x` 为 `null` 为止:

~~~java
for (Node x=first; x!=null; x=x.next) {
    // process x.item(s)
}
~~~

<br>

### 使用链表实现 `Stack API`

将栈保存为一条链表, 将表头视为栈顶, 实例变量 `first` 指向栈顶, 这样在向栈内 **压入元素** 时, 该元素会添加在表头, 而 **弹出元素** 时该元素会从表头删除. 

要实现 `size()` 方法, 只需使用一个实例变量 `N` 保存元素的个数, 并在 **压入或弹出** 元素时同步更新. 而实现 `isEmpty()` 方法的方式就是检测 `N` 是否为 $0$: 

~~~java
public class Stack<Item> implements Iterable<Item>{
    private Node first;     // top of the stack
    private int N;          // length of the stack

    // a nested class defining node
    private class Node {
        Item item;
        Node next;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void push(Item item) {
        Node oldfirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        N++;
    }

    public Item pop() {
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }
    
    // we will talk about the implementation of iterator later...
}
~~~

<br>

### 使用链表实现 `Queue API`

将队列表示为一条从 **最早插入的元素** 到 **最近插入元素** 的链表, 其中实例变量 `first` 指向 **队列的开头**, 实例变量 `last` 指向 **队列的结尾**. 

要将一个元素入列, 就需要将其添加到 **表尾**, 但是注意, 在链表为空时所新添加的元素 **既为队首又为队尾**, 因此我们需要将两个实例变量 `first` 和 `last` 同时指向它. 

要将一个元素出列, 只需要删除 **表头的结点**, 而在 **出列后链表为空** 时需要更新 `last` 的值: 

~~~java
public class Queue<Item> implements Iterable<Item>{
    private Node first;     // first node of the queue
    private Node last;      // last node of the queue 
    private int N;          // length of the queue

    // a nested class defining node
    private class Node {
        Item item;
        Node next;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void enqueue(Item item) {
        Node oldlast = last; 
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last; 
        } else {
            oldlast.next = last;
        }
        N++;
    }

    public Item dequeue() {
        Item item = first.item;
        first = first.next;
        if (isEmpty()) {
            last = null;
        } 
        N--;
        return item;
    }
    
    // we will talk about the implementation of iterator later...
}
~~~

<br>

### 使用链表实现 `Bag API`

只需对 `Stack API` 的链表实现进行简单改动即可实现 `Bag API`:

~~~java
public class Bag<Item> implements Iterable<Item>{
    
    // actually we don't care the order of adding items to the bag
    // since it's orderless
    private Node first;     // top of the bag
    private int N;          // length of the bag

    // a nested class defining node
    private class Node {
        Item item;
        Node next;
    }

    public boolean isEmpty() {
        return first == null;
    }

    public int size() {
        return N;
    }

    public void add(Item item) {
        Node oldfirst = first; 
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        N++;
    }
    
    // we will talk about the implementation of iterator later...
}
~~~

<br>

下面考虑迭代的实现. 我们首先需要引用 `Java` 的 **`Iterator` 接口** 并在类定义中加入对 `Iterable` 接口的实现声明:

~~~java
import java.util.Iterator;
~~~

随后我们提供 `iterator()` 方法:

~~~java
public Iterator<Item> iterator() {
    return new ListIterator();
}
~~~

然后实现 `ListIterator()`, 这个类需要提供 `hasNext()`, `next()` 和 `remove()` 方法供 **用例的 `foreach()`** 语句使用:

~~~java
private class ListIterator implements Iterator<Item> {
    private Node current = first;
    
    public boolean hasNext() {
        return current != null;
    }

    public void remove() {
        // intentially left blank to prevent data modification inside the `foreach` loop
    }

    public Item next() {
        Item item = current.item;
        current = current.next;
        return item;
    }
}
~~~

<br>

## 1.4 算法分析










