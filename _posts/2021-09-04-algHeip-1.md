---
layout:     post
title:      普林斯顿算法4-Ch1 基础
subtitle:   Basics and Union Find Set
date:       2021-09-03
author:     R1NG
header-img: img/blogpost_images/20210905154720.png
description: 
catalog: true
tags:
    - 2021
    - 数据结构和算法
    - 扩展自习
---

# Ch1 基础

在本章中, 我们将学习在随后的章节中用于实现, 分析和比较算法的基本原则与方法. 本书使用 `Java` 编程, 故在第一章中涉及了诸多关于 `Java` 语言的基本语法和面向对象程序设计的概念. 除此之外,  **背包, 队列和栈** 这三种基础的 **抽象数据类型** 也在该章节中被介绍. 最后, 本章介绍了一些分析算法性能的方法, 并通过对连通性问题解法的讨论引出了 **并查集** 这个数据结构的实现. 

<br>

## 1.1 `Java` 程序设计模型和面向对象程序设计

我们首先回顾一些重要的 `Java` 语言特性和 `OOP` 概念. 


**定义**: 数据类型和抽象数据类型

>数据类型指的是 **一组值** 和 **一组对这些值的操作的集合**, 而 `Java` 程序设计的基础是使用 `class` 关键字构造称为 **引用类型** 的数据类型.

要使用一种数据类型, 我们不需要知道它是如何实现的. 如果我们将一种数据类型的数据表示方式 **隐藏** 起来, 那么这样的数据类型就被称为 **抽象数据类型**. 在实现抽象数据类型时, 我们只需要将注意力集中在它的 `API` 所描述的操作上而无需关注具体的细节. 

`API` 常被用来描述 **抽象数据类型** 的行为. 其作用是列出该数据类型的所有 **构造函数** 和 **实例方法**. 

<br>

**定义**: 对象

>对象是 **能够承载数据类型的值**的实体. `Java` 中所有对象均具备三个特性: **状态**, 即数据类型中的值; **标识**, 用于将对象加以区分; **行为**, 亦即数据类型的操作. 

<br>

要完全了解一个数据类型, 我们就需要它的 **API**, **典型用例** 和 **实现**. 为了达成用例和实现的分离, 我们可以将用例独立成含有一个静态方法 `main()` 的类, 并将数据类型定义中的 `main()` 方法预留为一个测试用例. 同样的, 在开发数据类型时, 我们可以按照下列的顺序使用 **抽象数据类型** 满足用例的需求:

1. 定义一份 `API` 实现编程的模块化.
2. 编写一个 `Java` 类实现 `API` 的定义.
3. 实现多个测试用例用于验证前两步的设计和完成情况.

面向对象程序设计的一大特征是 **使用数据类型的实现封装数据**. 封装使我们可以独立开发 **用例** 和 **实现** 的代码, 并且确保即使以后 **实现** 部分的代码被替换成改进的版本, **用例** 部分也不会受到影响. 在学习数据结构与算法时, 倘若开发出更好的算法, 只需要用抽象数据类型的, 改进的实现替换原有的旧实现, 就可以保证在不改变任何用例代码的前提下改善所有这些用例的性能. 

**定义**: 接口和子类

> **接口** 规定了一系列需要实现的方法, 它可以使两个实现了这些公共方法的, 原本没有关联的类之间建立联系.  **子类** 允许我们在不重写整个类的前提下就能改变它的行为或者添加新的功能, 其主要思想是定义一个新类来继承父类的所有 **实例方法和实例变量**, 其中子类可以包含比父类更多的方法, 也可以对父类中原有的方法进行重定义. 

<br>

## 1.2 基础抽象数据类型: 背包, 队列和栈

**背包**, **队列** 和 **栈** 的不同之处只在于其删除或访问对象的顺序. 我们首先介绍这三种数据结构的 `API`:

1. 背包

    |`public class` | `Bag<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Bag()`|创建一个空背包|
    |`void` | `add(Item item)`| 添加一个新元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

2. 队列  (先进先出)
   
    |`public class` | `Queue<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Queue()`|创建一个空队列|
    |`void` | `enqueue(Item item)`| 添加一个新元素|
    |`Item`|`dequeue()`|删除最近添加的元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

3. 栈 (后进先出, 下压栈)

    |`public class` | `Stack<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Stack()`|创建一个空栈|
    |`void` | `push(Item item)`| 添加一个新元素|
    |`Item`|`pop()`|删除最近添加的元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

下面分别介绍三种数据类型.

### 背包

背包是一种 **不支持从中删除元素** 的 **集合数据类型**, 其作用是帮助用例收集并迭代遍历所有收集到的元素, 并且 **迭代的顺序不确定**且与用例无关. 

### 队列 (先进先出)

先进先出队列, 或简称队列, 是一种基于先进先出 (`FIFO`) 策略的集合类型. 在用例使用高级循环语句 `foreach` 迭代访问队列的元素时, 元素被处理的顺序就是 **它们被添加进队列中** 的顺序. 通过在程序中使用队列数据结构, 我们可以在集合保存元素的同时 **保存它们的相对顺序**.

### 下压栈

下压栈, 或简称栈, 是一种基于后进先出 (`LIFO`) 策略的集合类型. 和队列不同, 当用例使用 `foreach` 迭代遍历栈中元素时, 元素的处理顺序恰好与它们被压入的顺序相反. 通过在程序中使用队列数据结构, 我们可以在用集合保存元素的同时 **颠倒保存它们的相对顺序**.

<br>

下面讨论对上述三种数据类型的实现. 首先考虑一种容量固定的抽象数据类型: **定容栈**:

定容栈只能处理 `String`, 不支持迭代并且要求用例指定一个容量. 我们可以使用 **`String`数组** 作为定容栈的数据表示方式:

~~~java
public class FixedCapacityStackOfStrings {
    private String[] a;     // stack entries
    private int N;          // size
    
    // constructor
    public FixedCapacityStackOfStrings(int cap) {
        a = new String[cap];
    }

    // check whether a is empty or not
    public boolean isEmpty() {
        return N == 0;
    }

    // return the size N
    public int size() {
        return N;
    }

    // push new elem 
    public void push(String item) {
        a[N++] = item;
    }

    // pop out item
    public String pop() {
        return a[N--];
    }

    // usage cases (tests)
    public static void main(String[] args) {
       FixedCapacityStackOfStrings s;
        s = new FixedCapacityStackOfStrings(100);
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-")) {
                s.push(item);
            } else if (!s.isEmpty()) {
                StdOut.print(s.pop() + " ");
            }
            StdOut.println("(" + s.size() + " left on stack)")
        }
    }
}
~~~

上述代码给出的实现最明显的问题之一就是只能处理 `String` 对象. 我们可以使用 **泛型** 重新实现这个数据类型, 使其可以对任何类型的对象进行处理:

~~~java
public class FixedCapacityStack<Item> {
    private Item[] a;       // stack entries
    private int N;          // size
    
    // constructor
    public FixedCapacityStackOfStrings(int cap) {
        // java does not allow creating generic arrays directly
        // therefore we need conversions
        a = (Item[]) new Object[cap];   
    }

    // check whether a is empty or not
    public boolean isEmpty() {
        return N == 0;
    }

    // return the size N
    public int size() {
        return N;
    }

    // push new elem 
    public void push(Item item) {
        a[N++] = item;
    }

    // pop out item
    public Item pop() {
        return a[N--];
    }

    // usage cases (tests)
    // specify the type of 'Item' is 'String'
    public static void main(String[] args) {
       FixedCapacityStack<String> s;
        s = new FixedCapacityStackOfStrings<String>(100);
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            if (!item.equals("-")) {
                s.push(item);
            } else if (!s.isEmpty()) {
                StdOut.print(s.pop() + " ");
            }
            StdOut.println("(" + s.size() + " left on stack)")
        }
    }
}
~~~

注意上下两个实现方式的区别.

在使用泛型对数据类型的实现方式进行改进使其适用于任何类型的对象后, 我们现在需要考虑解除定容限制需要使用什么样的优化方式. `Java` 数组一旦创建大小无法改变, 但这不影响我们在将要改变栈内容时, 一旦检测到剩余容量不足时将原数组中的所有内容迁移到一个更大的数组中.

具体来说, 我们所进行的修改如下:

~~~java
// migrate the array to a new one with its size doubled
private void resize(int max) {
    Item[] temp = (Item[]) new Object[max];
    for (int i=0; i<N; i++) {
        temp[i] = a[i];
    }
    a = temp;
}

// check if the size is too small in push()
public void push(Item item) {
    if (N == a.length) {
        resize(2*a.length);
    }
    a[N++] = item;
}

// shrink a[]'s size into a half if stack's size < 1/4 * a.length 
// to ensure the stack never overflow.
// if the portion > 1/4: tends to do more migrations since less vacant space after shrinking
// if the portion < 1/4: tends to waste memory space since array is vacant
public String pop() {
    String item = a[--N];
    a[N] = null;    // prevent object loitering
    if (N>0 && N==a.length/4) {
        resize(a.length/2);
    }
    return item;
}
~~~

还又一个需要处理的改进是防止在 `pop()` 实现中, **被弹出元素的引用** 仍然存在于数组中而无法被 `Java` 垃圾收集器回收, 造成对象游离. 实现这一优化的一个有效手段是将被弹出的数组元素值设为 `null`, 这将 **覆盖无效的引用** (也就是清除掉对它的引用), 并使得系统在用例使用完被弹出的元素后 **回收它占用的内存空间**. 

下一个需要处理的问题是实现 `iterable` 接口, 使这个数据类型支持 **迭代**:

首先需要在类声明中加入  ```implements Iterable<Item>```, 然后需要在类中实现方法 `iterator()` 并返回一个迭代器 `Iterator<Item>`: 

~~~java
// we name the iterator to 'ReverseArrayIterator'
// since we need to traverse it in reverse order
public Iterator<Item> iterator() {
    return new ReverseArrayIterator();
}
~~~

而迭代器本身又是一个 **实现了 `hasNext()` 和 `next()` 方法的类** 的对象:

~~~java
public class ReverseArrayIterator implements Iterator<item> {
    private int i = N;
    public boolean hasNext() {
        return i>0;
    }
    public Item next() {
        return a[--i];
    }
    // leave it empty, we does not want to make it possible for 
    // editing data structure inside the iterations
    public void remove() {}
}
~~~

这样, 我们从定容栈出发, 完成了 `Stack API` 的一种能够 **动态调整数组大小** 的实现. 用例支持创建任意类型数据的栈, 并可调用高级循环 `foreach` 语句按照后进先出的顺序对全栈元素迭代访问. 这一实现还可以用作其他 **集合数据类型** 的实现的模板:

~~~java
// for some reason, 'Iterator' is not contained in 'java.lang'
// so we have to import it manually
import java.util.Iterator;  
public class ResizingArrayStack<Item> implements Iterable<Item> {
    private Item a = (Item[]) new Object[1]; // stack elem array
    private int N = 0;                       // the num of elements
    
    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    private void resize(int max) {
        Item[] temp = (Item[]) new Object[max];
        for (int i=0; i<N; i++) {
            temp[i] = a[i];
        }
        a = temp;
    }

    public void push(Item item) {
        if (N == a.length) {
            resize(2*a.length);
        }
        a[N++] = item;
    }

    public Item pop() {
        Item item = a[--N];
        a[N] = null;
        if (N>0 && N == a.length/4) {
            resize(a.length/2);
        }
        return item;
    }

    public class ReverseArrayIterator implements Iterator<item> {
        private int i = N;
        public boolean hasNext() {
            return i>0;
        }
        public Item next() {
            return a[--i];
        }
        public void remove() {}
}
~~~

<br>

## 1.3 基础数据结构: 链表

**链表** 是一种非 `Java` 直接支持的数据结构, 需要我们从零开始手动实现. 它适用于在 **集合累的抽象数据类型实现** 中表示数据的合适选择. 

**定义**: 链表
> **链表** 是一种 **递归的数据结构**, 任何一个链表或为空, 或是指向一个节点 (`Node`) 的 **引用**, 且该节点包含一个 **泛型的元素** 和一个 **指向另一条链表的引用**.

根据递归定义, 我们只需要一个 `Node` 类型的变量就能表示一条链表. 