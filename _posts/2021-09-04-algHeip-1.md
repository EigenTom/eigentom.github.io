---
layout:     post
title:      普林斯顿算法4-Ch1 基础
subtitle:   Basics and Union Find Set
date:       2021-09-03
author:     R1NG
header-img: img/blogpost_images/20210905154720.png
description: 
catalog: true
tags:
    - 2021
    - 数据结构和算法
    - 扩展自习
---

# Ch1 基础

在本章中, 我们将学习在随后的章节中用于实现, 分析和比较算法的基本原则与方法. 本书使用 `Java` 编程, 故在第一章中涉及了诸多关于 `Java` 语言的基本语法和面向对象程序设计的概念. 除此之外,  **背包, 队列和栈** 这三种基础的 **抽象数据类型** 也在该章节中被介绍. 最后, 本章介绍了一些分析算法性能的方法, 并通过对连通性问题解法的讨论引出了 **并查集** 这个数据结构的实现. 

<br>

## 1.1 `Java` 程序设计模型和面向对象程序设计

我们首先回顾一些重要的 `Java` 语言特性和 `OOP` 概念. 


**定义**: 数据类型和抽象数据类型

>数据类型指的是 **一组值** 和 **一组对这些值的操作的集合**, 而 `Java` 程序设计的基础是使用 `class` 关键字构造称为 **引用类型** 的数据类型.

要使用一种数据类型, 我们不需要知道它是如何实现的. 如果我们将一种数据类型的数据表示方式 **隐藏** 起来, 那么这样的数据类型就被称为 **抽象数据类型**. 在实现抽象数据类型时, 我们只需要将注意力集中在它的 `API` 所描述的操作上而无需关注具体的细节. 

`API` 常被用来描述 **抽象数据类型** 的行为. 其作用是列出该数据类型的所有 **构造函数** 和 **实例方法**. 

<br>

**定义**: 对象

>对象是 **能够承载数据类型的值**的实体. `Java` 中所有对象均具备三个特性: **状态**, 即数据类型中的值; **标识**, 用于将对象加以区分; **行为**, 亦即数据类型的操作. 

<br>

要完全了解一个数据类型, 我们就需要它的 **API**, **典型用例** 和 **实现**. 为了达成用例和实现的分离, 我们可以将用例独立成含有一个静态方法 `main()` 的类, 并将数据类型定义中的 `main()` 方法预留为一个测试用例. 同样的, 在开发数据类型时, 我们可以按照下列的顺序使用 **抽象数据类型** 满足用例的需求:

1. 定义一份 `API` 实现编程的模块化.
2. 编写一个 `Java` 类实现 `API` 的定义.
3. 实现多个测试用例用于验证前两步的设计和完成情况.

面向对象程序设计的一大特征是 **使用数据类型的实现封装数据**. 封装使我们可以独立开发 **用例** 和 **实现** 的代码, 并且确保即使以后 **实现** 部分的代码被替换成改进的版本, **用例** 部分也不会受到影响. 在学习数据结构与算法时, 倘若开发出更好的算法, 只需要用抽象数据类型的, 改进的实现替换原有的旧实现, 就可以保证在不改变任何用例代码的前提下改善所有这些用例的性能. 

**定义**: 接口和子类

> **接口** 规定了一系列需要实现的方法, 它可以使两个实现了这些公共方法的, 原本没有关联的类之间建立联系.  **子类** 允许我们在不重写整个类的前提下就能改变它的行为或者添加新的功能, 其主要思想是定义一个新类来继承父类的所有 **实例方法和实例变量**, 其中子类可以包含比父类更多的方法, 也可以对父类中原有的方法进行重定义. 

<br>

## 1.2 基础抽象数据类型: 背包, 队列和栈

**背包**, **队列** 和 **栈** 的不同之处只在于其删除或访问对象的顺序. 我们首先介绍这三种数据结构的 `API`:

1. 背包

    |`public class` | `Bag<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Bag()`|创建一个空背包|
    |`void` | `add(Item item)`| 添加一个新元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

2. 队列  (先进先出)
    |`public class` | `Queue<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Queue()`|创建一个空队列|
    |`void` | `enqueue(Item item)`| 添加一个新元素|
    |`Item`|`dequeue()`|删除最近添加的元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

3. 栈 (后进先出, 下压栈)
    |`public class` | `Stack<Item>`| `implements Iterable<Item>` |
    |-|-|-|
    ||`Stack()`|创建一个空栈|
    |`void` | `push(Item item)`| 添加一个新元素|
    |`Item`|`pop()`|删除最近添加的元素|
    |`boolean` | `isEmpty()`| 检查是否为空|
    |`int` | `size()`| 元素数量 |

下面分别介绍三种数据类型.

### 背包

背包是一种 **不支持从中删除元素** 的 **集合数据类型**, 其作用是帮助用例收集并迭代遍历所有收集到的元素, 并且 **迭代的顺序不确定**且与用例无关. 

### 队列 (先进先出)

先进先出队列, 或简称队列, 是一种基于先进先出 (`FIFO`) 策略的集合类型. 在用例使用高级循环语句 `foreach` 迭代访问队列的元素时, 元素被处理的顺序就是 **它们被添加进队列中** 的顺序. 通过在程序中使用队列数据结构, 我们可以在集合保存元素的同时 **保存它们的相对顺序**.

### 下压栈

下压栈, 或简称栈, 是一种基于后进先出 (`LIFO`) 策略的集合类型. 和队列不同, 当用例使用 `foreach` 迭代遍历栈中元素时, 元素的处理顺序恰好与它们被压入的顺序相反. 通过在程序中使用队列数据结构, 我们可以在用集合保存元素的同时 **颠倒保存它们的相对顺序**.



