---
layout:     post
title:      Prolog 学习 Ch3
subtitle:   Recursion
date:       2021-10-13
author:     R1NG
header-img: img/post-bg-comp23111.jpg
description: 
catalog: true
tags:
    - 2021
    - 课程笔记
    - COMP24011
---


# `Prolog` 入门: 递归

在本章中, 我们将介绍 `Prolog` 中的递归定义, 并举例说明一个问题: `Prolog` 程序的 **声明性含义** 与 **过程性含义** 之间可能会存在不匹配的情形.

## 1. 递归定义

在 `Prolog` 中, 谓词可以被 **递归地** 定义. 简单来说, 如果一个谓词的定义中至少有一条规则包含了其本身, 则称它是 **递归地定义** 的.

我们首先考虑下列的知识库:

~~~prolog
is_digesting(X, Y) :- just_ate(X, Y). 
is_digesting(X, Y) :- 
                just_ate(X, Z), 
                is_digesting(Z, Y). 

just_ate(mosquito,blood(john)). 
just_ate(frog,mosquito). 
just_ate(stork,frog).
~~~

上述的知识库中定义了 $3$ 条事实和 $2$ 条规则. 同时, 可以看出谓词 `is_digesting` 也是递归定义的, 因为在第二行对其的定义中出现了它自身. 而最重要的是, 由于 (并不是递归定义的) 第一条规则的存在, 我们可以从从第二条规则所构造的无限递归 (循环) 中挣脱出来. 下面我们分别对我们构造的知识库的 **声明式含义** 和 **过程式含义** 进行讨论. 

“声明” (`declarative`), 即指给定 `Prolog` 知识库的逻辑含义. 也就是说, `Prolog` 知识库的 **声明式含义** 所描述的就是 “这个知识库说了什么”, 或者 “从逻辑的角度上看, 这个知识库告诉了我们什么”. 

我们在知识库中所定义的两条规则从声明式含义的角度理解就是:

~~~prolog
% If X has just eaten Y, then X is now digesting Y.
is_digesting(X, Y) :- just_ate(X,Y). 

% If X has just eaten Z and Z is digesting Y, then X is digesting Y, too.
is_digesting(X, Y) :- 
                just_ate(X, Z), 
                is_digesting(Z, Y). 
~~~

这两条规则显然在声明式含义的解释下都是符合逻辑的.

下面我们需要考虑这条递归定义的规则在 **过程式含义** 的解释下的真实含义, 也就是说, 当我们的某条查询指令用到了或者涉及到它时, 这条递归定义究竟会做什么.

对于常规的非递归规则而言, 它在过程式含义的解释下意义非常显然. 而对于本例提及的第二条递归定义而言, 这样的定义使 `Prolog` 可以使用这样的策略判断 `is_digesting(X, Y)`: 尝试找到某个 `Z`, 并且它满足: 1. `just_ate(X, Z)` 为真; 2. `is_digesting(Z, Y)` 为真. 换句话说, 该条规则的定义使 `Prolog` 将执行证明搜索寻找可行解的任务切分为两个子任务. 理想状态下, 通过检索知识库, 两个子任务都能够得到解决, 从而原任务相应地也得到了解决.

![20211015225123](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20211015225123.png)

我们下面考虑查询语句 `is_digesting(stork,mosquito).`.

基于上一章所介绍的证明搜索流程, 我们知道 `Prolog` 首先会尝试联合知识库中的第一条规则. 通过对变量 `X` 和 `Y` 进行实例化 (与规则中的项联合), 我们可以得到一条并不存在于知识库中的规则

~~~prolog
just_ate(stork, mosquito).
~~~

第一条解路径并不能满足目标, 因此 `Prolog` 回溯至原点尝试第二条规则. 经过联合后程序需要满足的目标变为:

~~~prolog
just_ate(stork, Z), 
is_digesting(Z, mosquito).
~~~

也就是说, `Prolog` 需要找到一个同时满足两条目标的值为变量 `Z` 赋值.

经过对知识库的检索, `Prolog` 可以找到一个满足第一条目标的值 `frog`. 并且在尝试满足第二个目标时, 由于 **第一条规则的存在**, 我们可以通过推导 `is_digesting(frog,mosquito).` 得到位于知识库中的事实 `just_ate(frog,mosquito).`, 最终完成证明搜索. 

从这个例子中不难看出, 形如第一条规则一般, 允许 `Prolog` 在执行对递归定义的证明搜索中最终跳出递归的规则是至关重要的 我们一般称其为
**基本子句** (`Escape Clause, or Base Clause`). 倘若我们的知识库中不存在这样的基本子句, `Prolog` 就会重复执行无意义的计算而无法自拔. 

我们再来看一个将递归应用于 `Prolog` 程序设计中的例子, 体会通过应用递归的概念, 我们是如何轻松愉快地定义 `后代` (`descendent`) 的概念的. 

首先给定一个记录了关系 `child(X, Y)` 的知识库:

~~~prolog
child(bridget, caroline). 
child(caroline, donna).
~~~

可见 `Caroline` 是 `Bridget` 的孩子, 而 `Donna` 又是 `Caroline` 的孩子. 我们下面首先尝试使用 **非递归定义** 对 `后代` 这一概念建模. 我们可以给出如下定义:

~~~prolog
descend(X, Y) :- child(X, Y). 
descend(X, Y) :- child(X, Z), 
                child(Z, Y).
~~~

如此我们就定义了深度为 `2` 的 `后代` 关系. 但是不难看出, 使用这种方式进行的定义不具备任何可扩展性, 当我们需要考虑深度更高的 `后代` 关系时, 它就不再适用了. 随着深度愈发递增, 我们需要为每一层 `后代` 关系单独定义, 此时我们的知识库大小就要被迫膨胀到不可描述的级别. 

实际上, 我们不难观察到 `后代` 这一待建模的概念具有传递性. 基于传递性, 首先显然有:

~~~prolog
%Y is a child of X, if...
descend(X, Y) :- child(X, Z),     % 1. Z is a child of X
                 descend(Z, Y).   % 2. Y is a descendant of Z
~~~

不难看出上述的递归子句具有高度的可扩展性. 并且在深度为 $1$ 时, `后代` 和 `孩子` 的定义具有等价性:

~~~prolog
descend(X, Y) :- child(X, Y).
~~~

将两条规则拼接即可得到由一条 **基本子句** 和一条 **递归子句** 组成的 **完整的** 递归定义. 在使用结合了递归定义的规则的知识库进行查询时, `Prolog` 在每一次搜索证明中都会首先尝试联合基本子句以尝试满足当前目标, 而若不满足的话就联合第二条递归子句将问题进一步变换. 最终, 我们可以得到一条形如下图的搜索树.

![20211015232432](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20211015232432.png)

得益于递归子句的结构性和定义本身的可扩展性, 我们可以使用简单的递归子句实现定义, 并在需要的情形下轻松地通过递归将定义的深度扩展到需要的级别而无需让定义本身复杂化. 

