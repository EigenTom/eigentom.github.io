---
layout:     post
title:      基于知识组织的人工智能
subtitle:   Introduction to Knowledge-based AI + Chapter 1
date:       2022-02-11
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: Logic, once again...
catalog: true
tags:
    - 课程笔记
---

# 绪论

本质上我们将在本课程中所接触的内容是对智能体 (`Intelligent System`) 表示和推理其所在世界中的知识和信息的研究. 在本课程中, 我们将接触和学习 **知识表示** (`Knowledge Representation`) 的核心概念和数种自动推理 (`Automated Reasoning`) 方法. 

课程内容基本分为四个板块:

## 1. 一阶逻辑 (`First-Order Logic`) 和自动推理

* 一阶逻辑的 **语法和语义**
* 一节逻辑公式和子句形式 (`Clausal Form`) 的转换
* 有序语义归结 (`Ordered Resolution`)
* 基于饱和原则的证明搜索
* 模型 (`Model`) 构造

## 2. `Prolog`
* `Prolog` 语法和证明搜索执行规则
* `Prolog` 中基于 `Horn` 子句的反向推理法的应用
* 基于 `Prolog` 的定理证明

## 3. 知识表示
* 本体论工程 (`Ontological Engineering`)
* 对类型和物体的表示
* 对事件的表示
* 基于分类 (`Categories`) 的推理系统
* 语义网络 (`Semantic Networks`)
* 描述逻辑
* 基于默认信息 (`Default Information`) 的推理

## 4. 归纳推理与回溯推理
* 基于逻辑问题的学习 (`Learning as a Logical Problem`)
* 基于知识的学习 (`Learning with Knowledge`)
* 归纳逻辑程序设计
* 解释和诊断 (`Explaination and Diagnosis`)
* 基于解释的学习 (`Explaination-based Learning`)

我们下面开始对课程内容的介绍.

<br>

# 一阶逻辑 (`First-Order Logic`) 和自动推理

## 1. 基于一阶逻辑的知识表示

**定义 1.1** (知识表示)
> 称 **精确** (`Precise`) 和 **无歧义** (`Unambiguous`) 的, 表示世界中的已知信息的方式为 **知识表示**. 

**定义 1.2** (自动推理)
> 自动推理一般被定义为 **自动地** 基于某些已知事实推导出与之相关的声明 (`Statement`) 的行为.

在一阶逻辑中, 推理是基于预先定义好的 **推断规则** (`Inference Rules`) 执行的. 

推理同样依赖于对现实世界中知识的表示以及所具有的知识的多寡. 对于一阶逻辑, 我们将知识库 (`Knowledge Base`) 视为对现实世界的 **符号化抽象** (`Symbolic Abstraction`): 在知识库中, 称我们所关心的, 某个形式化的, 现实世界的子集为 **域** (`Domain`), 而用于表示域中元素的符号为 **标识** (`Signature`). 

### 1.1 一阶逻辑的语法

**定义 1.1.1** (标识, `Signature`)
> 称某个一阶公式的 **标识**
> 
> $$\Sigma = \langle \mathcal{F}, \mathcal{P}, \text{arr}\rangle$$
> 
> 由两个不相交的, 分别包含 **函数符号** 与 **谓词符号** 的集合 $\mathcal{F}, \mathcal{P}$ 以及 **表明每一个符号的元数** (`Arity`) 的映射 
> 
> $$\text{arr}: \mathcal{F} \cup \mathcal{P} \rightarrow \mathbb{N}_0$$
>
> 组成. 

**定义 1.1.2** (项, `Term`)
> 在一阶逻辑中, 下列元素均称为 **项**:<br>
> 1. 任何 **变量** 均为项.
> 2. 任何 **常量** (即元数为 $0$ 的函数符号) 均为项.
> 3. 若函数符号 $f$ 的元数为 $k$, $k > 0$ 且 $t_i, i\in [k]$ 均为项, 则 
>       $$f(t_1, \cdots, t_k)$$
>       
>       为项.
> 

**定义 1.1.3** (原子, `Atom`)
> 在一阶逻辑中, 下列元素均称为 **原子**:<br>
> 1. 任何 **谓词** (即元数为 $0$ 的谓词符号) 均为原子.
> 2. 若 $t_1, t_2$ 均为项, 则 $t_1 = t_2$ 为原子.
> 3. 若谓词符号 $p$ 的元数为 $k$, $k > 0$ 且 $t_i, i\in [k]$ 均为项, 则 
>       $$p(t_1, \cdots, t_k)$$
>       
>       为原子.
>

**定义 1.1.4** (公式 `Formula`)
> 在一阶逻辑中, 我们使用如下的规则递归定义 **公式**:<br>
> 1. 任何原子均为公式.
> 2. 布尔值 `True` 为公式.
> 3. 若 $\phi_1, \phi_2$ 均为公式, 则 
>       $$\neg \phi_1, \phi_1 \wedge \phi_2, \forall x. \phi_1$$
>       
>       为公式, 其中 $x$ 为变量.
> 

进一步地, 我们可以定义:

1. $\text{False} \equiv \neg\text{True}$
2. $\phi_1 \vee \phi_2 \equiv \neg (\phi_1 \wedge \phi_2)$ 
3. $\phi_1 \rightarrow \phi_2 \equiv \neg \phi_1 \vee \phi_2$
4. $\phi_1 \leftrightarrow \phi_2 \equiv ((\phi_1 \rightarrow \phi_2) \wedge (\phi_2 \rightarrow \phi_1))$
5. $\exists x. \phi \equiv \neg(\forall x. \neg \phi)$.

我们可以不甚严谨地理解上述的逻辑符号或量词:

![20220221205550](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221205550.png)

同时考虑如下的例子:

![20220221210809](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221210809.png)

![20220221210156](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221210156.png)

在一阶逻辑中我们可以使用下列的两种记法表示 **函数**:

1. 对于定义域有限的函数, 可以使用集合表示法.如:

    $$\{(1,2), (2,1)\}$$

    就表示了一个定义在 $\{1, 2\}$ 上, 将 $1$ 映射到 $2$, $2$ 映射到 $1$ 的函数.

2. 对于无法列举定义域中所有元素的函数, 可以使用 $\lambda-$ 抽象表示法: 使用

    $$\lambda x. (\text{expression using} ~x)$$

    表示以 $x$ 为输入, 以某个表达式为输出的匿名函数.

### 1.2 一阶逻辑的语义

我们将在直观简述一阶逻辑的语义后给出正规的形式化定义.

首先地, **项** 一般用于表示某个 **物体** (`Object`), 并且项无需是唯一的.

**公式** 用来表示某个声明具有真值, 它既可以是对某个既定现实的陈述, 也可以表示某个未经证实的, 将要被检验的声明. 

**符号** 用于在公式中表示对人而言具有特殊意义的事实, 事件, 状态等含义. 

需要注意, 逻辑系统不具备解读和分辨符号的能力, 并且往往一个公式的意义或它的真伪性完全取决于我们如何解读该公式中包含的符号. 

对应地, 若某个公式是真的, 则无论我们如何解读该公式中的符号, 都不会影响它的真伪性.

下面考虑一阶逻辑语义的形式化定义:

**定义 1.2.1** (基, 受限变量, 自由变量和句子)
> 1. 若某个公式不含变量, 则称其为 **基** (`Ground`).
> 2. 公式 $f$ 中任何不受任一种量词约束的变量均为 **自由变量**, 否则为 **受限变量**.
> 3. 不包含 **任何自由变量** 的公式成为 **句子** (`Sentence`).

下面给出一些记法: 

若公式 $\phi$ 中含自由变量 $X$ ,则可记为 $\phi[X]$; 若将 $X$ 替换为 $V$, 则可使用记号 $\phi[V]$.

我们下面考虑对公式的 **解释** (`Interpretation`): 

**定义 1.2.2** (解释, `Interpretation`)
> **解释** 使我们可以为任何句子赋予对应的 **真值** (`Truth Value`):
> 
> 形式上 **解释** 可被表示为下列的元组
> 
> $$\langle \mathcal{D}, \mathcal{I}\rangle$$
> 
> 其中 $\mathcal{I}$ 为基于非空域 $\mathcal{D}$ 上的解释. 一般地, 在表述解释时我们都会略去其作用域 $\mathcal{D}$.
> 
> 解释 $\mathcal{I}$ 本质上是一个映射. 它:
> 1. 将任何常数符号映射到 $\mathcal{D}$ 中的某个元素
> 2. 将任何元数为 $n$ 的函数符号映射到函数 
> 
>       $$D^{n} \rightarrow D$$
> 
> 3. 将任何谓词符号映射到某个真值
> 4. 将任何元数为 $n$ 的谓词符号映射到函数
> 
>       $$D^{n} \rightarrow \mathbb{B}$$
>

在对 **不为常数** 的 **基** 进行解释时, 我们可以递归地利用下列性质:

$$\mathcal{I}(f(t_1, \cdots, t_n)) = \mathcal{I}(f)(\mathcal{I}(t_1), \cdots, \mathcal{I}(t_n)).$$

这一性质同样可以作用在 **非谓词的原子** (`Non-Propositional Atoms`) 上:


$$\mathcal{I}(t_1 = t_2) = \mathcal{I}(t_1) = \mathcal{I}(t_2)$$

需要注意上式中三个等号的含义均 **各不相同**:

左侧等号表示两个项 $t_1, t_2$ 在语法上相同, 中间的等号表示左右两侧的公式在定义上相同, 而右侧的第三个等号表示的含义是域元素的相等性 (注意 **解释的本质** )

$$\mathcal{I}(p(t_1, \cdots, t_n)) = \mathcal{I}(p)(\mathcal{I}(t_1), \cdots, \mathcal{I}(t_n)).$$

我们进一步考虑对 **等价性** (`Equality`) 的解释:

![20220221232546](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221232546.png)


随后考虑对公式 (`Formula`) 的解释:

![20220221232734](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221232734.png)

然后给出对模型 (`Model`) 的解释:

![20220221232900](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221232900.png)

需要注意, 在对公式中的变量重命名 (`Rename`) 时, 我们需要在重命名受限变量时注意 **一致性**. 在后文中, 我们一般假定所接触到的公式都是经过规范化 (`Rectified`) 的.

最后给出对 **可满足性, 一致性和重言性** 的定义:

**定义1.2.3** (可满足性, 一致性, 重言性)
> 1. 若存在某个解释使某个公式在其解释下为真, 则称该解释是该公式的一个 **模型**.
> 2. 某个解释 **满足** 某个公式, 若它满足该公式的 **全称封闭式** (`Universal Closure`, 用全称量词约束给定公式中全体自由变量所得到的封闭公式).
> 3. 称某个公式为 **可满足的** 或 **一致的**, 若该公式至少有一个模型.
> 4. 称某个公式是 **重言** 的, 若它的任何解释都满足它. 
> 5. 对应地, 若某个公式不存在任何模型, 则称其为 **不可满足** 或 **不一致** 的. 

显然, 可以得出下列结论:

记 $\Gamma$ 为一系列公式的合取 (`Cunjunction`), $\phi$ 为一个句子 (`Sentence`), 则: 

1. $\phi$ 的模型恰好是无法作为 $\neg \phi$ 的模型的那些解释.

2. 若 $\Gamma$ 是不一致的, 则必有 $\Gamma \vDash \text{false}$.

3. $\Gamma \vDash \text{false}$, 当且仅当 $\Gamma \cup \{\neg \phi\} \vDash \text{false}$.

4. 若 $\Gamma$ 不一致, 则它没有模型; 由于 $\text{false}$ 同样没有模型, 因此 $\Gamma$ 的任何模型都是 $\text{false}$ 的模型.

我们下一步将讨论对象推广到 **表示为合取范式** 的 **一系列公式** 上. 由此, 我们可以讨论 **知识库的一致性**. 进一步地, 为了检验某个公式在给定知识库的所有解释下的含义均为真, 我们需要引入 **蕴含** 的概念:

**定义 1.2.4** (蕴含, `Entailment`)
> 称公式 $\phi$ 由一系列公式组成的集合 $\Gamma$ 所 **蕴含**, 若 $\Gamma$ 的任何模型都是 $\phi$ 的某个模型, 记为
>
> $$\Gamma \vDash \phi$$
> 
> 该性质同样可称为: “$\phi$ 是 $\Gamma$ 的一个结果 (`Consequence`)”.


我们以对 “处理查询” 的讨论结束本节. **问题** 或 **查询** 可被视为 **某个受存在量词约束的合取式** 或某个 **需要被实例化的, 包含自由变量的公式**. 

我们采用后者, 并在此基础上进一步假定 **任何作为查询的, 含有自由变量公式** 都是 **被存在量词所闭合的**, 如:

$$\phi [X] \implies \exists X. \phi[X].$$

由此, 给定知识库 $\Gamma$ 和查询语句 $\exists X. \phi[X].$, 我们的目标是找到替换 $\sigma$, 使

$$\Gamma \vDash \phi[X] \sigma.$$

为了达成这一目标, 我们需要将问题转换为

$$\Gamma \vDash \exists X. (\text{ans}(X) \wedge \phi[X]) \wedge \exists X. \neg \text{ans}(X).$$

并引入一个全新的谓词 `ans`.


## 2. 联合与前向推理法



## 3. 反向推理和语义归结



REFERENCE:

[First-Order Logic 1 Syntax of First-Order Logic](https://www.cs.ox.ac.uk/people/james.worrell/lecture9-2015.pdf)

[人工智能 一种现代方法 第8章 一阶逻辑 - CSDN](https://blog.csdn.net/yyl424525/article/details/95309168)

[命题逻辑和一阶逻辑](https://www.jianshu.com/p/4fbcd56002b4)