---
layout:     post
title:      基于知识组织的人工智能
subtitle:   Introduction to Knowledge-based AI + Chapter 1
date:       2022-02-11
author:     R1NG
header-img: img/post-bg-prolog.jpg
description: Logic, once again...
catalog: true
tags:
    - 课程笔记
---

# 绪论

本质上我们将在本课程中所接触的内容是对智能体 (`Intelligent System`) 表示和推理其所在世界中的知识和信息的研究. 在本课程中, 我们将接触和学习 **知识表示** (`Knowledge Representation`) 的核心概念和数种自动推理 (`Automated Reasoning`) 方法. 

课程内容基本分为四个板块:

## 1. 一阶逻辑 (`First-Order Logic`) 和自动推理

* 一阶逻辑的 **语法和语义**
* 一节逻辑公式和子句形式 (`Clausal Form`) 的转换
* 有序语义归结 (`Ordered Resolution`)
* 基于饱和原则的证明搜索
* 模型 (`Model`) 构造

## 2. `Prolog`
* `Prolog` 语法和证明搜索执行规则
* `Prolog` 中基于 `Horn` 子句的反向推理法的应用
* 基于 `Prolog` 的定理证明

## 3. 知识表示
* 本体论工程 (`Ontological Engineering`)
* 对类型和物体的表示
* 对事件的表示
* 基于分类 (`Categories`) 的推理系统
* 语义网络 (`Semantic Networks`)
* 描述逻辑
* 基于默认信息 (`Default Information`) 的推理

## 4. 归纳推理与回溯推理
* 基于逻辑问题的学习 (`Learning as a Logical Problem`)
* 基于知识的学习 (`Learning with Knowledge`)
* 归纳逻辑程序设计
* 解释和诊断 (`Explaination and Diagnosis`)
* 基于解释的学习 (`Explaination-based Learning`)

我们下面开始对课程内容的介绍.

<br>

# 一阶逻辑 (`First-Order Logic`) 和自动推理

## 1. 基于一阶逻辑的知识表示

**定义 1.1** (知识表示)
> 称 **精确** (`Precise`) 和 **无歧义** (`Unambiguous`) 的, 表示世界中的已知信息的方式为 **知识表示**. 

**定义 1.2** (自动推理)
> 自动推理一般被定义为 **自动地** 基于某些已知事实推导出与之相关的声明 (`Statement`) 的行为.

在一阶逻辑中, 推理是基于预先定义好的 **推断规则** (`Inference Rules`) 执行的. 

推理同样依赖于对现实世界中知识的表示以及所具有的知识的多寡. 对于一阶逻辑, 我们将知识库 (`Knowledge Base`) 视为对现实世界的 **符号化抽象** (`Symbolic Abstraction`): 在知识库中, 称我们所关心的, 某个形式化的, 现实世界的子集为 **域** (`Domain`), 而用于表示域中元素的符号为 **标识** (`Signature`). 

### 1.1 一阶逻辑的语法

**定义 1.1.1** (标识, `Signature`)
> 称某个一阶公式的 **标识**
> 
> $$\Sigma = \langle \mathcal{F}, \mathcal{P}, \text{arr}\rangle$$
> 
> 由两个不相交的, 分别包含 **函数符号** 与 **谓词符号** 的集合 $\mathcal{F}, \mathcal{P}$ 以及 **表明每一个符号的元数** (`Arity`) 的映射 
> 
> $$\text{arr}: \mathcal{F} \cup \mathcal{P} \rightarrow \mathbb{N}_0$$
>
> 组成. 

**定义 1.1.2** (项, `Term`)
> 在一阶逻辑中, 下列元素均称为 **项**:<br>
> 1. 任何 **变量** 均为项.
> 2. 任何 **常量** (即元数为 $0$ 的函数符号) 均为项.
> 3. 若函数符号 $f$ 的元数为 $k$, $k > 0$ 且 $t_i, i\in [k]$ 均为项, 则 
>       $$f(t_1, \cdots, t_k)$$
>       
>       为项.
> 

**定义 1.1.3** (原子, `Atom`)
> 在一阶逻辑中, 下列元素均称为 **原子**:<br>
> 1. 任何 **谓词** (即元数为 $0$ 的谓词符号) 均为原子.
> 2. 若 $t_1, t_2$ 均为项, 则 $t_1 = t_2$ 为原子.
> 3. 若谓词符号 $p$ 的元数为 $k$, $k > 0$ 且 $t_i, i\in [k]$ 均为项, 则 
>       $$p(t_1, \cdots, t_k)$$
>       
>       为原子.
>

**定义 1.1.4** (公式 `Formula`)
> 在一阶逻辑中, 我们使用如下的规则递归定义 **公式**:<br>
> 1. 任何原子均为公式.
> 2. 布尔值 `True` 为公式.
> 3. 若 $\phi_1, \phi_2$ 均为公式, 则 
>       $$\neg \phi_1, \phi_1 \wedge \phi_2, \forall x. \phi_1$$
>       
>       为公式, 其中 $x$ 为变量.
> 

进一步地, 我们可以定义:

1. $\text{False} \equiv \neg\text{True}$
2. $\phi_1 \vee \phi_2 \equiv \neg (\phi_1 \wedge \phi_2)$ 
3. $\phi_1 \rightarrow \phi_2 \equiv \neg \phi_1 \vee \phi_2$
4. $\phi_1 \leftrightarrow \phi_2 \equiv ((\phi_1 \rightarrow \phi_2) \wedge (\phi_2 \rightarrow \phi_1))$
5. $\exists x. \phi \equiv \neg(\forall x. \neg \phi)$.

我们可以不甚严谨地理解上述的逻辑符号或量词:

![20220221205550](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221205550.png)

同时考虑如下的例子:

![20220221210809](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221210809.png)

![20220221210156](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221210156.png)

### 1.2 一阶逻辑的语义

我们将在直观简述一阶逻辑的语义后给出正规的形式化定义.

首先地, **项** 一般用于表示某个 **物体** (`Object`), 并且项无需是唯一的.

**公式** 用来表示某个声明具有真值, 它既可以是对某个既定现实的陈述, 也可以表示某个未经证实的, 将要被检验的声明. 

**符号** 用于在公式中表示对人而言具有特殊意义的事实, 事件, 状态等含义. 

需要注意, 逻辑系统不具备解读和分辨符号的能力, 并且往往一个公式的意义或它的真伪性完全取决于我们如何解读该公式中包含的符号. 

对应地, 若某个公式是真的, 则无论我们如何解读该公式中的符号, 都不会影响它的真伪性.

下面考虑一阶逻辑语义的形式化定义:

**定义 1.2.1** (基, 受限变量, 自由变量和句子)
> 1. 若某个公式不含变量, 则称其为 **基** (`Ground`).
> 2. 公式 $f$ 中任何不受任一种量词约束的变量均为 **自由变量**, 否则为 **受限变量**.
> 3. 不包含 **任何自由变量** 的公式成为 **句子** (`Sentence`).

下面给出一些记法: 

若公式 $\phi$ 中含自由变量 $X$ ,则可记为 $\phi[X]$; 若将 $X$ 替换为 $V$, 则可使用记号 $\phi[V]$.

我们下面考虑对公式的 **解释** (`Interpretation`): 

**定义 1.2.2** (解释, `Interpretation`)
> **解释** 使我们可以为任何句子赋予对应的 **真值** (`Truth Value`):
> 
> 形式上 **解释** 可被表示为下列的元组
> 
> $$\langle \mathcal{D}, \mathcal{I}\rangle$$
> 
> 其中 $\mathcal{I}$ 为基于非空域 $\mathcal{D}$ 上的解释. 一般地, 在表述解释时我们都会略去其作用域 $\mathcal{D}$.
> 
> 解释 $\mathcal{I}$ 本质上是一个映射. 它:
> 1. 将任何常数符号映射到 $\mathcal{D}$ 中的某个元素
> 2. 将任何元数为 $n$ 的函数符号映射到函数 
> 
>       $$D^{n} \rightarrow D$$
> 
> 3. 将任何谓词符号映射到某个真值
> 4. 将任何元数为 $n$ 的谓词符号映射到函数
> 
>       $$D^{n} \rightarrow \mathbb{B}$$
>

在对 **不为常数** 的 **基** 进行解释时, 我们可以递归地利用下列性质:

$$\mathcal{I}(f(t_1, \cdots, t_n)) = \mathcal{I}(f)(\mathcal{I}(t_1), \cdots, \mathcal{I}(t_n)).$$

这一性质同样可以作用在 **非谓词的原子** (`Non-Propositional Atoms`) 上:


$$\mathcal{I}(t_1 = t_2) = \mathcal{I}(t_1) = \mathcal{I}(t_2)$$

需要注意上式中三个等号的含义均 **各不相同**:

左侧等号表示两个项 $t_1, t_2$ 在语法上相同, 中间的等号表示左右两侧的公式在定义上相同, 而右侧的第三个等号表示的含义是域元素的相等性 (注意 **解释的本质** )

$$\mathcal{I}(p(t_1, \cdots, t_n)) = \mathcal{I}(p)(\mathcal{I}(t_1), \cdots, \mathcal{I}(t_n)).$$

我们进一步考虑对 **等价性** (`Equality`) 的解释:

![20220221232546](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221232546.png)


随后考虑对公式 (`Formula`) 的解释:

![20220221232734](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221232734.png)

我们最后给出对模型 (`Model`) 的解释:

![20220221232900](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220221232900.png)

## 2. 联合与前向推理法


## 3. 反向推理和语义归结