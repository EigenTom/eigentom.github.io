---
layout:     post
title:      并行计算和系统资源分配
subtitle:   Introduction to Solidity
date:       2022-03-15
author:     R1NG
header-img: img/post-bg-concurrency.jpg
description: 本章介绍并行计算的基本概念并引入两种程序设计语言：契约语言 Solidity 和 Rust, 讨论现代程序设计语言如何实现资源管理.
catalog: true
tags:
    - 课程笔记
    - 并行计算
---

# 进阶课题

本章将简介 **程序语言与程序范式** 课程的最后一部分: 进阶课题. 我们将在这部分中首先介绍用于构造 **智能契约 (程序被部署在网络上自动运行并通过信息传递互相交互)** 的 `Solidity`, 并以此为契机引入一系列关于 **并行编程** (`Concurrent Programming`) 的基本概念; 随后介绍一种较新的程序设计语言: 和 `C/C++` 同样接近底层性能极高但内存安全的 `Rust`.

通过本章的学习, 我们将更深入地理解: 在现代程序设计语言中, 对资源的管理和利用愈发占据重要的位置. 

![20220504213955](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504213955.png)

下面首先讨论智能契约语言: `Solidity`. 

## 1. `Solidity`

`Solidity` 是一门主要用于编写智能契约的程序设计语言. 我们下面对 “智能契约” 给出定义: 

智能契约满足下列的四条性质:
1. 被部署在 **网络** 上. 
2. 任何智能契约都具有 **网络地址**, 并可以通过网络地址被访问. 
3. 智能契约具有 **不同的状态**, 而且对于各种不同的状态都有对应的行为定义. 
4. 智能契约通过在网络上 **发送和接受信息** 和外界进行信息交互.

而另外一个显著特征是: 智能契约在被部署后, 就会 **自动地** 运行在计算机上. 

### `Solidity` 介绍

在 `Solidity` 中, 和面向对象程序设计语言中的 **类** 相对应的是 **契约** (`Contract`), 本质上它所描述的是一个将会被部署到网络上自动运行的对象. 下面是 `Solidity` 中契约的基本结构:

![20220504214452](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504214452.png)

可以看出, 和类一样, 契约也可以具有大量成员变量 (`Member Variables`), 而且也有自己的 **构造器**, 而契约和类之间行为差异的根源是, 契约具有 **接收和处理外部信息** 的功能. 

我们应该近似地将契约中的每个方法和构造器都视为 `Message Handler`, 来自外部的信息可能会要求调用它们中的任一个. 

和其他方法不同的是, 契约中的构造器只有在 **这个契约的对象被创建** 时才会被 **这个契约的拥有者 (`Owner`)** 调用 **一次**. 

下面尝试在一个在线 `IDE`: `Remix` 中编译和运行上图中的例子. 

![20220504215041](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504215041.png)

注意 `view` 标记表明, 被标记的方法 `getCount()` 被调用时 **不会修改契约的当前状态**, 而 `returns (uint)` 关键字表明该方法被调用时会返回一个类型为无符号整型的数据. 

### 身份识别和不可分行为

契约语言需要具有 **明确地表明下列三个对象的能力** :

1. 信息发送者的身份.
2. 不可再分的行为/操作/指令.
3. 运行契约的成本和代价.

首先, 由于智能契约需要具备在网络中通过发送和接受信息从而实现交互和信息传递的功能, 任何信息都需要标记它的发送者 (`Message Sender`) 是谁, 这显然是和常规的程序语言中调用函数的过程完全不一致的.

其次, 由于我们同时需要考虑智能契约并行运行的可能性, 我们需要明确什么样的指令才能被视为不可再分 (**不可以被任何同时在网络上运行的进程干扰和中断的指令**), 需要以原子的形态参与并行运行时的任务调度.

最后, 由于智能契约运行在他人的计算机硬件上, 对系统资源 **不具有控制权**, 因此我们还需要能够具有明确任何契约运行产生的成本和代价的能力. 从而使我们能够为了让契约运行恰好支付相应的代价以换取相应的计算资源. 

#### 信息发送者身份的确定问题

回顾面向对象程序设计语言, 它们一般包含形如 `this`, `self` 一类的, 用于指示在某个类内部的类变量或类方法的关键字. 在 `Solidity` 中, 同样包括 `this` 关键字. 

但它的使用场景略有不同. 首先, 它可被用于获取 **当前契约的余额**: `address(this).balance`, 可以进一步用于建模/构造某种意义上的 “在线交易”.

同时, `Solidity` 具有 `msg` 关键字. 它的其中一个作用是允许我们获取信息发送者的地址: `msg.sender`.

考虑下面的例子:

![20220504220608](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504220608.png)

注意在 `increment()` 方法中我们对 **要求调用这个方法的信息的发送者身份** 提出了限制: **只有在要求调用本方法的信息的发送者是 `owner`** (这通过检查地址实现) 时, 函数才会被执行, 否则 **一旦发现要求不满足, 该方法此前执行的所有操作都会被 `revert`**.

换言之, 此处的 `require(msg.sender = owner)` 实际上等同于:

~~~c++
if (msg.sender != owner){
    revert();
}
~~~

而不同之处在于, 即使 `require(...)` 在上图的例子中被放在了 `14` 行后面, 只要条件不满足它也能 `revert` 此前该方法执行过的所有操作. 


#### 表示契约运行的成本问题

在上一小节中介绍了 `msg` 关键字, 它表示 **传入契约的信息**. 除了使用 `msg.sender` 获取信息发送者的身份外, 它还可被用于表示运行成本:

1. `msg.gas` 表示了这条信息所携带的, 关于处理它所需代价的补偿. (`payment for the cost of processing the message`)
   
   在 `Solidity` 中, 这样的代价被称为 `gas`, 单位为 `wei`.  (实际上 `wei` 是很小的单位)
   
    `Solidity` 中的 **任何一条指令** 都有对应的 `gas` 数额: 执行任何指令都会消耗相应数量的 `gas`. 

2. `msg.value` 表示了这条信息所携带的, 用于支付契约所将提供的服务的费用. (`payment for the service`)

考虑下面的例子:

![20220504221933](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504221933.png)

首先对于方法 `increment()`, 我们定义任何调用它的信息都需要携带不少于 `7 wei` 的支付费用. 

其次, 对于方法 `waste()`, 它被刻意设计为执行大量指令以高效地浪费 `gas`. 如果我们限制 `gas limit`, 则它会因为资源不足而无法执行. 

### 信息传递和并行执行相关的其他问题

本节我们讨论在 `Solidity` 中如何向其他契约发送信息, 并进一步讨论因为契约的信息交互所可能产生的两种 `concurrency problem`.

#### 信息传递: 向其他契约发送信息

在 `Solidity` 中, 向其他契约发送信息的方式类似于面向对象程序设计语言中调用对象方法的方式: 

![20220504222856](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504222856.png)

而在上一节中可知, 在一些情况下还需要在发送信息时附上对目标契约服务的支付费用. 

![20220504222955](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504222955.png)

#### 数据竞争问题 (`Data-Race`)

我们下面简要讨论数据竞争问题. 考虑下面的例子: 

![20220504223100](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223100.png)

在上图所示的例子中, 左右两个线程 **同时执行**, 并 **同时具有** 对缓冲数组 `buffer` 的访问权限. 

右侧线程将会持续从外界接受输入并存到 `buffer[indexi]` 中, 然后更新 `indexi` 确保它在 $0-9$ 内循环. 

左侧线程则会持续先用同样的方式循环更新数组指针 `indexo`, 然后 输出 `buffer[indexo]` 存储的内容到外界.

上述线程的问题是: **二者的运行速度可能不同**. 如果右侧线程运行速度极快, 则它会先于左侧进程完成对缓冲数组 `buffer` 的信息更新, **然后会覆写掉此前保存, 需要被左侧线程输出, 但还没有被输出的信息**, 导致信息丢失.

![20220504223700](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223700.png)

上面的例子就是典型的 **数据竞争问题**. 

我们下面给出数据竞争问题的定义: 

![20220504223736](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223736.png)

注意在上面三点特征中, 导致问题发生的主要特征是: 不存在任何规范化信息读写顺序的机制. 如果信息读写可以被某套规则严格控制, 即使某个情况满足上面的前两点也不会发生数据竞争问题. 

数据竞争问题在操作系统寄存器读写, 大规模并行数据库内容读写等场景中极为常见, 一般的程序语言都通过引入各种资源锁缓解或避免问题. 

而 `Solidity` 的解决方法简单粗暴: 它彻底放弃并行性, 不允许任何契约同时执行....

![20220504223959](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504223959.png)

#### 重入问题 (`Re-entrancy`)

虽然在 `Solidity` 中数据竞争问题不存在, 但由于智能契约语言中不可避免会出现 `remote function call`, 因此还是可能出现 **重入问题**:

![20220504224144](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504224144.png)

重入问题发生在两个函数中各自存在 **相互调用** 的关系时, 基于双方函数中的逻辑以及对变量进行的操作, 可能出现包括数据不安全在内的问题. 



### 复杂并行问题

下面我们暂时超出 `Solidity` 的范畴, 从一般的角度考虑复杂的并行问题. 

在本节中, “并行” 的定义是广义的: 指 **大量计算** 在 **同时执行** 的现象. 

#### 进程和线程

举例而言, 即使在 `Solidity` 中, 也可能出现 网络中 **大量契约被同时部署** 的现象. 

但与此同时, `Solidity` 使用名为 `Consensus Algorithm` (共识算法) 的算法确保在任何时刻整个网络上只会有一个函数运行, 并且它还使用了一些加密技术确保任何实体都不可能违背这个顺序. 

![20220504225202](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504225202.png)

但对于需要并行的其他场景而言, `Solidity` 解决并行导致的问题的方法是不适用的. 我们下面介绍一些其他的解决方案: **进程 (`Process`) 思想**, **线程 (`Thread`) 思想** 或者让编译器自行优化.

![20220504225649](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504225649.png)

注意: 

1. 进程相比线程独立性更强, 有属于自身的, 不可被外界观测和控制的状态, 天生适合原子化 (不可再分的) 操作的实现.
2. 线程实现存在潜在的数据竞争问题, 它们通过修改和读取表示状态的公共数据 (`Public States`) 确定数据是否可被安全读写, 避免数据竞争.
3. 让编译器自行优化实际上是非常复杂和困难的, 而且一般编译器自动优化的结果本质上就是进程思想或线程思想的实现.

#### 信息传递问题

下面考虑和 `Solidity` 共通之处更多的 **进程思想** 中可能出现的问题.

`Solidity` 通过强行确定信息的顺序让它们具有原子化的表现, 但标准的进程思想不同, `Solidity` 不允许任何意义上的并行执行. 而这原本是状态私有不可被外界篡改的进程最适合执行的事.  

而 `Solidity` 选择这种实现的原因是它可以从底层确保状态安全, 通过禁止并行执行, 就彻底消除了进程间状态不一致的可能性. 

而为了确保信息通信的一致性, 同样有下列三种解决方案:

1. `Remote Procedure Call` 远程程序调用:
   和调用方法类似, 信息发送者发送信息, 并在**收到** 接收者 **完成信息处理之后发送回复后** 继续执行程序.
2. `Synchronous Messages` 同步信息: 
   信息发送者发送信息, 并在收到接收者 **表明收到信息** 的回执后就继续执行程序, 不关心接收者是否完成了信息处理. 
3. `Asynchronous Messages` 异步信息:
   信息发送者发送信息, 然后直接继续执行程序, 既不关心信息是否送达, 也不关心信息是否被处理完成.

![20220504230704](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504230704.png)

#### 共享内存问题

下面考虑线程思想中可能出现的问题. 

由于线程思想中, 所有线程共用内存, 因此最直接明显的潜在问题就是数据竞争问题. 

而解决数据竞争问题的实质是: 如何确保对信息访问的 **互斥**, 即如何避免对同一块内存的 **同时访问**?

1. 将对数据的读写操作 **原子化**, 从而根除数据读写被中断导致数据污染或出现数据竞争的可能性. 这要求程序员使用特定的算法, 如 `Peterson's Algorithm`, 确保数据读写的互斥性, 主要问题是低效, 而且不能确保对互斥的实现适用于所有硬件平台.

2. 提供底层的, 原子化的, 对数据的 `test_and_set` 操作
   
   其实质是实现原子化的 `test_and_set` 方法, 实现在调用它时用 **原子化的操作** 将变量值修改为新的, 同时返回旧的值. 

   由于实现了 `test_and_set` 方法后就可以使用比 `Peterson's Algorithm` 简单的多的方法实现数据读写的原子化, 因此用这种方式可以一定程度上的提高效率. 

3. 直接提供更高阶的同步方法, 如资源锁, 信号量等.

4. 直接为程序或函数提供同步方法: 直接定义一段代码或某个方法需要被同步 (不可被干扰), 被这样定义的程序运行时禁止其他任何并行操作.

![20220504231551](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504231551.png)

#### 高阶的并行问题

需要注意, 互斥 (`Mutual Exclusion`) 并不能防止所有的并行运行问题. 虽然它可以预防 **特定的底层并行问题**, 但并不能预防其他的 **高阶并行问题** 的发生, 如 **死锁/活锁**. 

(Dead lock: prevent anything to happen; Live lock: prevent useful things to happen but allow infinite number of useless things to happen)

![20220504232747](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504232747.png)

如下面的例子中所示, 使用 `Solidity` 建模的哲学家问题就是一个死锁问题.

~~~c++
pragma solidity >=0.4.22 <0.7.0;

contract philosopher {

    enum State{hungry, gotLeft, gotRight, happy}

    chopstick left;
    chopstick right;
    State state;


    constructor(chopstick nleft, chopstick nright) public{
        left = nleft;
        right = nright;
        state = State.hungry;
    }

    function getLeft() public{
        require(state == State.hungry);
        left.pickUp();
        state = State.gotLeft;
    }

    function getRight() public{
        require(state == State.gotLeft);
        right.pickUp();
        state = State.gotRight;
    }

    function eatNoodles() public {
        require(state == State.gotRight);
        state = State.happy;

    }

    function think() public {
        require(state == State.happy);
        left.putDown();
        right.putDown();
        state = State.hungry;
    }

}

contract chopstick {

    philosopher holder;
    bool up = false;

    function pickUp() public{
        require(up == false);
        holder = philosopher(msg.sender);
        up = true;
    }

    function putDown() public{
        require(up = true && holder == philosopher(msg.sender));
        up = false;
    }

}

~~~

举例而言, 创建三个 `philosopher` 契约, 每人均进行 `pick left-chopstick` 操作, 然后任何 `philosopher` 都无法再执行 `pick right-chopstick` 操作, 因为任何 `philosopher` 的右筷子总是另一个人的左筷子, 死锁形成. 在这一情况下, 任何操作都无法被执行.

在实际情况中, 我们除了考虑状态的 **安全性质** (`Safety Property`) 外, 同时要考虑 **生命性质** (`Liveness Properties`): 除了避免坏事发生之外, 我们还要确保好事终将发生.

![20220504233355](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220504233355.png)

## 2. `Rust`

### `Rust` 中的内存管理

#### 所有权

#### 所有权借出

#### 基本数据类型和数据可变性 (`Mutability`)

### `Rust` 中的生命周期

