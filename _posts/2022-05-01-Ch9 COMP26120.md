---
layout:     post
title:      数据结构与算法： 可计算性问题
subtitle:   (In)Tractability Problem
date:       2022-05-1
author:     R1NG
header-img: img/post-bg-algs4.jpg
description: 本章介绍可计算性问题.
catalog: true
tags:
    - 课程笔记
    - 数据结构与算法
---

# 可计算性问题

在本章中, 我们将对 **可计算性问题** 进行介绍. 我们将依序介绍三种 **问题的复杂度类**: 可使用确定性算法在 **多项式时间内** 被求解的问题类 `P` (`Polynomial Time`), **使用确定性算法在多项式时间内无法求解但可验证** 的问题类 `NP` (`Non-Polynomial Time`), **比 `NP` 问题更难求解且无法确定能否在多项式时间内被验证** 的问题类 `NP-Hard`, 以及 **既是 `NP` 问题又是 `NP-Hard` 问题** 的问题类 `NP-Complete`.、

我们还将进一步介绍可用来验证给定问题属于哪个复杂度类的基本知识和技术, 并将通过一些例子说明应用. 

## `P`, `NP` 和其他非确定机

### 直观定义

我们首先分别说明 `P`, `NP`, `NP-Hard` 的定义.

首先明确, 这些定义都是对 **问题的难易程度** 的描述. 在这里, 我们对问题的 “难易程度” 所下的定义就是: 解决这一问题所需要的 **时间复杂度** 是什么. 显然, 对于计算能力相同的硬件而言, 需要更短计算时间就可解决的问题自然相对简单; 而对人类而言, 只有在我们的认知内可接受的时间范围内能够将问题解决的算法才具有实际意义. 

因此, 我们根据 **时间复杂度** 可将计算问题粗略的分为三类:

1. `Class P`: 任何可在 **多项式时间内** 由 **确定性算法** 得出结论的问题都属于 `P` 类问题.
2. `Class NP`: 任何 **需要使用非确定性算法** 才能在多项式时间内求解, **或** 可在 **多项式时间内检验解答是否正确** 的问题属于 `NP` 问题. 
3. `Class NP-Hard`: **难度至少和所有的 `NP` 问题一样难** 的问题属于 `NP-Hard` 问题.
4. `Class NP-Complete`: **既属于 `NP` 类, 又属于 `NP-Hard` 类** 的问题为 `NP-Hard` 问题. 

![20220521171150](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521171150.png)

在本课程中, 我们认为 `P`, `NP`, `NP-Hard` 问题之间是 **包含关系**:

![20220521171342](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521171342.png)

最后我们引入 **问题简化** (`Problem Reduction`) 的定义:

考虑任意的计算问题 $A, B$, 若 **所有 $A$ 问题的实例都可通过某个变换 $f_{I_A}$ 映射/转换为问题 $B$ 的某个实例**, 则称 $A$ 可被简化为 $B$.

![20220521171517](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521171517.png)

### `Class P` 问题的形式化定义和对问题的编码

我们首先说明如何对问题进行 **统一的二进制编码表示** (`Encoding`). 然后在此基础上给出对 `Class P` 类问题的 **形式化定义**.

在研究问题的可计算性时, 我们 **只关心决策问题** 而非优化问题, 至少不是 **直接关注优化问题, 而是关注它的决策问题形式**. 

广义上说, 决策问题就是一个函数, 它接收一些输入, 返回一个 **是或否** ($0$ 或 $1$) 的结果. 

并且, 我们可以从一个著名的优化问题: 旅行商问题的例子观察到:

1. 一般来说优化问题都可以 **等价地简化为** 某个决策问题.
2. 解决决策问题一般不会比解决优化问题更难.

因此, 在考虑优化问题的困难程度和可计算性时, 我们实际考察的是 **它的决策问题形式** 的困难程度与可计算性.

![20220521180622](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521180622.png)

#### 问题的统一编码

下面, 为了 **横向比较** 所有 **形式, 输入, 输出都不同** 的决策问题, 我们需要首先 **将它们转化为相同的形式**, 这是通过 **对问题的编码** (`Encoding`) 实现的:

![20220521180836](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521180836.png)

我们 **假设存在某种通用方法**, 可以将 **不同的数据结构统一地在多项式时间内编码为二进制序列**, 由此对于所有的决策问题, 它们的输入形式现在就是相同的.

因此, 另一种形式上对于决策问题的不同定义是: 

**所有以一系列二进制数串作为输入, 输出 $1$ 或 $0$ 的函数.**

而在经过转换前, 表示问题真实语义 (如下面图中对问题 `PATH` 的描述) 的描述被称为问题的 **语言** (`Language`), 它表示被形式化后的问题的真实含义.

![20220521181116](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521181116.png)

需要注意的是, 对数字 $n$ 的二进制编码长度仅为 $k = \log_{2}(n)$. 因此, 我们需要注意, 某些问题的时间复杂度可能 **关于输入的值的增长为线性的**, 但 **关于输入长度的增长则为指数级的** .

我们称满足这种特性的问题为 **伪多项式时间的问题** (`Pseudo-Polynomial`), 比如 **最简单的素数检测算法**. (回顾上一章介绍的内容)

![20220521181514](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521181514.png)

#### `Class P` 问题的形式化定义

在介绍了对决策问题的统一化编码方法后, 我们下面给出对 `Class P` 问题的形式化定义. 

首先给出 “可被确定” 的定义: 

1. 记算法 $A$ **接纳** 某个二进制串 $x$, **当且仅当满足** $A(x) = 1$.
2. 然后, 对任何 **被问题的语言 $L$ 描述的二进制串 $x$**, 若所有这样的 $x$ 都被 $A$ **接纳**, 也就是 
    
    $$A(x)=1 ~~ \text{for} ~ \forall x \in L$$

    且

    $$A(x)=0 ~~ \text{for} ~ \forall x \notin L$$

    则称 **问题的语言 $L$ 被算法 $A$ 所确定**.

然后给出 “问题的语言 $L$ 能够在多项式时间内被确定” 的 **形式化** 定义:

如果存在某个 **常数 $k$**, 对问题的语言 $L$ 中所描述的 **任何** 二进制串 $x$, 算法 $A$ 确定 $x$ 所需要消耗时间的复杂度为 $O(n^k)$, 则称 **该问题的语言 $L$ 能够被算法 $A$ 在多项式时间内确定**.

最后, `Class P` 就是 **全体能够被某个算法在多项式时间内确定的问题语言 $L$ 的集合**.

![20220521182511](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521182511.png)

#### `Class NP` 问题的形式化定义与 `Certificate` 的定义

下面对 `Class NP` 给出形式化定义, 并介绍能够表明问题是否位于 `Class NP` 中的标志: `Certificate` 的定义.

首先从一个简单的 `NP` 问题: **图的顶点包含问题** (`Vertex Cover Problem`) 开始.

**图的顶点包含问题** 要求检测我们能否找到一个不大于 $k$ 的, 而且 **包含了图中所有在任何一条边内顶点** 的集合 $C$.

显然, 给定这样的一个集合 $C$, 我们可通过遍历图的边集中每一条边的方式判断, 对于每一条边而言, 是否至少一个顶点位于 $C$ 中. 因此, **判断一个候选答案是否为问题的解** 的时间复杂度是 $O(kn)$.

但要从零开始 **生成满足条件的一个解 $C$**, 在最坏情况下我们需要检查图的顶点集 $V$ 的每一个子集, 因此要检查 $2^n$ 次.

显然这是一个典型的 `NP` 问题: 无法使用确定性算法在多项式时间内求解, 但是可以在多项式时间内验证候选答案是否为解.

![20220521191337](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521191337.png)

此处对这个问题而言, $C$ 就是它的一个 `Certificate`, 可被 **简单轻松地用来检测问题是否有解**. 任何被归类为 `Class NP` 的问题都有相应的 `Certificate`, 也正因如此可以看到, $P \in NP$.

我们再来考虑更复杂的问题: `k-SAT` 问题. 

`k-SAT` 问题关注的是 **对每个子句中最多有 $k$ 个文字** 的合取范式 (`CNF`) 的可满足性问题. (回顾 `COMP21111`)

其中, 实际上:

1. `SAT` 和 `3-SAT` 问题可互相转换, 并且它们都是 `NP` 问题, 而且其实它们也都是 `NP-Complete` 的. 
2. `2-SAT` 可在多项式时间内被求解. 

![20220521191901](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521191901.png)

以及其他的一些 `NP` 问题:

![20220521192114](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521192114.png)

对于上述的问题而言, 它们的 `Certificate` 分别为: 

1. 满足条件的集合 $S$.
2. 一系列长不超过 $k$ 的操作序列, 可被证明确实满足条件. 
3. 现成的, 不超过 $k$ 的一个序列, 可被证明确实是两个字符串的公共序列. 

因此, 我们下面给出 **基于可在多项式时间内对问题是否有解进行验证** 的 `Class NP` 的定义: 

对于给定问题语言 $L$, 如果存在某个 **验证函数 $A$**, 该函数接受 **决策结果** $x$ 和对应的 `Certificate` $y$, 可以在 **多项式时间内** 证明 $x$ 是否在 `Certificate` 的条件下确实为对应的解, 也就是 ($A(x, y)=1$), 则称这样的问题语言 $L$ 属于 `NP` 类.

而 `Class NP` 就是所有满足上述条件的问题语言组成的集合.

![20220521192758](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521192758.png)

同时, 我们对应给出 **基于非确定性计算** 的 `Class NP` 的定义: 

我们称 `Class NP` 是所有可以使用 **在非确定性计算机上运行的算法** 在 **多项式时间内** 求解的问题组成的集合. 

在这里, **非确定性计算机** 指具有 **可以同时执行所有可能的计算** 的, 理论上的计算机.

![20220521193119](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521193119.png)

需要注意: 这两个定义是 **等价** 的. 经过多项式时间的 **非确定性计算**, 生成的 `Certificate` 也是 **多项式长度** 的.

需要注意的是: 如果我们能够制造出这样的 **非确定性计算机**, 则 `P=NP`, 反之则有 `P!=NP`. 由于这样的计算机尚未建成, 但又无法证明我们确实造不出这样的计算机, 因此 **我们尚未明确 `P=NP` 还是 `P != NP`**. (相关习题里有一个与这个结论相关的, 很nasty的题. 顺带一提, 截止目前量子计算机是最接近这一定义的.)

#### 分析计算困难度时对问题实际困难程度简化的技术 (`Reduction`)

我们在上一节中已经看到, 不同的问题之间存在一定的联系, 某种问题可以被转化为另外一种问题, 而且我们观察到可以互相转换的问题之间, 它们的计算困难度似乎有一定的关联. 下面我们正式介绍 `Reduction` 的概念, 介绍如何正确地定义 “某个问题必难于另一个问题”.

首先在此处 **不加证明** 地给出下列结论:

若存在问题语言 $L_1, L_2$, 且 $L_1$ 可在 **多项式时间内** 被转化为 $L_2$, 则有: $L_1$ 的计算困难度 **不高于** (小于等于) $L_2$.

![20220521200952](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521200952.png)

注意: 此处就有结论:

1. $L_1$ 简单不意味着 $L_2$ 一定简单, 但 $L_1$ 难一定意味着 $L_2$ 至少不会更简单.
2. $L_2$ 难不意味着 $L_1$ 一定难, 但 $L_2$ 简单一定意味着 $L_1$ 至少不会更难.
3. 偏序关系 $\leqslant_{P}$ 是具有 **传递性** 的.

其次给出 `Class NPC` 的定义:

![20220521201202](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201202.png)

注意, 任何为 `NPC` 的问题语言 $L$ 必须同时满足: 

1. $L$ 也是 `NP` 的.
2. $L$ 同时不比 **其他任何 `NP`** 问题简单, 也就是说 “任何其他 `NP` 问题都可 **在多项式时间内** 被 `reduce` 为 `L`”.

### 相关题目解析

![20220521201627](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201627.png)

($\uparrow$ 基础的定义问题, 包含关系弄反了)

![20220521201655](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201655.png)

($\uparrow$ 这个问题的答案本质上是 `P != NP?` 的答案. 但是 `P != NP?` 有答案吗? 想想量子计算机.)

![20220521201818](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201818.png)

($\uparrow$ 对 `NP` 问题 `Certificate` 检测的时间复杂度必须是 **关于输入长度呈多项式级** 的.)

![20220521201946](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201946.png)

![20220521201956](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521201956.png)

($\uparrow$ 记住偏序关系 $\leqslant_{P}$ 的构造顺序: **若$A$ 可被多项式时间内简化为 $B$, 则计算困难度关系为 $A \leqslant_{P} B$**.)

![20220521202113](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20220521202113.png)

($\uparrow$ 记住: 对于 `NP` 问题, 其 `certificate` 的长度和检验 `certificae` 消耗的时间都要与其 **输入长度而非输入数值大小** 的变化呈 **多项式** 级别的关系.)

## `NP-Hardness` 和 `NP-Complete` 问题类



## `NP-Complete` 问题

## 问题简化方法