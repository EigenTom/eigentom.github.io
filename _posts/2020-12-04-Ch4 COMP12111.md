---
layout:     post
title:      Ch4 MU0：控制部分简介
subtitle:   Introducing the controllers
date:       2020-12-04
author:     R1NG
header-img: img/post-bg-ios9-web.jpg
description: 在本章中，我们将简介MU0处理器的控制器设计，包括一个简单的有限状态机，一个结合指令和当前状态进行控制信号转译的翻译器，以及统揽两者的控制模块。
catalog: true
tags:
    - COMP12111
    - 课程笔记
    - 2020
---

# COMP12111 计算机组成结构: `MU0` 处理器控制部分简介

在本章中, 我们将简介MU0处理器的控制器设计:<br>
1. `MU0` 的结构和支持指令类型简介
2. 一个简单的有限状态机
3. 一个结合指令和当前状态进行控制信号转译的翻译器
4. 一个统揽两者的控制模块. 
5. 上述模块的 `Verilog` 实现


<br>
<br>


## 1. `MU0` 结构和指令列表
`MU0` 是一个 $16$ 位处理器, 其数据传输界面包含:
- `Clk`: 处理器时钟信号输入
- `Reset`: 处理器复位信号输入
- `Halted`: 处理器停机信号输入
- `Address`: 地址信号输出总线, 总线位宽 $12$ 位. 
- `Rd`: 内存读取控制信号输出
- `Wr`: 内存写入控制信号输出
- `Data_out`: 数据信号输出总线, 总线位宽 $16$ 位. 
- `Data_in`: 数据信号输入总线, 总线位宽 $16$ 位. 



<center>处理器结构拓扑图如下:</center>




![20201205111433](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201205111433.png)


注: <br>
`MU0` 处理器依赖 `Rd` 和 `Wr` 信号激活和控制内存界面. 当相应的信号处于高电平时, 从处理器数据信号输出总线或地址信号输出总线输出的数据将会被传递至内存, 并依此执行读取/写入操作. 需要注意的是, 由于内存界面在同一时刻无法并行执行内存的读取/写入, 这两个信号不能同时处于高电平状态. 

<br>

`MU0` 处理器为程序员提供了两个寄存器: 一个 $16$ 位的累加寄存器 `Acc`, 一个 $12$ 位的程序计数器 `PC`. <br>
`MU0` 处理器的指令长为 $16$ 位, 其头部 $4$ 位为指令位, 剩余的 $12$ 位存储操作符. 



![20201205111529](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201205111529.png)



`MU0` 处理器所支持的指令如下:

|二进制编码|助记符|功能|
|:-:|:-:|:-|
|$0000$|`LDA S`|从内存位置 `S` 处加载内容至累加寄存器中|
|$0001$|`STA S`|将累加寄存器的内容储存至内存位置 `S` 中|
|$0010$|`ADD S`|将内存位置 `S` 处的内容和累加寄存器中的数据相加|
|$0011$|`SUB S`|将内存位置 `S` 处的内容和累加寄存器中的数据相减|
|$0100$|`JMP S`|跳转到地址 `S` 处|
|$0101$|`JGE S`|若在该指令前所执行的比较指令结果为非负, 跳转至地址 `S` 处|
|$0110$|`JNE S`|若在该指令前所执行的比较指令结果不为零, 跳转至地址 `S` 处|
|$0111$|`STP`|停机指令|
|$1000-1111$|`-`|预留, 无实际作用|


`MU0` 的控制模块可以被细分为两个部分: 一个作为状态转换器的有限状态机, 和一个基于当前指令和当前状态转译数据流控制信号的翻译器. 

![20201205113228](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201205113228.png)


<br>


## 2. `MU0`状态转换器: `FSM`

`MU0` 中作为状态转换器的有限状态机功能较为简单, 只在 `取指令 - 转译/执行` 这两种状态之间基于时钟信号周期性地来回转换. 其状态图如下图所示:


![20201205113514](https://cdn.jsdelivr.net/gh/KirisameMarisaa/KirisameMarisaa.github.io/img/blogpost_images/20201205113514.png)



<br>

## 3. `MU0` 控制信号翻译器
控制信号翻译器接受来自外界的指令输入 `F`, 并监听复位信号 `Reset` , 时钟信号 `Clk` 以及两个分支条件判断结果 `flag`: `N, Z`, 从而处理, 转译和生成控制数据流的控制信号. 

基于 `MU0` 处理器数据流的设计, `MU0` 控制信号翻译器需要同时输出 $7$ 个信号, 对一个 `ALU`, 三个分选器和三个寄存器进行控制: 


|控制信号|功能|
|-|-|
|`PC_En`|控制程序计数器是否可写. 若设为高电平, 则在下一个时钟上升沿, 程序计数器内现存的值将被传入的数据所覆盖. |
|`Acc_En`|控制累加寄存器是否可写. 若设为高电平, 则在下一个时钟上升沿, 累加寄存器内现存的值将被传入的数据所覆盖.|
|`IR_En`|控制指令寄存器是否可写. 若设为高电平, 则在下一个时钟上升沿, 指令寄存器内现存的值将被传入的数据所覆盖. |
|`X Y_sel`|控制分选器 `X, Y`. |
|`Addr_sel`|控制地址输出分选器. |
|`M[1:0]`|宽为 $2$ 的控制信号输出, 控制 `ALU` 执行的运算类型. |
|`Halted`|停机信号, 当且仅当处理器处于停机状态下时输出高电平. |

<br>

`MU0` 数据流中的 `ALU` 模组我们已经作为第二次 `Lab` 的实践内容完成, 因此在此不多赘述其组成结构和原理, 仅简要复述一下其可执行的运算类型和对应的控制指令: 

|二进制指令|运算类型|-|
|:-:|:-:|:-|
|$00$|$Y$|仅传递 $Y$ 的值|
|$01$|$X+Y$|执行两个操作数之间的加法|
|$10$|$X+1$|将操作数 $X$ 加 $1$|
|$11$|$X-Y$|执行两个操作数之间的减法|

<br>

## 4. `MU0` 控制模块
`MU0` 的控制模块仅作为上述两个子模块的简单组合, 将状态转换器和控制信号翻译器之间用一根传递当前状态的内部链路相联结. 在第五部分中, 我们可以非常清晰地看到具体的实现方式. 

<br>


## 5. `MU0` 控制器的 `Verilog` 实现

详见博文: `Lab3 COMP12111`. 