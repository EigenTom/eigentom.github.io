---
layout:     post
title:      高级计算机图形学:每周习题解析
subtitle:   Solution to Weekly Quiz
date:       2022-10-07
author:     R1NG
header-img: img/post-bg-comp37111.jpg
description: 每周习题解析
catalog: true
tags:
    - 课程笔记
    - 高级计算机图形学
---

# 每周习题解析

## Week I

TBA

## Week II

![20221007125402](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221007125402.png)

答案为 `B`. `A` 和 `D` 显然错误, `C` 在此处所考虑的更多是 “在游戏中创建人物” 的流水线, 和构建模型无关.

<br>

![20221007125513](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221007125513.png)

`A` 显然是错误的 (因此是正确答案): 由于曲线的隐式表示形如 $F(x, y, z) = 0$, 故若要 `trace a variable`, i.e., 给定自变量 $x, y$ 求因变量 $z$, 不同于显式表示和参数化表示的情形可以直接得出结果, 我们需要 **求解隐式表示的方程** 才能得到对应的 $z$. 

其余选项的描述都是正确的, 此处不作赘述.

![20221007130519](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221007130519.png)

此题比较有趣. 首先 `Frenet` 标架的主要作用是基于曲线上的点确定关于这个点的坐标系, 因此 **它利用了曲线的几何性质**, 但 **并未描述曲线的任何几何性质**. 其次, 在剩下三个选项中可能出错的是 `C`. 其解释如下: 实际上在转折点 (`Inflection Point`) 处真正发生翻转的是法线 $N$, 但 **这是结果而非原因**. 从直接原因的角度看, $T$ 向量就是切线向量, 被曲线的一阶导数描述, 是切线向量的转折导致了法线向量的翻转.

![20221007130955](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221007130955.png)

回顾曲线隐式表示的定义, 可知代入点 $(0, 0, 0)$ 时表达式值为 $1$ 大于 $0$, 符合 “位于曲线外” 的情况.

![20221007131058](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221007131058.png)

`A` 错误: 使用双三次贝塞尔表示法表示的曲面控制点数量是 $16$ 个.
`B` 错误: 向网格中添加新的点和边都非常方便.
`C` 正确: 任何情况下使用任何方式建模的曲面最后在渲染管线中都会被栅格化.
`D` 错误: `Displaced Surface` 是凹凸不平的, 因为平面上的点的高度会基于 `Displacement Map` 中存储的 `offset` 被抬升对应的高度, 形成 **凹凸不平** 的曲面. 

## Week III

![20221013154010](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221013154010.png)

在构造物体运动的动画时, 对物体加速度程度的建模基于它的 **质量**.

![20221013154625](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221013154625.png)

`Rigging`: 绑定, 构造骨骼约束.
`Skinning`: 蒙皮, 将骨骼和模型结合起来: 把 “蒙皮” 上的关键点映射到骨骼的对应位置上.
`Tweening`: 自动插值补全关键帧间的动画, 又称补间.
`Posing`: 将模型摆出特定的姿势.

基于题意可知, 在完成 `Rigging` 后下一步自然需要进行蒙皮操作.

![20221013154608](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221013154608.png)

色度图 (`Chromaticity Diagram`) 是从完整的色彩空间 **拍扁到二维平面上** 得到的, 因此它 **不包含明度信息**. 由此可知, 在更改颜色的亮度后, 它在色度图中的坐标 **不变**.

![20221013154806](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221013154806.png)

物体的颜色取决于它 **不吸收什么波长的光**, 若一个物体看上去为白色, 说明它 **不吸收任何波长的光**. 若某个物体吸收 **所有波长的光**, 则它看上去应该是 **纯黑色**. 其余选项均正确.

![20221013154914](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221013154914.png)

第二个视频中已经说明, 电影行业的帧速率标准 (大概) 为 $24\text{fps}$, 对视频而言 $30\text{fps}$ 已经够用, 视频网站, 手机和相机的默认视频播放/录制帧速率都是 $30\text{fps}$. 对于 `VR`, 为避免眩晕, 内建的显示屏需要提供至少 $90\text{fps}$ 的刷新率.

## Week IV

## Week V

## Week VI

![20221225181853](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225181853.png)

渲染方程的一大重要假设就是: 在场景的某个点上观察到的光是该点自身发出的光和从所有其他点射到此处的所有光的合成. 由于可见光也可视为能量辐射, 因此这对应热力学第一定律: 物体内能的增加等于物体吸收的热量和对物体所作的功的总和.

![20221225182110](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225182110.png)

渲染方程只关心 **观察点到被观察点之间的角度**, 并未真正考虑观察点的具体位置.

![20221225182155](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225182155.png)

基于 `Lambert Law` 可知: 入射光线恰好垂直于平面时, 光强最大.

![20221225182242](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225182242.png)

原因正确但结论不对: 在第一个视频的末尾提到, 正是因为渲染方程是 `Fredholm Equation of Second Kind`, 因此我们无法求出它的分析解.

![20221225182336](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225182336.png)

`a)` 为我们从观察点所观测的, 目标点发散出的能量辐射 (`Radiance`), `b)` 为该点自身发散出的能量辐射 (`Radiance`), `d` 为不同方向上射入目标点的能量辐照 (`Irradiance`).

![20221225182604](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225182604.png)

此题显然, 不做解释.

![20221225182634](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225182634.png)

原因正确但结论显然错误. 项 `e)` 是 `Lambert Cosine Law Factor`.

## Week VII

## Week VIII

![20221225212827](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225212827.png)

传统的光线追踪首先可以实现所有的 `Specular` 效果和 `Hard Shadow`. 其次, 由于它以 **确定性** 的方式对光线的传播路径进行绝对精确的追踪, 因此它可以同时渲染出反射 (`Reflection`) 和折射 (`Refraction`) 效果. 最后, 在 `nVIDIA` 的视频 $7$ 中, 明确提及传统光线追踪也可支持类似丁达尔效应的 `Participating Media` 和视觉景深效果.

![20221225213029](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225213029.png)

辐射着色的效果与任何 `Specular` 效果无缘. 在此基础上, 由于它的渲染逻辑基于 “物体表面之间的辐射交换”, 因此自然具有渲染出 `Color Bleed` 和 `Diffuse Interreflection` 的能力. 此外, 辐射着色渲染出的影子自然具有柔和的边界.

![20221225213226](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225213226.png)

路径追踪具有上述的全部性质.

![20221225213337](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225213337.png)

在只使用 `BRDF` 结合渲染方程对场景进行渲染时, 首先由于没有考虑 `BTDF`, 因此自然无法渲染折射 `Refraction`. 其次, 由于缺乏光线追踪或路径追踪对视觉景深的模拟, 单纯使用 `BRDF` 无法渲染出景深. 同样, `BRDF` 无法渲染出 `Relativistic Effect`. 最后, 由于 `BRDF` 是基于热力学的, 它自然也无法渲染 **冷发光效果** (`Luminsense`). 

![20221225213703](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225213703.png)

注意: 纹理烘焙技术本身不依赖于视点的位置: 即便改变视点位置也不需要重新烘焙纹理贴图. 但烘焙到纹理贴图中的信息只有结合特定的视点位置才能得到最佳效果, 因此一旦移动视点, 纹理烘焙就无法再模拟物体表面的平滑高光, 平滑反射或折射, 而纹理烘焙技术更不可能模拟景深. 

![20221225214114](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225214114.png)

采样不足的话会导致渲染出的场景具有两个问题: `Noisy` 和 `Inaccurate`. 

![20221225213855](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225213855.png)

显然, 增加每个像素的采样数会导致计算复杂度随着像素数量 **线性** 增加, 也就是随着视平面的大小而增加: 视平面越大, 包含的像素数就越多.

![20221225213955](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221225213955.png)

作为基于热力学的渲染方法, 辐射着色自然与视点位置无关. 而变换视点位置也不会导致我们不得不重新烘焙纹理贴图, 唯一的后果就是让效果变得不真实.

## Week IX

![20221226141219](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226141219.png)

回顾直接体积渲染的相关知识: 由于直接体积渲染中包含类似于 ”光线的路径追踪“ 的流程, 因此它的渲染结果是 `Viewpoint-Dependent` 的. 不过需要注意: 在渲染前对 `Volume Set` 中每个 `Voxel` 的颜色和透明度的计算是 `Viewpoint-Independent` 的, 因为它只基于我们的实际观测需求和所有 `Voxels` 中数值的分布情况.

![20221226141500](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226141500.png)

直接体积渲染以来的数据结构是 `Voxel Array`, 也称为 `Volume Set`.

![20221226141532](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226141532.png)

原始数据中每个 `Voxel` 存储的数值可以是使用任何测量手段得到的, 关于物体的某种测度, 不局限于频率, 密度等; 如第一题的解释中提及的一样, 颜色和透明度在视角变换时无需被重新计算.

![20221226141705](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226141705.png)

回顾间接体积渲染中, 使用 `Marching Cube` 方法计算 `ISO Surface` 所存在的问题: 由于 `Ambiguity`, 我们计算出的曲面多边形很可能是不真实的. 即便使用 `Proxy Geometry`, 在视角变换时也 **不一定非得重新计算切片**, 只不过不计算的话会使视觉效果不真实而已.

![20221226141847](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226141847.png)

多边形网格可以直接用于执行常规渲染, 执行体积渲染需要提供对物体的某种测度.

## Week X

![20221226170337](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226170337.png)

`Gridcell` 背后的数据结构是 $3$ 维数组.

![20221226170408](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226170408.png)

$3$ 维数组的访问时间复杂度是 $O(1)$.

![20221226170436](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226170436.png)

`Gridcell` 和 `Octree` 的索引构建过程都是基于给定规则的.

![20221226170537](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226170537.png)

`Binary Space Partitioning` 分划可以保留空间中的相对前后, 上下和左右关系.

![20221226170605](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226170605.png)

不做解释, 概念题.

![20221226171527](https://cdn.jsdelivr.net/gh/KirisameR/KirisameR.github.io/img/blogpost_images/20221226171527.png)

注意此处的 “**Projected** winding”, 这意味着多边形已经被渲染, 从而意味着此时再进行检测起到的仅是类似 `z-buffer` 的作用, 因此无法对渲染时间的提升起到有价值的帮助.